// protoc-gen-geo generates geolocation features with Google Maps
// Store locator, distance calculation, spatial queries
// Uses Category Theory: Monoid + Functor + Fold
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// =============================================================================
// CATEGORY THEORY FOUNDATIONS
// =============================================================================

type Monoid[A any] struct {
	Empty  func() A
	Append func(A, A) A
}

type Code struct{ Run func() string }

var CodeMonoid = Monoid[Code]{
	Empty:  func() Code { return Code{Run: func() string { return "" }} },
	Append: func(a, b Code) Code { return Code{Run: func() string { return a.Run() + b.Run() }} },
}

func FoldRight[A, B any](xs []A, z B, f func(A, B) B) B {
	if len(xs) == 0 {
		return z
	}
	return f(xs[0], FoldRight(xs[1:], z, f))
}

func Concat[A any](m Monoid[A], xs []A) A {
	return FoldRight(xs, m.Empty(), func(a A, acc A) A { return m.Append(a, acc) })
}

func Map[A, B any](xs []A, f func(A) B) []B {
	return FoldRight(xs, []B{}, func(a A, acc []B) []B { return append([]B{f(a)}, acc...) })
}

func Filter[A any](xs []A, pred func(A) bool) []A {
	return FoldRight(xs, []A{}, func(a A, acc []A) []A {
		if pred(a) {
			return append([]A{a}, acc...)
		}
		return acc
	})
}

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }

// =============================================================================
// MESSAGE ANALYSIS
// =============================================================================

type GeoMessage struct {
	Name         string
	HasLatitude  bool
	HasLongitude bool
	LatField     string
	LngField     string
	Fields       []FieldInfo
}

type FieldInfo struct {
	Name   string
	GoName string
	GoType string
}

func AnalyzeMessage(msg *protogen.Message) *GeoMessage {
	gm := &GeoMessage{
		Name: msg.GoIdent.GoName,
	}

	for _, f := range msg.Fields {
		name := strings.ToLower(string(f.Desc.Name()))
		goName := f.GoName

		// Detect latitude field
		if strings.Contains(name, "lat") || name == "latitude" {
			gm.HasLatitude = true
			gm.LatField = goName
		}

		// Detect longitude field
		if strings.Contains(name, "lng") || strings.Contains(name, "lon") || name == "longitude" {
			gm.HasLongitude = true
			gm.LngField = goName
		}

		gm.Fields = append(gm.Fields, FieldInfo{
			Name:   string(f.Desc.Name()),
			GoName: goName,
			GoType: goTypeForField(f),
		})
	}

	return gm
}

func goTypeForField(f *protogen.Field) string {
	switch f.Desc.Kind() {
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.BoolKind:
		return "bool"
	default:
		return "interface{}"
	}
}

func IsGeoMessage(gm *GeoMessage) bool {
	return gm.HasLatitude && gm.HasLongitude
}

// =============================================================================
// GO BACKEND GENERATOR
// =============================================================================

func GenerateGeoBackend(pkgName string, geoMessages []*GeoMessage) Code {
	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-geo. DO NOT EDIT."),
		Line("// Geolocation features: distance calculation, spatial queries, store locator"),
		Blank(),
		Linef("package %s", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"math"`),
		Line(`	"sort"`),
		Line(`	"sync"`),
		Line(")"),
		Blank(),
		GenerateGeoConstants(),
		GenerateGeoTypes(),
		GenerateHaversine(),
		GenerateBoundingBox(),
		GenerateGeoHash(),
		GenerateSpatialIndex(),
		GenerateGeoRepository(geoMessages),
		GenerateGeoService(geoMessages),
	})
}

func GenerateGeoConstants() Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// CONSTANTS"),
		Line("// ============================================================================="),
		Blank(),
		Line("const ("),
		Line("	// Earth's radius in kilometers"),
		Line("	EarthRadiusKm = 6371.0"),
		Line("	// Earth's radius in miles"),
		Line("	EarthRadiusMiles = 3959.0"),
		Line("	// Default search radius in km"),
		Line("	DefaultRadiusKm = 50.0"),
		Line("	// Default result limit"),
		Line("	DefaultLimit = 20"),
		Line("	// GeoHash precision (characters)"),
		Line("	GeoHashPrecision = 7"),
		Line(")"),
		Blank(),
	})
}

func GenerateGeoTypes() Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// GEO TYPES"),
		Line("// ============================================================================="),
		Blank(),
		Line("// Coordinates represents a geographic point"),
		Line("type Coordinates struct {"),
		Line("	Latitude  float64"),
		Line("	Longitude float64"),
		Line("}"),
		Blank(),
		Line("// BoundingBox represents a geographic rectangle"),
		Line("type BoundingBox struct {"),
		Line("	MinLat float64"),
		Line("	MaxLat float64"),
		Line("	MinLng float64"),
		Line("	MaxLng float64"),
		Line("}"),
		Blank(),
		Line("// GeoResult wraps an item with its distance from a reference point"),
		Line("type GeoResult[T any] struct {"),
		Line("	Item       T"),
		Line("	DistanceKm float64"),
		Line("}"),
		Blank(),
		Line("// FindNearestOptions configures nearest-neighbor search"),
		Line("type FindNearestOptions struct {"),
		Line("	Center   Coordinates"),
		Line("	RadiusKm float64"),
		Line("	Limit    int"),
		Line("}"),
		Blank(),
		Line("// GeoLocatable interface for items with coordinates"),
		Line("type GeoLocatable interface {"),
		Line("	GetCoordinates() Coordinates"),
		Line("	GetID() string"),
		Line("}"),
		Blank(),
	})
}

func GenerateHaversine() Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// HAVERSINE DISTANCE CALCULATION"),
		Line("// ============================================================================="),
		Blank(),
		Line("// Haversine calculates the great-circle distance between two points"),
		Line("// using the Haversine formula. Returns distance in kilometers."),
		Line("func Haversine(lat1, lng1, lat2, lng2 float64) float64 {"),
		Line("	// Convert to radians"),
		Line("	lat1Rad := lat1 * math.Pi / 180"),
		Line("	lat2Rad := lat2 * math.Pi / 180"),
		Line("	lng1Rad := lng1 * math.Pi / 180"),
		Line("	lng2Rad := lng2 * math.Pi / 180"),
		Blank(),
		Line("	// Differences"),
		Line("	dLat := lat2Rad - lat1Rad"),
		Line("	dLng := lng2Rad - lng1Rad"),
		Blank(),
		Line("	// Haversine formula"),
		Line("	a := math.Sin(dLat/2)*math.Sin(dLat/2) +"),
		Line("		math.Cos(lat1Rad)*math.Cos(lat2Rad)*"),
		Line("		math.Sin(dLng/2)*math.Sin(dLng/2)"),
		Blank(),
		Line("	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))"),
		Blank(),
		Line("	return EarthRadiusKm * c"),
		Line("}"),
		Blank(),
		Line("// HaversineCoords calculates distance between two Coordinates"),
		Line("func HaversineCoords(c1, c2 Coordinates) float64 {"),
		Line("	return Haversine(c1.Latitude, c1.Longitude, c2.Latitude, c2.Longitude)"),
		Line("}"),
		Blank(),
		Line("// HaversineMiles calculates distance in miles"),
		Line("func HaversineMiles(lat1, lng1, lat2, lng2 float64) float64 {"),
		Line("	return Haversine(lat1, lng1, lat2, lng2) * 0.621371"),
		Line("}"),
		Blank(),
	})
}

func GenerateBoundingBox() Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// BOUNDING BOX"),
		Line("// ============================================================================="),
		Blank(),
		Line("// BoundingBoxFromCenter creates a bounding box around a center point"),
		Line("func BoundingBoxFromCenter(center Coordinates, radiusKm float64) BoundingBox {"),
		Line("	// Latitude: 1 degree â‰ˆ 111 km"),
		Line("	latDelta := radiusKm / 111.0"),
		Blank(),
		Line("	// Longitude: varies by latitude"),
		Line("	lngDelta := radiusKm / (111.0 * math.Cos(center.Latitude*math.Pi/180))"),
		Blank(),
		Line("	return BoundingBox{"),
		Line("		MinLat: center.Latitude - latDelta,"),
		Line("		MaxLat: center.Latitude + latDelta,"),
		Line("		MinLng: center.Longitude - lngDelta,"),
		Line("		MaxLng: center.Longitude + lngDelta,"),
		Line("	}"),
		Line("}"),
		Blank(),
		Line("// Contains checks if a point is within the bounding box"),
		Line("func (bb BoundingBox) Contains(c Coordinates) bool {"),
		Line("	return c.Latitude >= bb.MinLat &&"),
		Line("		c.Latitude <= bb.MaxLat &&"),
		Line("		c.Longitude >= bb.MinLng &&"),
		Line("		c.Longitude <= bb.MaxLng"),
		Line("}"),
		Blank(),
		Line("// Expand increases the bounding box by a factor"),
		Line("func (bb BoundingBox) Expand(factor float64) BoundingBox {"),
		Line("	latDelta := (bb.MaxLat - bb.MinLat) * (factor - 1) / 2"),
		Line("	lngDelta := (bb.MaxLng - bb.MinLng) * (factor - 1) / 2"),
		Line("	return BoundingBox{"),
		Line("		MinLat: bb.MinLat - latDelta,"),
		Line("		MaxLat: bb.MaxLat + latDelta,"),
		Line("		MinLng: bb.MinLng - lngDelta,"),
		Line("		MaxLng: bb.MaxLng + lngDelta,"),
		Line("	}"),
		Line("}"),
		Blank(),
	})
}

func GenerateGeoHash() Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// GEOHASH"),
		Line("// ============================================================================="),
		Blank(),
		Line("const base32 = \"0123456789bcdefghjkmnpqrstuvwxyz\""),
		Blank(),
		Line("// EncodeGeoHash encodes coordinates to a geohash string"),
		Line("func EncodeGeoHash(lat, lng float64, precision int) string {"),
		Line("	if precision <= 0 {"),
		Line("		precision = GeoHashPrecision"),
		Line("	}"),
		Blank(),
		Line("	var ("),
		Line("		minLat, maxLat = -90.0, 90.0"),
		Line("		minLng, maxLng = -180.0, 180.0"),
		Line("		hash           = make([]byte, precision)"),
		Line("		bit            = 0"),
		Line("		ch             = 0"),
		Line("		isLng          = true"),
		Line("	)"),
		Blank(),
		Line("	for i := 0; i < precision; i++ {"),
		Line("		for j := 0; j < 5; j++ {"),
		Line("			if isLng {"),
		Line("				mid := (minLng + maxLng) / 2"),
		Line("				if lng >= mid {"),
		Line("					ch |= 1 << (4 - bit)"),
		Line("					minLng = mid"),
		Line("				} else {"),
		Line("					maxLng = mid"),
		Line("				}"),
		Line("			} else {"),
		Line("				mid := (minLat + maxLat) / 2"),
		Line("				if lat >= mid {"),
		Line("					ch |= 1 << (4 - bit)"),
		Line("					minLat = mid"),
		Line("				} else {"),
		Line("					maxLat = mid"),
		Line("				}"),
		Line("			}"),
		Line("			isLng = !isLng"),
		Line("			bit++"),
		Line("			if bit == 5 {"),
		Line("				hash[i] = base32[ch]"),
		Line("				bit = 0"),
		Line("				ch = 0"),
		Line("			}"),
		Line("		}"),
		Line("	}"),
		Blank(),
		Line("	return string(hash)"),
		Line("}"),
		Blank(),
		Line("// GeoHashNeighbors returns the 8 neighboring geohash cells"),
		Line("func GeoHashNeighbors(hash string) []string {"),
		Line("	// Simplified: return prefix matches for nearby search"),
		Line("	if len(hash) <= 1 {"),
		Line("		return []string{hash}"),
		Line("	}"),
		Line("	prefix := hash[:len(hash)-1]"),
		Line("	neighbors := make([]string, 0, 32)"),
		Line("	for _, c := range base32 {"),
		Line("		neighbors = append(neighbors, prefix+string(c))"),
		Line("	}"),
		Line("	return neighbors"),
		Line("}"),
		Blank(),
	})
}

func GenerateSpatialIndex() Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// SPATIAL INDEX (GeoHash-based)"),
		Line("// ============================================================================="),
		Blank(),
		Line("// SpatialIndex provides fast spatial lookups using geohash"),
		Line("type SpatialIndex[T GeoLocatable] struct {"),
		Line("	mu        sync.RWMutex"),
		Line("	items     map[string]T            // id -> item"),
		Line("	geoIndex  map[string][]string     // geohash -> []id"),
		Line("	precision int"),
		Line("}"),
		Blank(),
		Line("// NewSpatialIndex creates a new spatial index"),
		Line("func NewSpatialIndex[T GeoLocatable](precision int) *SpatialIndex[T] {"),
		Line("	if precision <= 0 {"),
		Line("		precision = GeoHashPrecision"),
		Line("	}"),
		Line("	return &SpatialIndex[T]{"),
		Line("		items:     make(map[string]T),"),
		Line("		geoIndex:  make(map[string][]string),"),
		Line("		precision: precision,"),
		Line("	}"),
		Line("}"),
		Blank(),
		Line("// Insert adds an item to the index"),
		Line("func (idx *SpatialIndex[T]) Insert(item T) {"),
		Line("	idx.mu.Lock()"),
		Line("	defer idx.mu.Unlock()"),
		Blank(),
		Line("	id := item.GetID()"),
		Line("	coords := item.GetCoordinates()"),
		Line("	hash := EncodeGeoHash(coords.Latitude, coords.Longitude, idx.precision)"),
		Blank(),
		Line("	idx.items[id] = item"),
		Line("	idx.geoIndex[hash] = append(idx.geoIndex[hash], id)"),
		Line("}"),
		Blank(),
		Line("// Remove removes an item from the index"),
		Line("func (idx *SpatialIndex[T]) Remove(id string) {"),
		Line("	idx.mu.Lock()"),
		Line("	defer idx.mu.Unlock()"),
		Blank(),
		Line("	item, ok := idx.items[id]"),
		Line("	if !ok {"),
		Line("		return"),
		Line("	}"),
		Blank(),
		Line("	coords := item.GetCoordinates()"),
		Line("	hash := EncodeGeoHash(coords.Latitude, coords.Longitude, idx.precision)"),
		Blank(),
		Line("	delete(idx.items, id)"),
		Blank(),
		Line("	// Remove from geohash index"),
		Line("	ids := idx.geoIndex[hash]"),
		Line("	for i, itemID := range ids {"),
		Line("		if itemID == id {"),
		Line("			idx.geoIndex[hash] = append(ids[:i], ids[i+1:]...)"),
		Line("			break"),
		Line("		}"),
		Line("	}"),
		Line("}"),
		Blank(),
		Line("// FindNearest finds items near a point within radius"),
		Line("func (idx *SpatialIndex[T]) FindNearest(opts FindNearestOptions) []GeoResult[T] {"),
		Line("	idx.mu.RLock()"),
		Line("	defer idx.mu.RUnlock()"),
		Blank(),
		Line("	if opts.RadiusKm <= 0 {"),
		Line("		opts.RadiusKm = DefaultRadiusKm"),
		Line("	}"),
		Line("	if opts.Limit <= 0 {"),
		Line("		opts.Limit = DefaultLimit"),
		Line("	}"),
		Blank(),
		Line("	// Get candidate geohashes"),
		Line("	centerHash := EncodeGeoHash(opts.Center.Latitude, opts.Center.Longitude, idx.precision)"),
		Line("	candidateHashes := GeoHashNeighbors(centerHash)"),
		Line("	candidateHashes = append(candidateHashes, centerHash)"),
		Blank(),
		Line("	// Collect candidate items"),
		Line("	seen := make(map[string]bool)"),
		Line("	var results []GeoResult[T]"),
		Blank(),
		Line("	for _, hash := range candidateHashes {"),
		Line("		for _, id := range idx.geoIndex[hash] {"),
		Line("			if seen[id] {"),
		Line("				continue"),
		Line("			}"),
		Line("			seen[id] = true"),
		Blank(),
		Line("			item := idx.items[id]"),
		Line("			coords := item.GetCoordinates()"),
		Line("			dist := HaversineCoords(opts.Center, coords)"),
		Blank(),
		Line("			if dist <= opts.RadiusKm {"),
		Line("				results = append(results, GeoResult[T]{"),
		Line("					Item:       item,"),
		Line("					DistanceKm: dist,"),
		Line("				})"),
		Line("			}"),
		Line("		}"),
		Line("	}"),
		Blank(),
		Line("	// Sort by distance"),
		Line("	sort.Slice(results, func(i, j int) bool {"),
		Line("		return results[i].DistanceKm < results[j].DistanceKm"),
		Line("	})"),
		Blank(),
		Line("	// Limit results"),
		Line("	if len(results) > opts.Limit {"),
		Line("		results = results[:opts.Limit]"),
		Line("	}"),
		Blank(),
		Line("	return results"),
		Line("}"),
		Blank(),
		Line("// FindWithinBox finds items within a bounding box"),
		Line("func (idx *SpatialIndex[T]) FindWithinBox(bb BoundingBox) []T {"),
		Line("	idx.mu.RLock()"),
		Line("	defer idx.mu.RUnlock()"),
		Blank(),
		Line("	var results []T"),
		Line("	for _, item := range idx.items {"),
		Line("		coords := item.GetCoordinates()"),
		Line("		if bb.Contains(coords) {"),
		Line("			results = append(results, item)"),
		Line("		}"),
		Line("	}"),
		Line("	return results"),
		Line("}"),
		Blank(),
		Line("// Count returns the number of indexed items"),
		Line("func (idx *SpatialIndex[T]) Count() int {"),
		Line("	idx.mu.RLock()"),
		Line("	defer idx.mu.RUnlock()"),
		Line("	return len(idx.items)"),
		Line("}"),
		Blank(),
	})
}

func GenerateGeoRepository(geoMessages []*GeoMessage) Code {
	parts := []Code{
		Line("// ============================================================================="),
		Line("// GEO-ENABLED REPOSITORIES"),
		Line("// ============================================================================="),
		Blank(),
	}

	for _, gm := range geoMessages {
		if !IsGeoMessage(gm) {
			continue
		}
		parts = append(parts, GenerateGeoRepositoryForMessage(gm))
	}

	return Concat(CodeMonoid, parts)
}

func GenerateGeoRepositoryForMessage(gm *GeoMessage) Code {
	lower := strings.ToLower(gm.Name)

	return Concat(CodeMonoid, []Code{
		Linef("// %sGeoWrapper wraps %s to implement GeoLocatable", gm.Name, gm.Name),
		Linef("type %sGeoWrapper struct {", gm.Name),
		Linef("	*%s", gm.Name),
		Line("}"),
		Blank(),
		Linef("func (w *%sGeoWrapper) GetCoordinates() Coordinates {", gm.Name),
		Line("	return Coordinates{"),
		Linef("		Latitude:  w.%s.Get%s(),", gm.Name, gm.LatField),
		Linef("		Longitude: w.%s.Get%s(),", gm.Name, gm.LngField),
		Line("	}"),
		Line("}"),
		Blank(),
		Linef("func (w *%sGeoWrapper) GetID() string {", gm.Name),
		Linef("	return w.%s.GetId()", gm.Name),
		Line("}"),
		Blank(),
		Linef("// %sGeoRepository adds geo queries to %sRepository", gm.Name, gm.Name),
		Linef("type %sGeoRepository struct {", gm.Name),
		Linef("	repo  %sRepository", gm.Name),
		Linef("	index *SpatialIndex[*%sGeoWrapper]", gm.Name),
		Line("}"),
		Blank(),
		Linef("// NewGeo%sRepository creates a geo-enabled repository", gm.Name),
		Linef("func NewGeo%sRepository(repo %sRepository) *%sGeoRepository {", gm.Name, gm.Name, gm.Name),
		Linef("	return &%sGeoRepository{", gm.Name),
		Line("		repo:  repo,"),
		Linef("		index: NewSpatialIndex[*%sGeoWrapper](GeoHashPrecision),", gm.Name),
		Line("	}"),
		Line("}"),
		Blank(),
		Linef("// Create creates and indexes a %s", lower),
		Linef("func (r *%sGeoRepository) Create(ctx context.Context, item *%s) (string, error) {", gm.Name, gm.Name),
		Line("	id, err := r.repo.Create(ctx, item)"),
		Line("	if err != nil {"),
		Line("		return \"\", err"),
		Line("	}"),
		Line("	item.Id = id"),
		Linef("	r.index.Insert(&%sGeoWrapper{item})", gm.Name),
		Line("	return id, nil"),
		Line("}"),
		Blank(),
		Linef("// Update updates and re-indexes a %s", lower),
		Linef("func (r *%sGeoRepository) Update(ctx context.Context, item *%s) error {", gm.Name, gm.Name),
		Line("	if err := r.repo.Update(ctx, item); err != nil {"),
		Line("		return err"),
		Line("	}"),
		Line("	r.index.Remove(item.GetId())"),
		Linef("	r.index.Insert(&%sGeoWrapper{item})", gm.Name),
		Line("	return nil"),
		Line("}"),
		Blank(),
		Linef("// Delete removes a %s from repo and index", lower),
		Linef("func (r *%sGeoRepository) Delete(ctx context.Context, id string) error {", gm.Name),
		Line("	if err := r.repo.Delete(ctx, id); err != nil {"),
		Line("		return err"),
		Line("	}"),
		Line("	r.index.Remove(id)"),
		Line("	return nil"),
		Line("}"),
		Blank(),
		Linef("// Get retrieves a %s by ID", lower),
		Linef("func (r *%sGeoRepository) Get(ctx context.Context, id string) (*%s, error) {", gm.Name, gm.Name),
		Line("	return r.repo.Get(ctx, id)"),
		Line("}"),
		Blank(),
		Linef("// List retrieves all %ss", lower),
		Linef("func (r *%sGeoRepository) List(ctx context.Context) ([]*%s, error) {", gm.Name, gm.Name),
		Line("	return r.repo.List(ctx)"),
		Line("}"),
		Blank(),
		Linef("// FindNearest finds %ss near a point", lower),
		Linef("func (r *%sGeoRepository) FindNearest(ctx context.Context, lat, lng, radiusKm float64, limit int) ([]*%sWithDistance, error) {", gm.Name, gm.Name),
		Line("	results := r.index.FindNearest(FindNearestOptions{"),
		Line("		Center:   Coordinates{Latitude: lat, Longitude: lng},"),
		Line("		RadiusKm: radiusKm,"),
		Line("		Limit:    limit,"),
		Line("	})"),
		Blank(),
		Linef("	out := make([]*%sWithDistance, len(results))", gm.Name),
		Line("	for i, r := range results {"),
		Linef("		out[i] = &%sWithDistance{", gm.Name),
		Linef("			%s:         r.Item.%s,", gm.Name, gm.Name),
		Line("			DistanceKm: r.DistanceKm,"),
		Line("		}"),
		Line("	}"),
		Line("	return out, nil"),
		Line("}"),
		Blank(),
		Linef("// FindWithinBox finds %ss within a bounding box", lower),
		Linef("func (r *%sGeoRepository) FindWithinBox(ctx context.Context, minLat, maxLat, minLng, maxLng float64) ([]*%s, error) {", gm.Name, gm.Name),
		Line("	wrappers := r.index.FindWithinBox(BoundingBox{"),
		Line("		MinLat: minLat,"),
		Line("		MaxLat: maxLat,"),
		Line("		MinLng: minLng,"),
		Line("		MaxLng: maxLng,"),
		Line("	})"),
		Blank(),
		Linef("	out := make([]*%s, len(wrappers))", gm.Name),
		Line("	for i, w := range wrappers {"),
		Linef("		out[i] = w.%s", gm.Name),
		Line("	}"),
		Line("	return out, nil"),
		Line("}"),
		Blank(),
		Linef("// RebuildIndex rebuilds the spatial index from the repository"),
		Linef("func (r *%sGeoRepository) RebuildIndex(ctx context.Context) error {", gm.Name),
		Line("	items, err := r.repo.List(ctx)"),
		Line("	if err != nil {"),
		Line("		return err"),
		Line("	}"),
		Blank(),
		Linef("	r.index = NewSpatialIndex[*%sGeoWrapper](GeoHashPrecision)", gm.Name),
		Line("	for _, item := range items {"),
		Linef("		r.index.Insert(&%sGeoWrapper{item})", gm.Name),
		Line("	}"),
		Line("	return nil"),
		Line("}"),
		Blank(),
		Linef("// %sWithDistance pairs a %s with its distance from a reference point", gm.Name, gm.Name),
		Linef("type %sWithDistance struct {", gm.Name),
		Linef("	*%s", gm.Name),
		Line("	DistanceKm float64"),
		Line("}"),
		Blank(),
	})
}

func GenerateGeoService(geoMessages []*GeoMessage) Code {
	parts := []Code{
		Line("// ============================================================================="),
		Line("// GEO SERVICE"),
		Line("// ============================================================================="),
		Blank(),
	}

	for _, gm := range geoMessages {
		if !IsGeoMessage(gm) {
			continue
		}
		parts = append(parts, GenerateGeoServiceForMessage(gm))
	}

	return Concat(CodeMonoid, parts)
}

func GenerateGeoServiceForMessage(gm *GeoMessage) Code {
	return Concat(CodeMonoid, []Code{
		Linef("// %sLocatorService provides store-locator functionality for %s", gm.Name, gm.Name),
		Linef("type %sLocatorService struct {", gm.Name),
		Linef("	repo *%sGeoRepository", gm.Name),
		Line("}"),
		Blank(),
		Linef("// New%sLocatorService creates a new locator service", gm.Name),
		Linef("func New%sLocatorService(repo *%sGeoRepository) *%sLocatorService {", gm.Name, gm.Name, gm.Name),
		Linef("	return &%sLocatorService{repo: repo}", gm.Name),
		Line("}"),
		Blank(),
		Linef("// FindNearest finds the nearest %ss to a location", gm.Name),
		Linef("func (s *%sLocatorService) FindNearest(ctx context.Context, lat, lng float64, radiusKm float64, limit int) ([]*%sWithDistance, error) {", gm.Name, gm.Name),
		Line("	if radiusKm <= 0 {"),
		Line("		radiusKm = DefaultRadiusKm"),
		Line("	}"),
		Line("	if limit <= 0 {"),
		Line("		limit = DefaultLimit"),
		Line("	}"),
		Line("	return s.repo.FindNearest(ctx, lat, lng, radiusKm, limit)"),
		Line("}"),
		Blank(),
		Linef("// FindWithinBounds finds %ss within a map viewport", gm.Name),
		Linef("func (s *%sLocatorService) FindWithinBounds(ctx context.Context, minLat, maxLat, minLng, maxLng float64) ([]*%s, error) {", gm.Name, gm.Name),
		Line("	return s.repo.FindWithinBox(ctx, minLat, maxLat, minLng, maxLng)"),
		Line("}"),
		Blank(),
	})
}

// =============================================================================
// REACT FRONTEND GENERATOR
// =============================================================================

func GenerateGeoFrontend(geoMessages []*GeoMessage) Code {
	return Concat(CodeMonoid, []Code{
		GenerateGeoTypes(),
		GenerateUseGeolocation(),
		GenerateGoogleMapsLoader(),
		GenerateMapComponent(geoMessages),
		GenerateStoreList(geoMessages),
		GenerateStoreLocator(geoMessages),
	})
}

func GenerateFrontendTypes() Code {
	return Code{Run: func() string {
		return `// geo_types.ts
// Generated by protoc-gen-geo

export interface Coordinates {
  latitude: number;
  longitude: number;
}

export interface BoundingBox {
  minLat: number;
  maxLat: number;
  minLng: number;
  maxLng: number;
}

export interface StoreWithDistance<T> {
  store: T;
  distanceKm: number;
}

export interface MapViewport {
  center: Coordinates;
  zoom: number;
  bounds?: BoundingBox;
}

`
	}}
}

func GenerateUseGeolocation() Code {
	return Code{Run: func() string {
		return `// useGeolocation.ts
// Generated by protoc-gen-geo

import { useState, useEffect, useCallback } from 'react';
import type { Coordinates } from './geo_types';

interface GeolocationState {
  coordinates: Coordinates | null;
  error: string | null;
  isLoading: boolean;
}

interface UseGeolocationOptions {
  enableHighAccuracy?: boolean;
  timeout?: number;
  maximumAge?: number;
}

export function useGeolocation(options: UseGeolocationOptions = {}) {
  const [state, setState] = useState<GeolocationState>({
    coordinates: null,
    error: null,
    isLoading: true,
  });

  const { enableHighAccuracy = true, timeout = 10000, maximumAge = 0 } = options;

  const getCurrentPosition = useCallback(() => {
    setState(s => ({ ...s, isLoading: true, error: null }));

    if (!navigator.geolocation) {
      setState({
        coordinates: null,
        error: 'Geolocation is not supported by your browser',
        isLoading: false,
      });
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        setState({
          coordinates: {
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
          },
          error: null,
          isLoading: false,
        });
      },
      (error) => {
        let message = 'Failed to get location';
        switch (error.code) {
          case error.PERMISSION_DENIED:
            message = 'Location permission denied';
            break;
          case error.POSITION_UNAVAILABLE:
            message = 'Location information unavailable';
            break;
          case error.TIMEOUT:
            message = 'Location request timed out';
            break;
        }
        setState({
          coordinates: null,
          error: message,
          isLoading: false,
        });
      },
      { enableHighAccuracy, timeout, maximumAge }
    );
  }, [enableHighAccuracy, timeout, maximumAge]);

  useEffect(() => {
    getCurrentPosition();
  }, [getCurrentPosition]);

  return { ...state, refresh: getCurrentPosition };
}

// Calculate distance between two points (Haversine formula)
export function calculateDistance(
  lat1: number,
  lng1: number,
  lat2: number,
  lng2: number
): number {
  const R = 6371; // Earth's radius in km
  const dLat = toRad(lat2 - lat1);
  const dLng = toRad(lng2 - lng1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLng / 2) * Math.sin(dLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function toRad(deg: number): number {
  return deg * (Math.PI / 180);
}

// Format distance for display
export function formatDistance(km: number): string {
  if (km < 1) {
    return ` + "`${Math.round(km * 1000)} m`" + `;
  }
  return ` + "`${km.toFixed(1)} km`" + `;
}

`
	}}
}

func GenerateGoogleMapsLoader() Code {
	return Code{Run: func() string {
		return `// GoogleMapsLoader.tsx
// Generated by protoc-gen-geo

import React, { createContext, useContext, useEffect, useState } from 'react';

interface GoogleMapsContextType {
  isLoaded: boolean;
  loadError: Error | null;
  google: typeof google | null;
}

const GoogleMapsContext = createContext<GoogleMapsContextType>({
  isLoaded: false,
  loadError: null,
  google: null,
});

interface GoogleMapsProviderProps {
  apiKey: string;
  children: React.ReactNode;
  libraries?: string[];
}

export function GoogleMapsProvider({ 
  apiKey, 
  children,
  libraries = ['places', 'geometry'],
}: GoogleMapsProviderProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [loadError, setLoadError] = useState<Error | null>(null);

  useEffect(() => {
    // Check if already loaded
    if (window.google?.maps) {
      setIsLoaded(true);
      return;
    }

    // Check if script is already being loaded
    const existingScript = document.querySelector('script[src*="maps.googleapis.com"]');
    if (existingScript) {
      existingScript.addEventListener('load', () => setIsLoaded(true));
      return;
    }

    // Load the script
    const script = document.createElement('script');
    script.src = ` + "`https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=${libraries.join(',')}`" + `;
    script.async = true;
    script.defer = true;

    script.onload = () => setIsLoaded(true);
    script.onerror = () => setLoadError(new Error('Failed to load Google Maps'));

    document.head.appendChild(script);

    return () => {
      // Cleanup if needed
    };
  }, [apiKey, libraries]);

  return (
    <GoogleMapsContext.Provider value={{ isLoaded, loadError, google: isLoaded ? window.google : null }}>
      {children}
    </GoogleMapsContext.Provider>
  );
}

export function useGoogleMaps() {
  return useContext(GoogleMapsContext);
}

// Type declaration for window.google
declare global {
  interface Window {
    google: typeof google;
  }
}

`
	}}
}

func GenerateMapComponent(geoMessages []*GeoMessage) Code {
	return Code{Run: func() string {
		return `// MapView.tsx
// Generated by protoc-gen-geo

import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useGoogleMaps } from './GoogleMapsLoader';
import type { Coordinates, BoundingBox } from './geo_types';

interface Marker {
  id: string;
  position: Coordinates;
  title?: string;
  icon?: string;
}

interface MapViewProps {
  center?: Coordinates;
  zoom?: number;
  markers?: Marker[];
  onMarkerClick?: (id: string) => void;
  onBoundsChange?: (bounds: BoundingBox) => void;
  onCenterChange?: (center: Coordinates) => void;
  selectedMarkerId?: string;
  height?: string;
  className?: string;
  showUserLocation?: boolean;
  userLocation?: Coordinates | null;
}

export function MapView({
  center = { latitude: 37.7749, longitude: -122.4194 }, // Default: San Francisco
  zoom = 12,
  markers = [],
  onMarkerClick,
  onBoundsChange,
  onCenterChange,
  selectedMarkerId,
  height = '400px',
  className = '',
  showUserLocation = true,
  userLocation,
}: MapViewProps) {
  const { isLoaded, google } = useGoogleMaps();
  const mapRef = useRef<HTMLDivElement>(null);
  const mapInstanceRef = useRef<google.maps.Map | null>(null);
  const markersRef = useRef<Map<string, google.maps.Marker>>(new Map());
  const userMarkerRef = useRef<google.maps.Marker | null>(null);

  // Initialize map
  useEffect(() => {
    if (!isLoaded || !google || !mapRef.current || mapInstanceRef.current) return;

    mapInstanceRef.current = new google.maps.Map(mapRef.current, {
      center: { lat: center.latitude, lng: center.longitude },
      zoom,
      styles: defaultMapStyles,
      mapTypeControl: false,
      fullscreenControl: false,
      streetViewControl: false,
    });

    // Listen for bounds change
    mapInstanceRef.current.addListener('idle', () => {
      const bounds = mapInstanceRef.current?.getBounds();
      if (bounds && onBoundsChange) {
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        onBoundsChange({
          minLat: sw.lat(),
          maxLat: ne.lat(),
          minLng: sw.lng(),
          maxLng: ne.lng(),
        });
      }
    });

    mapInstanceRef.current.addListener('center_changed', () => {
      const mapCenter = mapInstanceRef.current?.getCenter();
      if (mapCenter && onCenterChange) {
        onCenterChange({
          latitude: mapCenter.lat(),
          longitude: mapCenter.lng(),
        });
      }
    });
  }, [isLoaded, google]);

  // Update center
  useEffect(() => {
    if (!mapInstanceRef.current) return;
    mapInstanceRef.current.setCenter({ lat: center.latitude, lng: center.longitude });
  }, [center.latitude, center.longitude]);

  // Update markers
  useEffect(() => {
    if (!isLoaded || !google || !mapInstanceRef.current) return;

    // Remove old markers
    markersRef.current.forEach((marker, id) => {
      if (!markers.find(m => m.id === id)) {
        marker.setMap(null);
        markersRef.current.delete(id);
      }
    });

    // Add/update markers
    markers.forEach((m) => {
      let marker = markersRef.current.get(m.id);
      
      if (!marker) {
        marker = new google.maps.Marker({
          map: mapInstanceRef.current,
          position: { lat: m.position.latitude, lng: m.position.longitude },
          title: m.title,
          icon: m.icon || defaultMarkerIcon,
          animation: google.maps.Animation.DROP,
        });

        marker.addListener('click', () => {
          onMarkerClick?.(m.id);
        });

        markersRef.current.set(m.id, marker);
      } else {
        marker.setPosition({ lat: m.position.latitude, lng: m.position.longitude });
      }

      // Highlight selected marker
      if (m.id === selectedMarkerId) {
        marker.setAnimation(google.maps.Animation.BOUNCE);
        setTimeout(() => marker?.setAnimation(null), 1500);
      }
    });
  }, [isLoaded, google, markers, selectedMarkerId, onMarkerClick]);

  // User location marker
  useEffect(() => {
    if (!isLoaded || !google || !mapInstanceRef.current || !showUserLocation || !userLocation) return;

    if (!userMarkerRef.current) {
      userMarkerRef.current = new google.maps.Marker({
        map: mapInstanceRef.current,
        position: { lat: userLocation.latitude, lng: userLocation.longitude },
        title: 'Your Location',
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 10,
          fillColor: '#4285F4',
          fillOpacity: 1,
          strokeColor: '#ffffff',
          strokeWeight: 2,
        },
        zIndex: 999,
      });
    } else {
      userMarkerRef.current.setPosition({ lat: userLocation.latitude, lng: userLocation.longitude });
    }
  }, [isLoaded, google, showUserLocation, userLocation]);

  if (!isLoaded) {
    return (
      <div 
        className={` + "`flex items-center justify-center bg-gray-100 ${className}`" + `}
        style={{ height }}
      >
        <div className="text-gray-500">Loading map...</div>
      </div>
    );
  }

  return (
    <div 
      ref={mapRef} 
      className={className}
      style={{ height, width: '100%' }}
    />
  );
}

const defaultMarkerIcon = {
  url: 'data:image/svg+xml,' + encodeURIComponent(` + "`" + `
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="40" viewBox="0 0 32 40">
      <path fill="#EA4335" d="M16 0C7.16 0 0 7.16 0 16c0 12 16 24 16 24s16-12 16-24C32 7.16 24.84 0 16 0zm0 22c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"/>
    </svg>
  ` + "`" + `),
  scaledSize: { width: 32, height: 40 } as google.maps.Size,
  anchor: { x: 16, y: 40 } as google.maps.Point,
};

const defaultMapStyles: google.maps.MapTypeStyle[] = [
  {
    featureType: 'poi',
    elementType: 'labels',
    stylers: [{ visibility: 'off' }],
  },
];

`
	}}
}

func GenerateStoreList(geoMessages []*GeoMessage) Code {
	return Code{Run: func() string {
		return `// StoreList.tsx
// Generated by protoc-gen-geo

import React from 'react';
import { formatDistance } from './useGeolocation';

interface Store {
  id: string;
  name: string;
  address?: string;
  phone?: string;
  latitude: number;
  longitude: number;
}

interface StoreListProps<T extends Store> {
  stores: Array<{ store: T; distanceKm: number }>;
  selectedId?: string;
  onSelect?: (store: T) => void;
  onGetDirections?: (store: T) => void;
  isLoading?: boolean;
  emptyMessage?: string;
}

export function StoreList<T extends Store>({
  stores,
  selectedId,
  onSelect,
  onGetDirections,
  isLoading = false,
  emptyMessage = 'No locations found nearby',
}: StoreListProps<T>) {
  if (isLoading) {
    return (
      <div className="p-4 space-y-4">
        {[1, 2, 3].map((i) => (
          <div key={i} className="animate-pulse">
            <div className="h-4 bg-gray-200 rounded w-3/4 mb-2" />
            <div className="h-3 bg-gray-200 rounded w-1/2" />
          </div>
        ))}
      </div>
    );
  }

  if (stores.length === 0) {
    return (
      <div className="p-8 text-center text-gray-500">
        <MapPinIcon className="w-12 h-12 mx-auto mb-4 text-gray-300" />
        <p>{emptyMessage}</p>
      </div>
    );
  }

  return (
    <div className="divide-y divide-gray-200">
      {stores.map(({ store, distanceKm }) => (
        <StoreCard
          key={store.id}
          store={store}
          distance={distanceKm}
          isSelected={store.id === selectedId}
          onSelect={() => onSelect?.(store)}
          onGetDirections={() => onGetDirections?.(store)}
        />
      ))}
    </div>
  );
}

interface StoreCardProps<T extends Store> {
  store: T;
  distance: number;
  isSelected?: boolean;
  onSelect?: () => void;
  onGetDirections?: () => void;
}

export function StoreCard<T extends Store>({
  store,
  distance,
  isSelected = false,
  onSelect,
  onGetDirections,
}: StoreCardProps<T>) {
  return (
    <div
      className={` + "`p-4 cursor-pointer transition hover:bg-gray-50 ${isSelected ? 'bg-blue-50 border-l-4 border-blue-500' : ''}`" + `}
      onClick={onSelect}
    >
      <div className="flex justify-between items-start">
        <div className="flex-1">
          <h3 className="font-medium text-gray-900">{store.name}</h3>
          {store.address && (
            <p className="text-sm text-gray-600 mt-1">{store.address}</p>
          )}
          {store.phone && (
            <p className="text-sm text-gray-500 mt-1">
              <a href={` + "`tel:${store.phone}`" + `} className="hover:text-blue-600" onClick={e => e.stopPropagation()}>
                {store.phone}
              </a>
            </p>
          )}
        </div>
        <div className="text-right ml-4">
          <span className="text-sm font-medium text-gray-700">
            {formatDistance(distance)}
          </span>
        </div>
      </div>
      
      <div className="mt-3 flex gap-2">
        <button
          onClick={(e) => {
            e.stopPropagation();
            onGetDirections?.();
          }}
          className="text-sm text-blue-600 hover:text-blue-800 flex items-center gap-1"
        >
          <DirectionsIcon className="w-4 h-4" />
          Directions
        </button>
      </div>
    </div>
  );
}

function MapPinIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
  );
}

function DirectionsIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
    </svg>
  );
}

`
	}}
}

func GenerateStoreLocator(geoMessages []*GeoMessage) Code {
	return Code{Run: func() string {
		return `// StoreLocator.tsx
// Generated by protoc-gen-geo

import React, { useState, useEffect, useCallback } from 'react';
import { MapView } from './MapView';
import { StoreList } from './StoreList';
import { useGeolocation } from './useGeolocation';
import type { Coordinates, BoundingBox } from './geo_types';

interface Store {
  id: string;
  name: string;
  address?: string;
  phone?: string;
  latitude: number;
  longitude: number;
}

interface StoreWithDistance<T extends Store> {
  store: T;
  distanceKm: number;
}

interface StoreLocatorProps<T extends Store> {
  findNearest: (lat: number, lng: number, radiusKm: number, limit: number) => Promise<StoreWithDistance<T>[]>;
  defaultCenter?: Coordinates;
  defaultRadius?: number;
  title?: string;
  className?: string;
}

export function StoreLocator<T extends Store>({
  findNearest,
  defaultCenter = { latitude: 37.7749, longitude: -122.4194 },
  defaultRadius = 50,
  title = 'Find a Location',
  className = '',
}: StoreLocatorProps<T>) {
  const { coordinates: userLocation, isLoading: locationLoading, error: locationError } = useGeolocation();
  const [stores, setStores] = useState<StoreWithDistance<T>[]>([]);
  const [selectedStore, setSelectedStore] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [searchRadius, setSearchRadius] = useState(defaultRadius);
  const [mapCenter, setMapCenter] = useState<Coordinates>(defaultCenter);

  // Update center when user location is available
  useEffect(() => {
    if (userLocation) {
      setMapCenter(userLocation);
    }
  }, [userLocation]);

  // Fetch stores when center changes
  const loadStores = useCallback(async (center: Coordinates) => {
    setIsLoading(true);
    try {
      const results = await findNearest(center.latitude, center.longitude, searchRadius, 20);
      setStores(results);
    } catch (error) {
      console.error('Failed to fetch stores:', error);
      setStores([]);
    } finally {
      setIsLoading(false);
    }
  }, [findNearest, searchRadius]);

  useEffect(() => {
    loadStores(mapCenter);
  }, [mapCenter, loadStores]);

  // Convert stores to map markers
  const markers = stores.map(({ store }) => ({
    id: store.id,
    position: { latitude: store.latitude, longitude: store.longitude },
    title: store.name,
  }));

  // Handle getting directions
  const handleGetDirections = (store: T) => {
    const origin = userLocation 
      ? ` + "`${userLocation.latitude},${userLocation.longitude}`" + `
      : '';
    const destination = ` + "`${store.latitude},${store.longitude}`" + `;
    const url = ` + "`https://www.google.com/maps/dir/${origin}/${destination}`" + `;
    window.open(url, '_blank');
  };

  return (
    <div className={` + "`flex flex-col lg:flex-row h-[600px] ${className}`" + `}>
      {/* Sidebar */}
      <div className="w-full lg:w-96 flex flex-col bg-white border-r">
        <div className="p-4 border-b">
          <h2 className="text-xl font-semibold">{title}</h2>
          
          {/* Search radius selector */}
          <div className="mt-3">
            <label className="text-sm text-gray-600">Search radius</label>
            <select
              value={searchRadius}
              onChange={(e) => setSearchRadius(Number(e.target.value))}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md text-sm"
            >
              <option value={10}>10 km</option>
              <option value={25}>25 km</option>
              <option value={50}>50 km</option>
              <option value={100}>100 km</option>
            </select>
          </div>

          {/* Location status */}
          {locationLoading && (
            <p className="mt-2 text-sm text-gray-500">Getting your location...</p>
          )}
          {locationError && (
            <p className="mt-2 text-sm text-red-500">{locationError}</p>
          )}
          {userLocation && (
            <button
              onClick={() => setMapCenter(userLocation)}
              className="mt-2 text-sm text-blue-600 hover:text-blue-800"
            >
              Center on my location
            </button>
          )}
        </div>

        {/* Store list */}
        <div className="flex-1 overflow-y-auto">
          <StoreList
            stores={stores}
            selectedId={selectedStore?.id}
            onSelect={(store) => {
              setSelectedStore(store);
              setMapCenter({ latitude: store.latitude, longitude: store.longitude });
            }}
            onGetDirections={handleGetDirections}
            isLoading={isLoading}
            emptyMessage="No locations found in this area"
          />
        </div>

        {/* Results count */}
        {!isLoading && stores.length > 0 && (
          <div className="p-3 border-t text-sm text-gray-500">
            {stores.length} location{stores.length !== 1 ? 's' : ''} found
          </div>
        )}
      </div>

      {/* Map */}
      <div className="flex-1 h-64 lg:h-full">
        <MapView
          center={mapCenter}
          zoom={12}
          markers={markers}
          selectedMarkerId={selectedStore?.id}
          onMarkerClick={(id) => {
            const found = stores.find(s => s.store.id === id);
            if (found) setSelectedStore(found.store);
          }}
          onCenterChange={setMapCenter}
          userLocation={userLocation}
          showUserLocation={!!userLocation}
          height="100%"
        />
      </div>
    </div>
  );
}

// =============================================================================
// CONNECT CLIENT HOOK
// =============================================================================

// Creates a findNearest function from a Connect client
// Usage:
//   import { createConnectTransport } from '@connectrpc/connect-web';
//   import { createClient } from '@connectrpc/connect';
//   import { StoreLocatorService } from './gen/store/v1/store_connect';
//
//   const transport = createConnectTransport({ baseUrl: '/api' });
//   const client = createClient(StoreLocatorService, transport);
//   const { findNearest } = useStoreLocatorClient(client);
//
//   <StoreLocator findNearest={findNearest} />

export function useStoreLocatorClient<
  TStore extends Store,
  TClient extends {
    findNearest: (req: { latitude: number; longitude: number; radiusKm: number; limit: number }) 
      => Promise<{ stores: Array<{ store: TStore; distanceKm: number }> }>;
  }
>(client: TClient) {
  const findNearest = useCallback(
    async (lat: number, lng: number, radiusKm: number, limit: number) => {
      const response = await client.findNearest({
        latitude: lat,
        longitude: lng,
        radiusKm,
        limit,
      });
      return response.stores.map(s => ({
        store: s.store,
        distanceKm: s.distanceKm,
      }));
    },
    [client]
  );

  return { findNearest };
}

// =============================================================================
// REACT QUERY HOOK (Optional)
// =============================================================================

// For use with @tanstack/react-query
// Usage:
//   const { data, isLoading } = useNearestStores(client, center, radius);

export function useNearestStoresQuery<
  TStore extends Store,
  TClient extends {
    findNearest: (req: { latitude: number; longitude: number; radiusKm: number; limit: number }) 
      => Promise<{ stores: Array<{ store: TStore; distanceKm: number }> }>;
  }
>(
  client: TClient,
  center: Coordinates | null,
  radiusKm: number = 50,
  limit: number = 20
) {
  const [stores, setStores] = useState<StoreWithDistance<TStore>[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    if (!center) return;

    setIsLoading(true);
    setError(null);

    client
      .findNearest({ latitude: center.latitude, longitude: center.longitude, radiusKm, limit })
      .then((response) => {
        setStores(response.stores.map(s => ({ store: s.store, distanceKm: s.distanceKm })));
      })
      .catch((err) => {
        setError(err);
        setStores([]);
      })
      .finally(() => {
        setIsLoading(false);
      });
  }, [client, center?.latitude, center?.longitude, radiusKm, limit]);

  return { stores, isLoading, error };
}

`
	}}
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			// Analyze messages for geo fields
			var geoMessages []*GeoMessage
			for _, msg := range f.Messages {
				gm := AnalyzeMessage(msg)
				if IsGeoMessage(gm) {
					geoMessages = append(geoMessages, gm)
				}
			}

			// Skip if no geo messages
			if len(geoMessages) == 0 {
				continue
			}

			pkgName := string(f.GoPackageName)

			// Generate Go backend
			backendFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_geo.pb.go", f.GoImportPath)
			backendFile.P(GenerateGeoBackend(pkgName, geoMessages).Run())

			// Generate React frontend files
			basePath := strings.Replace(f.GeneratedFilenamePrefix, "/go/", "/ui/geo/", 1)

			typesFile := gen.NewGeneratedFile(basePath+"_types.ts", "")
			typesFile.P(GenerateFrontendTypes().Run())

			geolocationFile := gen.NewGeneratedFile(basePath+"_useGeolocation.ts", "")
			geolocationFile.P(GenerateUseGeolocation().Run())

			mapsLoaderFile := gen.NewGeneratedFile(basePath+"_GoogleMapsLoader.tsx", "")
			mapsLoaderFile.P(GenerateGoogleMapsLoader().Run())

			mapViewFile := gen.NewGeneratedFile(basePath+"_MapView.tsx", "")
			mapViewFile.P(GenerateMapComponent(geoMessages).Run())

			storeListFile := gen.NewGeneratedFile(basePath+"_StoreList.tsx", "")
			storeListFile.P(GenerateStoreList(geoMessages).Run())

			storeLocatorFile := gen.NewGeneratedFile(basePath+"_StoreLocator.tsx", "")
			storeLocatorFile.P(GenerateStoreLocator(geoMessages).Run())
		}
		return nil
	})
}
