// protoc-gen-wire generates Google Wire provider sets
// Uses Category Theory: Monoid + Functor + Fold
// Generates: RepositorySet, ServiceSet, RealtimeSet, FullSet
package main

import (
	"fmt"
	"strings"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
	pluginpb "google.golang.org/protobuf/types/pluginpb"
)

// =============================================================================
// CATEGORY THEORY FOUNDATIONS
// =============================================================================

type Monoid[A any] struct {
	Empty  func() A
	Append func(A, A) A
}

type Code struct{ Run func() string }

var CodeMonoid = Monoid[Code]{
	Empty:  func() Code { return Code{Run: func() string { return "" }} },
	Append: func(a, b Code) Code { return Code{Run: func() string { return a.Run() + b.Run() }} },
}

func FoldRight[A, B any](xs []A, z B, f func(A, B) B) B {
	if len(xs) == 0 {
		return z
	}
	return f(xs[0], FoldRight(xs[1:], z, f))
}

func Concat[A any](m Monoid[A], xs []A) A {
	return FoldRight(xs, m.Empty(), func(a A, acc A) A { return m.Append(a, acc) })
}

func Map[A, B any](xs []A, f func(A) B) []B {
	return FoldRight(xs, []B{}, func(a A, acc []B) []B { return append([]B{f(a)}, acc...) })
}

func FoldMap[A, B any](xs []A, m Monoid[B], f func(A) B) B { return Concat(m, Map(xs, f)) }

func Filter[A any](xs []A, pred func(A) bool) []A {
	return FoldRight(xs, []A{}, func(a A, acc []A) []A {
		if pred(a) {
			return append([]A{a}, acc...)
		}
		return acc
	})
}

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }

// =============================================================================
// MESSAGE INFO
// =============================================================================

type MessageInfo struct {
	Name, GoName string
	HasID        bool
}

func ExtractMessageInfo(msg *protogen.Message) MessageInfo {
	hasID := false
	for _, field := range msg.Fields {
		if strings.EqualFold(string(field.Desc.Name()), "id") {
			hasID = true
			break
		}
	}
	return MessageInfo{
		Name:   string(msg.Desc.Name()),
		GoName: msg.GoIdent.GoName,
		HasID:  hasID,
	}
}

// =============================================================================
// WIRE GENERATOR
// =============================================================================

func GenerateWire(messages []MessageInfo, pkgName string) Code {
	// Filter to only entities (messages with ID field)
	entities := Filter(messages, func(m MessageInfo) bool { return m.HasID })

	return Concat(CodeMonoid, []Code{
		generateHeader(pkgName),
		generateFirestoreRepositorySet(entities),
		generateInMemoryRepositorySet(entities),
		generateRealtimeRepositorySet(entities),
		generateServiceSet(entities),
		generateFullSets(entities),
		generateServerStruct(entities),
		generateServerConstructor(entities),
		generateWireInjectorsExample(entities, pkgName),
	})
}

func generateHeader(pkgName string) Code {
	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-wire. DO NOT EDIT."),
		Line("// Generated using Category Theory: Monoid + Functor + Fold"),
		Blank(),
		Linef("package %s", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"net/http"`),
		Blank(),
		Line(`	"cloud.google.com/go/firestore"`),
		Line(`	"github.com/google/wire"`),
		Line(")"),
		Blank(),
	})
}

func generateFirestoreRepositorySet(entities []MessageInfo) Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// FIRESTORE REPOSITORY PROVIDERS"),
		Line("// ============================================================================="),
		Blank(),
		Line("// FirestoreRepositorySet provides all Firestore repository implementations."),
		Line("// Use this set for production with a real Firestore database."),
		Line("var FirestoreRepositorySet = wire.NewSet("),
		FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
			return Linef("	New%sFirestoreRepository,", m.GoName)
		}),
		Line(")"),
		Blank(),
		Line("// Firestore repository constructors that Wire will use"),
		FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
			return Concat(CodeMonoid, []Code{
				Linef("func New%sFirestoreRepository(client *firestore.Client) %sRepository {", m.GoName, m.GoName),
				Linef("	return New%sRepository(client)", m.GoName),
				Line("}"),
				Blank(),
			})
		}),
	})
}

func generateInMemoryRepositorySet(entities []MessageInfo) Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// IN-MEMORY REPOSITORY PROVIDERS"),
		Line("// ============================================================================="),
		Blank(),
		Line("// InMemoryRepositorySet provides all in-memory repository implementations."),
		Line("// Use this set for testing and development without a database."),
		Line("var InMemoryRepositorySet = wire.NewSet("),
		FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
			return Linef("	New%sInMemoryRepository,", m.GoName)
		}),
		Line(")"),
		Blank(),
		Line("// In-memory repository constructors that Wire will use"),
		FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
			return Concat(CodeMonoid, []Code{
				Linef("func New%sInMemoryRepository() %sRepository {", m.GoName, m.GoName),
				Linef("	return New%sRepository()", m.GoName),
				Line("}"),
				Blank(),
			})
		}),
	})
}

func generateRealtimeRepositorySet(entities []MessageInfo) Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// REALTIME REPOSITORY WRAPPERS"),
		Line("// ============================================================================="),
		Blank(),
		Line("// RealtimeRepositorySet wraps repositories with event publishing."),
		Line("// Use this to add real-time updates via WebSocket."),
		Line("var RealtimeRepositorySet = wire.NewSet("),
		FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
			return Linef("	Wrap%sWithRealtime,", m.GoName)
		}),
		Line(")"),
		Blank(),
		Line("// Realtime wrapper constructors"),
		FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
			return Concat(CodeMonoid, []Code{
				Linef("func Wrap%sWithRealtime(repo %sRepository) %sRepository {", m.GoName, m.GoName, m.GoName),
				Linef("	return New%sRepositoryWithEvents(repo)", m.GoName),
				Line("}"),
				Blank(),
			})
		}),
	})
}

func generateServiceSet(entities []MessageInfo) Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// SERVICE PROVIDERS"),
		Line("// ============================================================================="),
		Blank(),
		Line("// ServiceSet provides all service implementations."),
		Line("// Services depend on repositories (either Firestore or InMemory)."),
		Line("var ServiceSet = wire.NewSet("),
		FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
			return Linef("	New%sServiceServer,", m.GoName)
		}),
		Line(")"),
		Blank(),
	})
}

func generateFullSets(entities []MessageInfo) Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// FULL APPLICATION SETS"),
		Line("// ============================================================================="),
		Blank(),
		Line("// ProductionSet wires everything for production (Firestore + Services)."),
		Line("var ProductionSet = wire.NewSet("),
		Line("	FirestoreRepositorySet,"),
		Line("	ServiceSet,"),
		Line("	NewServer,"),
		Line(")"),
		Blank(),
		Line("// ProductionRealtimeSet adds real-time updates to production."),
		Line("var ProductionRealtimeSet = wire.NewSet("),
		Line("	FirestoreRepositorySet,"),
		Line("	RealtimeRepositorySet,"),
		Line("	ServiceSet,"),
		Line("	NewServer,"),
		Line(")"),
		Blank(),
		Line("// DevelopmentSet wires everything for development (InMemory + Services)."),
		Line("var DevelopmentSet = wire.NewSet("),
		Line("	InMemoryRepositorySet,"),
		Line("	ServiceSet,"),
		Line("	NewServer,"),
		Line(")"),
		Blank(),
		Line("// TestSet is an alias for DevelopmentSet, useful for testing."),
		Line("var TestSet = DevelopmentSet"),
		Blank(),
	})
}

func generateServerStruct(entities []MessageInfo) Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// SERVER"),
		Line("// ============================================================================="),
		Blank(),
		Line("// Server holds all services and provides HTTP handlers."),
		Line("type Server struct {"),
		FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
			return Linef("	%sService *%sServiceServer", m.GoName, m.GoName)
		}),
		Line("	mux *http.ServeMux"),
		Line("}"),
		Blank(),
	})
}

func generateServerConstructor(entities []MessageInfo) Code {
	// Build parameter list
	params := FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
		return Linef("	%sService *%sServiceServer,", lowerFirst(m.GoName), m.GoName)
	})

	// Build struct initialization
	fields := FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
		return Linef("		%sService: %sService,", m.GoName, lowerFirst(m.GoName))
	})

	// Build service registration
	registrations := FoldMap(entities, CodeMonoid, func(m MessageInfo) Code {
		return Linef("	Register%sServiceServer(s.mux, s.%sService)", m.GoName, m.GoName)
	})

	return Concat(CodeMonoid, []Code{
		Line("// NewServer creates a new Server with all services wired."),
		Line("func NewServer("),
		params,
		Line(") *Server {"),
		Line("	s := &Server{"),
		fields,
		Line("		mux: http.NewServeMux(),"),
		Line("	}"),
		Blank(),
		Line("	// Register all services"),
		registrations,
		Blank(),
		Line("	return s"),
		Line("}"),
		Blank(),
		Line("// ServeHTTP implements http.Handler."),
		Line("func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {"),
		Line("	s.mux.ServeHTTP(w, r)"),
		Line("}"),
		Blank(),
		Line("// Handler returns the HTTP handler with CORS support."),
		Line("func (s *Server) Handler() http.Handler {"),
		Line("	return WithCORS(s.mux)"),
		Line("}"),
		Blank(),
		Line("// Run starts the server on the given address."),
		Line("func (s *Server) Run(addr string) error {"),
		Line(`	return http.ListenAndServe(addr, s.Handler())`),
		Line("}"),
		Blank(),
	})
}

func generateWireInjectorsExample(entities []MessageInfo, pkgName string) Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// WIRE INJECTOR EXAMPLES (copy to wire.go)"),
		Line("// ============================================================================="),
		Blank(),
		Line("/*"),
		Line("// wire.go - Copy this to your project and run `wire`"),
		Blank(),
		Line("//go:build wireinject"),
		Blank(),
		Line("package main"),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Blank(),
		Line(`	"cloud.google.com/go/firestore"`),
		Line(`	"github.com/google/wire"`),
		Linef(`	%s "your/import/path"`, pkgName),
		Line(")"),
		Blank(),
		Line("// InitializeProductionServer creates a production server with Firestore."),
		Line("func InitializeProductionServer(ctx context.Context, client *firestore.Client) (*Server, error) {"),
		Line("	wire.Build(ProductionSet)"),
		Line("	return nil, nil"),
		Line("}"),
		Blank(),
		Line("// InitializeProductionRealtimeServer creates a production server with real-time."),
		Line("func InitializeProductionRealtimeServer(ctx context.Context, client *firestore.Client) (*Server, error) {"),
		Line("	wire.Build(ProductionRealtimeSet)"),
		Line("	return nil, nil"),
		Line("}"),
		Blank(),
		Line("// InitializeDevelopmentServer creates a development server with in-memory repos."),
		Line("func InitializeDevelopmentServer() (*Server, error) {"),
		Line("	wire.Build(DevelopmentSet)"),
		Line("	return nil, nil"),
		Line("}"),
		Blank(),
		Line("// InitializeTestServer creates a test server (same as development)."),
		Line("func InitializeTestServer() (*Server, error) {"),
		Line("	wire.Build(TestSet)"),
		Line("	return nil, nil"),
		Line("}"),
		Line("*/"),
		Blank(),
	})
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate || len(f.Messages) == 0 {
				continue
			}

			messages := Map(f.Messages, ExtractMessageInfo)
			entities := Filter(messages, func(m MessageInfo) bool { return m.HasID })

			if len(entities) == 0 {
				continue
			}

			pkgName := string(f.GoPackageName)

			// Generate Wire providers
			wireFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_wire.pb.go", f.GoImportPath)
			wireFile.P(GenerateWire(messages, pkgName).Run())
		}
		return nil
	})
}

// =============================================================================
// HELPERS
// =============================================================================

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			result = append(result, '_')
		}
		result = append(result, unicode.ToLower(r))
	}
	return string(result)
}
