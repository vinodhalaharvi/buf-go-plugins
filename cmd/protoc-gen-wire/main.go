// protoc-gen-wire generates Google Wire provider sets
// Uses entity options to determine which messages get providers
// Generates: RepositorySet, ServiceSet, HandlerSet, ServerSet
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	pluginpb "google.golang.org/protobuf/types/pluginpb"
)

const entityExtensionNumber = 50000

// =============================================================================
// CODE HELPERS
// =============================================================================

type Code struct{ Run func() string }

var empty = Code{Run: func() string { return "" }}

func append2(a, b Code) Code { return Code{Run: func() string { return a.Run() + b.Run() }} }

func concat(codes ...Code) Code {
	result := empty
	for _, c := range codes {
		result = append2(result, c)
	}
	return result
}

func line(s string) Code                    { return Code{Run: func() string { return s + "\n" }} }
func linef(f string, a ...interface{}) Code { return line(fmt.Sprintf(f, a...)) }
func blank() Code                           { return line("") }

// =============================================================================
// ENTITY DETECTION
// =============================================================================

func hasEntityOption(msg *protogen.Message) bool {
	opts := msg.Desc.Options()
	if opts == nil {
		return false
	}
	optsProto, ok := opts.(*descriptorpb.MessageOptions)
	if !ok {
		return false
	}
	b, _ := proto.Marshal(optsProto)
	return containsTag(b, entityExtensionNumber)
}

func containsTag(b []byte, fieldNum int32) bool {
	tag := uint64(fieldNum<<3 | 2)
	i := 0
	for i < len(b) {
		v, n := varint(b[i:])
		if n == 0 {
			break
		}
		if v == tag {
			return true
		}
		i += n
		switch v & 0x7 {
		case 0:
			_, vn := varint(b[i:])
			i += vn
		case 1:
			i += 8
		case 2:
			length, ln := varint(b[i:])
			i += ln + int(length)
		case 5:
			i += 4
		default:
			return false
		}
	}
	return false
}

func varint(b []byte) (uint64, int) {
	var x uint64
	for n := 0; n < len(b) && n < 10; n++ {
		x |= uint64(b[n]&0x7f) << (7 * n)
		if b[n] < 0x80 {
			return x, n + 1
		}
	}
	return 0, 0
}

// =============================================================================
// INFO TYPES
// =============================================================================

type EntityInfo struct {
	GoName string
}

type ServiceInfo struct {
	GoName string
}

// =============================================================================
// WIRE GENERATOR
// =============================================================================

func GenerateWire(entities []EntityInfo, services []ServiceInfo, pkgName, importPath string) Code {
	return concat(
		generateHeader(pkgName, importPath),
		generateRepositorySet(entities),
		generateRepositoryStruct(entities),
		generateServiceProviders(services),
		generateHandlerSet(services, importPath),
		generateServerSet(),
		generateServerStruct(services, importPath),
		generateWireInjectorExample(pkgName, importPath),
	)
}

func generateHeader(pkgName, importPath string) Code {
	return concat(
		line("// Code generated by protoc-gen-wire. DO NOT EDIT."),
		line("// Wire dependency injection providers for proto-generated services."),
		blank(),
		linef("package %s", pkgName),
		blank(),
		line("import ("),
		line(`	"net/http"`),
		line(`	"time"`),
		blank(),
		line(`	"github.com/google/wire"`),
		line(`	"github.com/rs/cors"`),
		line(`	"golang.org/x/net/http2"`),
		line(`	"golang.org/x/net/http2/h2c"`),
		line(")"),
		blank(),
	)
}

func generateRepositorySet(entities []EntityInfo) Code {
	providers := empty
	for _, e := range entities {
		providers = append2(providers, linef("	NewFirestore%sRepository,", e.GoName))
	}

	return concat(
		line("// ============================================================================="),
		line("// REPOSITORY PROVIDERS"),
		line("// ============================================================================="),
		blank(),
		line("// RepositorySet provides all Firestore repositories."),
		line("var RepositorySet = wire.NewSet("),
		providers,
		line("	NewRepositories,"),
		line(")"),
		blank(),
	)
}

func generateRepositoryStruct(entities []EntityInfo) Code {
	fields := empty
	for _, e := range entities {
		fields = append2(fields, linef("	%s *Firestore%sRepository", e.GoName, e.GoName))
	}

	params := empty
	for _, e := range entities {
		params = append2(params, linef("	%s *Firestore%sRepository,", lowerFirst(e.GoName), e.GoName))
	}

	assigns := empty
	for _, e := range entities {
		assigns = append2(assigns, linef("		%s: %s,", e.GoName, lowerFirst(e.GoName)))
	}

	return concat(
		line("// Repositories holds all repository instances."),
		line("type Repositories struct {"),
		fields,
		line("}"),
		blank(),
		line("// NewRepositories creates a Repositories container."),
		line("func NewRepositories("),
		params,
		line(") *Repositories {"),
		line("	return &Repositories{"),
		assigns,
		line("	}"),
		line("}"),
		blank(),
	)
}

func generateServiceProviders(services []ServiceInfo) Code {
	return concat(
		line("// ============================================================================="),
		line("// SERVICE PROVIDERS"),
		line("// ============================================================================="),
		blank(),
		line("// ServiceSet provides all service implementations."),
		line("// Note: Custom services (TokenService, UserService, etc.) should be"),
		line("// provided separately as they require custom logic."),
		line("var ServiceSet = wire.NewSet("),
		line("	// Add custom service providers here"),
		line(")"),
		blank(),
	)
}

func generateHandlerSet(services []ServiceInfo, importPath string) Code {
	// Handler wiring requires custom service implementations
	// This is a placeholder - wire handlers manually in main.go
	return concat(
		line("// ============================================================================="),
		line("// HANDLER REGISTRATION HELPERS"),
		line("// ============================================================================="),
		blank(),
		line("// RegisterHandlers registers all Connect handlers with the mux."),
		line("// Call this from main.go after creating your services."),
		line("// Example:"),
		line("//   mux := NewServerMux()"),
		line("//   mux.Handle(purecertsv1connect.NewUserServiceHandler(userSvc))"),
		line("//   mux.Handle(purecertsv1connect.NewTokenServiceHandler(tokenSvc))"),
		line("//   ..."),
		blank(),
	)
}

func generateServerSet() Code {
	return concat(
		line("// ============================================================================="),
		line("// SERVER SET"),
		line("// ============================================================================="),
		blank(),
		line("// ServerSet wires repositories + handlers into a server."),
		line("var ServerSet = wire.NewSet("),
		line("	RepositorySet,"),
		line("	// ServiceSet, // Uncomment when custom services added"),
		line("	// HandlerSet, // Uncomment when handlers wired"),
		line("	NewServerMux,"),
		line("	NewHTTPServer,"),
		line(")"),
		blank(),
	)
}

func generateServerStruct(services []ServiceInfo, importPath string) Code {
	return concat(
		line("// ============================================================================="),
		line("// SERVER HELPERS"),
		line("// ============================================================================="),
		blank(),
		line("// ServerConfig holds server configuration."),
		line("type ServerConfig struct {"),
		line("	Port            string"),
		line("	AllowedOrigins  []string"),
		line("	ReadTimeout     time.Duration"),
		line("	WriteTimeout    time.Duration"),
		line("}"),
		blank(),
		line("// DefaultServerConfig returns sensible defaults."),
		line("func DefaultServerConfig() *ServerConfig {"),
		line("	return &ServerConfig{"),
		line(`		Port:           "8080",`),
		line(`		AllowedOrigins: []string{"http://localhost:3000", "http://localhost:5173"},`),
		line("		ReadTimeout:    30 * time.Second,"),
		line("		WriteTimeout:   30 * time.Second,"),
		line("	}"),
		line("}"),
		blank(),
		line("// NewServerMux creates a new HTTP mux."),
		line("func NewServerMux() *http.ServeMux {"),
		line("	mux := http.NewServeMux()"),
		line("	"),
		line("	// Health check"),
		line(`	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {`),
		line(`		w.Header().Set("Content-Type", "application/json")`),
		line("		w.Write([]byte(`{\"status\":\"ok\"}`))"),
		line("	})"),
		line("	"),
		line("	return mux"),
		line("}"),
		blank(),
		line("// RegisterHandler registers a Connect handler with the mux."),
		line("func RegisterHandler(mux *http.ServeMux, path string, handler http.Handler) {"),
		line("	mux.Handle(path, handler)"),
		line("}"),
		blank(),
		line("// NewHTTPServer creates an HTTP server with CORS and HTTP/2."),
		line("func NewHTTPServer(mux *http.ServeMux, cfg *ServerConfig) *http.Server {"),
		line("	if cfg == nil {"),
		line("		cfg = DefaultServerConfig()"),
		line("	}"),
		blank(),
		line("	corsHandler := cors.New(cors.Options{"),
		line("		AllowedOrigins:   cfg.AllowedOrigins,"),
		line(`		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},`),
		line(`		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "Connect-Protocol-Version"},`),
		line(`		ExposedHeaders:   []string{"Grpc-Status", "Grpc-Message"},`),
		line("		AllowCredentials: true,"),
		line("	}).Handler(mux)"),
		blank(),
		line("	return &http.Server{"),
		line(`		Addr:         ":" + cfg.Port,`),
		line("		Handler:      h2c.NewHandler(corsHandler, &http2.Server{}),"),
		line("		ReadTimeout:  cfg.ReadTimeout,"),
		line("		WriteTimeout: cfg.WriteTimeout,"),
		line("	}"),
		line("}"),
		blank(),
	)
}

func generateWireInjectorExample(pkgName, importPath string) Code {
	return concat(
		line("// ============================================================================="),
		line("// WIRE INJECTOR EXAMPLE"),
		line("// ============================================================================="),
		blank(),
		line("/*"),
		line("Copy this to cmd/server/wire.go:"),
		blank(),
		line("//go:build wireinject"),
		blank(),
		line("package main"),
		blank(),
		line("import ("),
		line(`	"cloud.google.com/go/firestore"`),
		line(`	"github.com/google/wire"`),
		linef(`	pb "%s"`, importPath),
		line(")"),
		blank(),
		line("func InitializeServer(client *firestore.Client, cfg *pb.ServerConfig) (*http.Server, error) {"),
		line("	wire.Build(pb.ServerSet)"),
		line("	return nil, nil"),
		line("}"),
		blank(),
		line("Then run: wire ./cmd/server"),
		line("*/"),
		blank(),
	)
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			// Find entities (messages with entity option)
			var entities []EntityInfo
			for _, msg := range f.Messages {
				if hasEntityOption(msg) {
					entities = append(entities, EntityInfo{GoName: msg.GoIdent.GoName})
				}
			}

			// Find services
			var services []ServiceInfo
			for _, svc := range f.Services {
				services = append(services, ServiceInfo{GoName: svc.GoName})
			}

			if len(entities) == 0 && len(services) == 0 {
				continue
			}

			pkgName := string(f.GoPackageName)
			importPath := string(f.GoImportPath)

			g := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_wire.pb.go", f.GoImportPath)
			g.P(GenerateWire(entities, services, pkgName, importPath).Run())
		}
		return nil
	})
}

// =============================================================================
// HELPERS
// =============================================================================

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}
