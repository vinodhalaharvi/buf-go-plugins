// protoc-gen-deploy generates deployment configuration for Cloud Run
// Generates: Dockerfile, cloudbuild.yaml, main.go server entrypoint
// Uses Category Theory: Monoid + Functor + Fold
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// =============================================================================
// CATEGORY THEORY FOUNDATIONS
// =============================================================================

type Monoid[A any] struct {
	Empty  func() A
	Append func(A, A) A
}

type Code struct{ Run func() string }

var CodeMonoid = Monoid[Code]{
	Empty:  func() Code { return Code{Run: func() string { return "" }} },
	Append: func(a, b Code) Code { return Code{Run: func() string { return a.Run() + b.Run() }} },
}

func FoldRight[A, B any](xs []A, z B, f func(A, B) B) B {
	if len(xs) == 0 {
		return z
	}
	return f(xs[0], FoldRight(xs[1:], z, f))
}

func Concat[A any](m Monoid[A], xs []A) A {
	return FoldRight(xs, m.Empty(), func(a A, acc A) A { return m.Append(a, acc) })
}

func Map[A, B any](xs []A, f func(A) B) []B {
	return FoldRight(xs, []B{}, func(a A, acc []B) []B { return append([]B{f(a)}, acc...) })
}

func FoldMap[A, B any](xs []A, m Monoid[B], f func(A) B) B { return Concat(m, Map(xs, f)) }

func Filter[A any](xs []A, pred func(A) bool) []A {
	return FoldRight(xs, []A{}, func(a A, acc []A) []A {
		if pred(a) {
			return append([]A{a}, acc...)
		}
		return acc
	})
}

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }
func Raw(s string) Code                             { return Code{Run: func() string { return s }} }

// =============================================================================
// SERVICE INFO
// =============================================================================

type ServiceInfo struct {
	Name    string
	Package string
	Methods []string
}

func ExtractServices(file *protogen.File) []ServiceInfo {
	return Map(file.Services, func(svc *protogen.Service) ServiceInfo {
		return ServiceInfo{
			Name:    svc.GoName,
			Package: string(file.GoPackageName),
			Methods: Map(svc.Methods, func(m *protogen.Method) string { return m.GoName }),
		}
	})
}

// =============================================================================
// DOCKERFILE GENERATOR
// =============================================================================

func GenerateDockerfile(moduleName string) Code {
	return Raw(fmt.Sprintf(`# Generated by protoc-gen-deploy
# Multi-stage build for minimal image size

# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Install build dependencies
RUN apk add --no-cache git ca-certificates

# Copy go mod files first for better caching
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build the binary
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags="-w -s" \
    -o /server \
    ./cmd/server

# Runtime stage
FROM alpine:3.19

# Add ca-certificates for HTTPS and tzdata for timezones
RUN apk --no-cache add ca-certificates tzdata

WORKDIR /

# Copy binary from builder
COPY --from=builder /server /server

# Create non-root user
RUN adduser -D -g '' appuser
USER appuser

# Expose port (Cloud Run uses PORT env var)
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Run
ENTRYPOINT ["/server"]
`))
}

// =============================================================================
// CLOUD BUILD GENERATOR
// =============================================================================

func GenerateCloudBuild(serviceName, region string) Code {
	return Raw(fmt.Sprintf(`# Generated by protoc-gen-deploy
# Cloud Build configuration for Cloud Run deployment

steps:
  # Build the container image
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '-t'
      - 'gcr.io/$PROJECT_ID/%s:$COMMIT_SHA'
      - '-t'
      - 'gcr.io/$PROJECT_ID/%s:latest'
      - '.'

  # Push the container image to Container Registry
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - 'gcr.io/$PROJECT_ID/%s:$COMMIT_SHA'

  # Push latest tag
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - 'gcr.io/$PROJECT_ID/%s:latest'

  # Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '%s'
      - '--image'
      - 'gcr.io/$PROJECT_ID/%s:$COMMIT_SHA'
      - '--region'
      - '%s'
      - '--platform'
      - 'managed'
      - '--allow-unauthenticated'
      - '--port'
      - '8080'
      - '--memory'
      - '512Mi'
      - '--cpu'
      - '1'
      - '--min-instances'
      - '0'
      - '--max-instances'
      - '10'
      - '--set-env-vars'
      - 'GIN_MODE=release'

# Store images in Container Registry
images:
  - 'gcr.io/$PROJECT_ID/%s:$COMMIT_SHA'
  - 'gcr.io/$PROJECT_ID/%s:latest'

# Build options
options:
  logging: CLOUD_LOGGING_ONLY

# Timeout
timeout: '1200s'
`, serviceName, serviceName, serviceName, serviceName, serviceName, serviceName, region, serviceName, serviceName))
}

// =============================================================================
// CLOUD RUN SERVICE YAML
// =============================================================================

func GenerateCloudRunService(serviceName, region string) Code {
	return Raw(fmt.Sprintf(`# Generated by protoc-gen-deploy
# Cloud Run service configuration (for terraform or manual deployment)

apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: %s
  annotations:
    run.googleapis.com/ingress: all
spec:
  template:
    metadata:
      annotations:
        autoscaling.knative.dev/minScale: "0"
        autoscaling.knative.dev/maxScale: "10"
        run.googleapis.com/cpu-throttling: "true"
    spec:
      containerConcurrency: 80
      timeoutSeconds: 300
      containers:
        - image: gcr.io/PROJECT_ID/%s:latest
          ports:
            - containerPort: 8080
          resources:
            limits:
              cpu: "1"
              memory: 512Mi
          env:
            - name: PORT
              value: "8080"
            - name: ENV
              value: production
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
`, serviceName, serviceName))
}

// =============================================================================
// SERVER MAIN.GO GENERATOR
// =============================================================================

func GenerateServerMain(services []ServiceInfo, moduleName, pkgPath string) Code {
	if len(services) == 0 {
		return CodeMonoid.Empty()
	}

	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-deploy. DO NOT EDIT."),
		Line("// Server entrypoint for Cloud Run deployment"),
		Blank(),
		Line("package main"),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"fmt"`),
		Line(`	"log"`),
		Line(`	"net/http"`),
		Line(`	"os"`),
		Line(`	"os/signal"`),
		Line(`	"syscall"`),
		Line(`	"time"`),
		Blank(),
		Line(`	"golang.org/x/net/http2"`),
		Line(`	"golang.org/x/net/http2/h2c"`),
		Linef(`	pb "%s"`, pkgPath),
		Line(")"),
		Blank(),
		Line("func main() {"),
		Line("	// Get port from environment (Cloud Run sets PORT)"),
		Line(`	port := os.Getenv("PORT")`),
		Line(`	if port == "" {`),
		Line(`		port = "8080"`),
		Line("	}"),
		Blank(),
		Line("	// Create HTTP mux"),
		Line("	mux := http.NewServeMux()"),
		Blank(),
		Line("	// Health check endpoint"),
		Line(`	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {`),
		Line(`		w.WriteHeader(http.StatusOK)`),
		Line(`		w.Write([]byte("ok"))`),
		Line("	})"),
		Blank(),
		Line("	// Initialize repositories (using in-memory for now, swap for Firestore in production)"),
		FoldMap(services, CodeMonoid, func(svc ServiceInfo) Code {
			// Try to infer entity name from service name (UserService -> User)
			entityName := strings.TrimSuffix(svc.Name, "Service")
			return Linef("	%sRepo := pb.NewInMemory%sRepository()", lowerFirst(entityName), entityName)
		}),
		Blank(),
		Line("	// Register service handlers"),
		FoldMap(services, CodeMonoid, func(svc ServiceInfo) Code {
			entityName := strings.TrimSuffix(svc.Name, "Service")
			return Concat(CodeMonoid, []Code{
				Linef("	%sServer := pb.New%sServer(%sRepo)", lowerFirst(entityName), svc.Name, lowerFirst(entityName)),
				Linef("	path, handler := pb.New%sHandler(%sServer)", svc.Name, lowerFirst(entityName)),
				Line("	mux.Handle(path, handler)"),
				Blank(),
			})
		}),
		Line("	// Create server with HTTP/2 support (required for Connect)"),
		Line("	server := &http.Server{"),
		Line(`		Addr:         ":" + port,`),
		Line("		Handler:      h2c.NewHandler(mux, &http2.Server{}),"),
		Line("		ReadTimeout:  30 * time.Second,"),
		Line("		WriteTimeout: 30 * time.Second,"),
		Line("		IdleTimeout:  120 * time.Second,"),
		Line("	}"),
		Blank(),
		Line("	// Graceful shutdown"),
		Line("	go func() {"),
		Line("		sigChan := make(chan os.Signal, 1)"),
		Line("		signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)"),
		Line("		<-sigChan"),
		Blank(),
		Line(`		log.Println("Shutting down server...")`),
		Line("		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)"),
		Line("		defer cancel()"),
		Blank(),
		Line("		if err := server.Shutdown(ctx); err != nil {"),
		Line(`			log.Printf("Server shutdown error: %v", err)`),
		Line("		}"),
		Line("	}()"),
		Blank(),
		Line(`	log.Printf("Server starting on port %s", port)`),
		Line("	if err := server.ListenAndServe(); err != http.ErrServerClosed {"),
		Line(`		log.Fatalf("Server error: %v", err)`),
		Line("	}"),
		Blank(),
		Line(`	log.Println("Server stopped")`),
		Line("}"),
	})
}

// =============================================================================
// MAKEFILE DEPLOY TARGETS
// =============================================================================

func GenerateMakefileTargets(serviceName string) Code {
	return Raw(fmt.Sprintf(`# Generated by protoc-gen-deploy
# Add these targets to your Makefile

.PHONY: docker-build docker-run docker-push deploy-cloudrun

# Build Docker image locally
docker-build:
	docker build -t %s:latest .

# Run Docker image locally
docker-run: docker-build
	docker run -p 8080:8080 -e PORT=8080 %s:latest

# Push to Google Container Registry
docker-push:
	docker tag %s:latest gcr.io/$$(gcloud config get-value project)/%s:latest
	docker push gcr.io/$$(gcloud config get-value project)/%s:latest

# Deploy to Cloud Run
deploy-cloudrun:
	gcloud run deploy %s \
		--source . \
		--region us-central1 \
		--platform managed \
		--allow-unauthenticated

# Deploy using Cloud Build
deploy-cloudbuild:
	gcloud builds submit --config cloudbuild.yaml

# View Cloud Run logs
logs:
	gcloud run services logs read %s --region us-central1 --limit 100

# Get Cloud Run URL
url:
	@gcloud run services describe %s --region us-central1 --format 'value(status.url)'
`, serviceName, serviceName, serviceName, serviceName, serviceName, serviceName, serviceName, serviceName))
}

// =============================================================================
// .DOCKERIGNORE GENERATOR
// =============================================================================

func GenerateDockerIgnore() Code {
	return Raw(`# Generated by protoc-gen-deploy

# Git
.git
.gitignore

# IDE
.idea
.vscode
*.swp
*.swo

# Build artifacts
bin/
dist/

# Test files
*_test.go
testdata/

# Documentation
*.md
docs/

# Generated UI (separate deployment)
gen/ui/
node_modules/

# Local config
.env
.env.local
*.local

# OS files
.DS_Store
Thumbs.db
`)
}

// =============================================================================
// ENV EXAMPLE
// =============================================================================

func GenerateEnvExample() Code {
	return Raw(`# Generated by protoc-gen-deploy
# Copy to .env and fill in values

# Server
PORT=8080
ENV=development

# Google Cloud
GOOGLE_CLOUD_PROJECT=your-project-id
GOOGLE_APPLICATION_CREDENTIALS=path/to/service-account.json

# Firestore (production)
FIRESTORE_PROJECT_ID=your-project-id

# Auth (if using protoc-gen-auth)
JWT_SECRET=your-secret-key-change-in-production
JWT_EXPIRY=24h

# Optional: Anthropic (if using protoc-gen-llm)
ANTHROPIC_API_KEY=sk-ant-...
`)
}

// =============================================================================
// HELPERS
// =============================================================================

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('-')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		// Track if we've generated deployment files
		generated := false

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			services := ExtractServices(f)
			if len(services) == 0 {
				continue
			}

			// Only generate deployment files once
			if !generated {
				generated = true

				// Derive service name from package
				serviceName := toSnakeCase(string(f.GoPackageName))
				if serviceName == "" {
					serviceName = "app"
				}

				moduleName := string(f.GoImportPath)
				region := "us-central1"

				// Generate Dockerfile
				dockerfile := gen.NewGeneratedFile("Dockerfile", "")
				dockerfile.P(GenerateDockerfile(moduleName).Run())

				// Generate .dockerignore
				dockerignore := gen.NewGeneratedFile(".dockerignore", "")
				dockerignore.P(GenerateDockerIgnore().Run())

				// Generate cloudbuild.yaml
				cloudbuild := gen.NewGeneratedFile("cloudbuild.yaml", "")
				cloudbuild.P(GenerateCloudBuild(serviceName, region).Run())

				// Generate Cloud Run service.yaml
				serviceYaml := gen.NewGeneratedFile("deploy/cloudrun-service.yaml", "")
				serviceYaml.P(GenerateCloudRunService(serviceName, region).Run())

				// Generate Makefile targets
				makeTargets := gen.NewGeneratedFile("deploy/Makefile.deploy", "")
				makeTargets.P(GenerateMakefileTargets(serviceName).Run())

				// Generate .env.example
				envExample := gen.NewGeneratedFile(".env.example", "")
				envExample.P(GenerateEnvExample().Run())

				// Generate server main.go
				pkgPath := string(f.GoImportPath)
				serverMain := gen.NewGeneratedFile("cmd/server/main.go", "")
				serverMain.P(GenerateServerMain(services, moduleName, pkgPath).Run())
			}
		}
		return nil
	})
}
