// protoc-gen-auth generates authentication & authorization
// - JWT middleware (Go)
// - RBAC checks (Go)
// - Auth context + hooks (React)
// - Login/Register pages (React)
package main

import (
	"fmt"
	"strings"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
)

// =============================================================================
// CATEGORY THEORY FOUNDATIONS
// =============================================================================

type Monoid[A any] struct {
	Empty  func() A
	Append func(A, A) A
}

type Code struct{ Run func() string }

var CodeMonoid = Monoid[Code]{
	Empty:  func() Code { return Code{Run: func() string { return "" }} },
	Append: func(a, b Code) Code { return Code{Run: func() string { return a.Run() + b.Run() }} },
}

func Concat[A any](m Monoid[A], xs []A) A {
	if len(xs) == 0 {
		return m.Empty()
	}
	result := xs[0]
	for _, x := range xs[1:] {
		result = m.Append(result, x)
	}
	return result
}

func Map[A, B any](xs []A, f func(A) B) []B {
	result := make([]B, len(xs))
	for i, x := range xs {
		result[i] = f(x)
	}
	return result
}

func FoldMap[A, B any](xs []A, m Monoid[B], f func(A) B) B { return Concat(m, Map(xs, f)) }

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }

// =============================================================================
// GO AUTH MIDDLEWARE GENERATOR
// =============================================================================

func GenerateGoAuth(pkgName string) Code {
	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-auth. DO NOT EDIT."),
		Blank(),
		Linef("package %s", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"errors"`),
		Line(`	"net/http"`),
		Line(`	"strings"`),
		Line(`	"time"`),
		Line(""),
		Line(`	"github.com/golang-jwt/jwt/v5"`),
		Line(")"),
		Blank(),
		generateAuthErrors(),
		generateAuthClaims(),
		generateAuthConfig(),
		generateJWTFunctions(),
		generateAuthMiddleware(),
		generateRBACMiddleware(),
		generateAuthHandlers(),
	})
}

func generateAuthErrors() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Auth errors"),
		Line("var ("),
		Line(`	ErrUnauthorized    = errors.New("unauthorized")`),
		Line(`	ErrInvalidToken    = errors.New("invalid token")`),
		Line(`	ErrTokenExpired    = errors.New("token expired")`),
		Line(`	ErrInsufficientRole = errors.New("insufficient permissions")`),
		Line(")"),
		Blank(),
	})
}

func generateAuthClaims() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Role represents user roles"),
		Line("type Role string"),
		Blank(),
		Line("const ("),
		Line(`	RoleUser      Role = "user"`),
		Line(`	RoleAdmin     Role = "admin"`),
		Line(`	RoleModerator Role = "moderator"`),
		Line(")"),
		Blank(),
		Line("// AuthClaims contains JWT claims"),
		Line("type AuthClaims struct {"),
		Line("	jwt.RegisteredClaims"),
		Line("	UserID string `json:\"user_id\"`"),
		Line("	Email  string `json:\"email\"`"),
		Line("	Role   Role   `json:\"role\"`"),
		Line("}"),
		Blank(),
		Line("// AuthUser represents the authenticated user in context"),
		Line("type AuthUser struct {"),
		Line("	ID    string"),
		Line("	Email string"),
		Line("	Role  Role"),
		Line("}"),
		Blank(),
		Line("type contextKey string"),
		Line(`const authUserKey contextKey = "auth_user"`),
		Blank(),
		Line("// GetAuthUser retrieves the authenticated user from context"),
		Line("func GetAuthUser(ctx context.Context) (*AuthUser, bool) {"),
		Line("	user, ok := ctx.Value(authUserKey).(*AuthUser)"),
		Line("	return user, ok"),
		Line("}"),
		Blank(),
		Line("// MustGetAuthUser retrieves the authenticated user or panics"),
		Line("func MustGetAuthUser(ctx context.Context) *AuthUser {"),
		Line("	user, ok := GetAuthUser(ctx)"),
		Line("	if !ok {"),
		Line(`		panic("no authenticated user in context")`),
		Line("	}"),
		Line("	return user"),
		Line("}"),
		Blank(),
	})
}

func generateAuthConfig() Code {
	return Concat(CodeMonoid, []Code{
		Line("// AuthConfig holds authentication configuration"),
		Line("type AuthConfig struct {"),
		Line("	SecretKey       string"),
		Line("	TokenExpiry     time.Duration"),
		Line("	RefreshExpiry   time.Duration"),
		Line("	Issuer          string"),
		Line("}"),
		Blank(),
		Line("// DefaultAuthConfig returns sensible defaults"),
		Line("func DefaultAuthConfig(secret string) AuthConfig {"),
		Line("	return AuthConfig{"),
		Line("		SecretKey:     secret,"),
		Line("		TokenExpiry:   15 * time.Minute,"),
		Line("		RefreshExpiry: 7 * 24 * time.Hour,"),
		Line(`		Issuer:        "app",`),
		Line("	}"),
		Line("}"),
		Blank(),
		Line("var authConfig AuthConfig"),
		Blank(),
		Line("// InitAuth initializes authentication with config"),
		Line("func InitAuth(cfg AuthConfig) {"),
		Line("	authConfig = cfg"),
		Line("}"),
		Blank(),
	})
}

func generateJWTFunctions() Code {
	return Concat(CodeMonoid, []Code{
		Line("// GenerateToken creates a new JWT token"),
		Line("func GenerateToken(userID, email string, role Role) (string, error) {"),
		Line("	claims := AuthClaims{"),
		Line("		RegisteredClaims: jwt.RegisteredClaims{"),
		Line("			ExpiresAt: jwt.NewNumericDate(time.Now().Add(authConfig.TokenExpiry)),"),
		Line("			IssuedAt:  jwt.NewNumericDate(time.Now()),"),
		Line("			Issuer:    authConfig.Issuer,"),
		Line("			Subject:   userID,"),
		Line("		},"),
		Line("		UserID: userID,"),
		Line("		Email:  email,"),
		Line("		Role:   role,"),
		Line("	}"),
		Blank(),
		Line("	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)"),
		Line("	return token.SignedString([]byte(authConfig.SecretKey))"),
		Line("}"),
		Blank(),
		Line("// GenerateRefreshToken creates a refresh token"),
		Line("func GenerateRefreshToken(userID string) (string, error) {"),
		Line("	claims := jwt.RegisteredClaims{"),
		Line("		ExpiresAt: jwt.NewNumericDate(time.Now().Add(authConfig.RefreshExpiry)),"),
		Line("		IssuedAt:  jwt.NewNumericDate(time.Now()),"),
		Line("		Issuer:    authConfig.Issuer,"),
		Line("		Subject:   userID,"),
		Line("	}"),
		Blank(),
		Line("	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)"),
		Line("	return token.SignedString([]byte(authConfig.SecretKey))"),
		Line("}"),
		Blank(),
		Line("// ValidateToken validates a JWT token and returns claims"),
		Line("func ValidateToken(tokenString string) (*AuthClaims, error) {"),
		Line("	token, err := jwt.ParseWithClaims(tokenString, &AuthClaims{}, func(token *jwt.Token) (interface{}, error) {"),
		Line("		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {"),
		Line(`			return nil, errors.New("unexpected signing method")`),
		Line("		}"),
		Line("		return []byte(authConfig.SecretKey), nil"),
		Line("	})"),
		Blank(),
		Line("	if err != nil {"),
		Line("		if errors.Is(err, jwt.ErrTokenExpired) {"),
		Line("			return nil, ErrTokenExpired"),
		Line("		}"),
		Line("		return nil, ErrInvalidToken"),
		Line("	}"),
		Blank(),
		Line("	claims, ok := token.Claims.(*AuthClaims)"),
		Line("	if !ok || !token.Valid {"),
		Line("		return nil, ErrInvalidToken"),
		Line("	}"),
		Blank(),
		Line("	return claims, nil"),
		Line("}"),
		Blank(),
	})
}

func generateAuthMiddleware() Code {
	return Concat(CodeMonoid, []Code{
		Line("// AuthMiddleware validates JWT and injects user into context"),
		Line("func AuthMiddleware(next http.Handler) http.Handler {"),
		Line("	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {"),
		Line(`		authHeader := r.Header.Get("Authorization")`),
		Line(`		if authHeader == "" {`),
		Line("			http.Error(w, ErrUnauthorized.Error(), http.StatusUnauthorized)"),
		Line("			return"),
		Line("		}"),
		Blank(),
		Line(`		parts := strings.Split(authHeader, " ")`),
		Line(`		if len(parts) != 2 || parts[0] != "Bearer" {`),
		Line("			http.Error(w, ErrInvalidToken.Error(), http.StatusUnauthorized)"),
		Line("			return"),
		Line("		}"),
		Blank(),
		Line("		claims, err := ValidateToken(parts[1])"),
		Line("		if err != nil {"),
		Line("			http.Error(w, err.Error(), http.StatusUnauthorized)"),
		Line("			return"),
		Line("		}"),
		Blank(),
		Line("		user := &AuthUser{"),
		Line("			ID:    claims.UserID,"),
		Line("			Email: claims.Email,"),
		Line("			Role:  claims.Role,"),
		Line("		}"),
		Blank(),
		Line("		ctx := context.WithValue(r.Context(), authUserKey, user)"),
		Line("		next.ServeHTTP(w, r.WithContext(ctx))"),
		Line("	})"),
		Line("}"),
		Blank(),
		Line("// OptionalAuthMiddleware extracts user if token present, but doesn't require it"),
		Line("func OptionalAuthMiddleware(next http.Handler) http.Handler {"),
		Line("	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {"),
		Line(`		authHeader := r.Header.Get("Authorization")`),
		Line(`		if authHeader != "" {`),
		Line(`			parts := strings.Split(authHeader, " ")`),
		Line(`			if len(parts) == 2 && parts[0] == "Bearer" {`),
		Line("				if claims, err := ValidateToken(parts[1]); err == nil {"),
		Line("					user := &AuthUser{ID: claims.UserID, Email: claims.Email, Role: claims.Role}"),
		Line("					ctx := context.WithValue(r.Context(), authUserKey, user)"),
		Line("					r = r.WithContext(ctx)"),
		Line("				}"),
		Line("			}"),
		Line("		}"),
		Line("		next.ServeHTTP(w, r)"),
		Line("	})"),
		Line("}"),
		Blank(),
	})
}

func generateRBACMiddleware() Code {
	return Concat(CodeMonoid, []Code{
		Line("// RequireRole middleware checks if user has required role"),
		Line("func RequireRole(roles ...Role) func(http.Handler) http.Handler {"),
		Line("	return func(next http.Handler) http.Handler {"),
		Line("		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {"),
		Line("			user, ok := GetAuthUser(r.Context())"),
		Line("			if !ok {"),
		Line("				http.Error(w, ErrUnauthorized.Error(), http.StatusUnauthorized)"),
		Line("				return"),
		Line("			}"),
		Blank(),
		Line("			hasRole := false"),
		Line("			for _, role := range roles {"),
		Line("				if user.Role == role {"),
		Line("					hasRole = true"),
		Line("					break"),
		Line("				}"),
		Line("			}"),
		Blank(),
		Line("			if !hasRole {"),
		Line("				http.Error(w, ErrInsufficientRole.Error(), http.StatusForbidden)"),
		Line("				return"),
		Line("			}"),
		Blank(),
		Line("			next.ServeHTTP(w, r)"),
		Line("		})"),
		Line("	}"),
		Line("}"),
		Blank(),
		Line("// RequireOwner middleware checks if user owns the resource"),
		Line("func RequireOwner(getOwnerID func(r *http.Request) string) func(http.Handler) http.Handler {"),
		Line("	return func(next http.Handler) http.Handler {"),
		Line("		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {"),
		Line("			user, ok := GetAuthUser(r.Context())"),
		Line("			if !ok {"),
		Line("				http.Error(w, ErrUnauthorized.Error(), http.StatusUnauthorized)"),
		Line("				return"),
		Line("			}"),
		Blank(),
		Line("			// Admins can access any resource"),
		Line("			if user.Role == RoleAdmin {"),
		Line("				next.ServeHTTP(w, r)"),
		Line("				return"),
		Line("			}"),
		Blank(),
		Line("			ownerID := getOwnerID(r)"),
		Line("			if ownerID != user.ID {"),
		Line("				http.Error(w, ErrInsufficientRole.Error(), http.StatusForbidden)"),
		Line("				return"),
		Line("			}"),
		Blank(),
		Line("			next.ServeHTTP(w, r)"),
		Line("		})"),
		Line("	}"),
		Line("}"),
		Blank(),
	})
}

func generateAuthHandlers() Code {
	return Concat(CodeMonoid, []Code{
		Line("// LoginRequest for login endpoint"),
		Line("type LoginRequest struct {"),
		Line("	Email    string `json:\"email\"`"),
		Line("	Password string `json:\"password\"`"),
		Line("}"),
		Blank(),
		Line("// LoginResponse from login endpoint"),
		Line("type LoginResponse struct {"),
		Line("	AccessToken  string `json:\"access_token\"`"),
		Line("	RefreshToken string `json:\"refresh_token\"`"),
		Line("	ExpiresIn    int64  `json:\"expires_in\"`"),
		Line("	User         AuthUser `json:\"user\"`"),
		Line("}"),
		Blank(),
		Line("// RegisterRequest for registration"),
		Line("type RegisterRequest struct {"),
		Line("	Email    string `json:\"email\"`"),
		Line("	Password string `json:\"password\"`"),
		Line("	Name     string `json:\"name\"`"),
		Line("}"),
		Blank(),
		Line("// RefreshRequest for token refresh"),
		Line("type RefreshRequest struct {"),
		Line("	RefreshToken string `json:\"refresh_token\"`"),
		Line("}"),
		Blank(),
		Line("// PasswordHasher interface for password hashing"),
		Line("type PasswordHasher interface {"),
		Line("	Hash(password string) (string, error)"),
		Line("	Compare(hashed, password string) bool"),
		Line("}"),
		Blank(),
		Line("// UserStore interface for user persistence"),
		Line("type UserStore interface {"),
		Line("	GetByEmail(ctx context.Context, email string) (*AuthUser, string, error) // returns user, hashed password"),
		Line("	Create(ctx context.Context, email, hashedPassword, name string) (*AuthUser, error)"),
		Line("	GetByID(ctx context.Context, id string) (*AuthUser, error)"),
		Line("}"),
		Blank(),
		Line("// AuthService handles authentication"),
		Line("type AuthService struct {"),
		Line("	users  UserStore"),
		Line("	hasher PasswordHasher"),
		Line("}"),
		Blank(),
		Line("// NewAuthService creates a new auth service"),
		Line("func NewAuthService(users UserStore, hasher PasswordHasher) *AuthService {"),
		Line("	return &AuthService{users: users, hasher: hasher}"),
		Line("}"),
		Blank(),
		Line("// Login authenticates a user"),
		Line("func (s *AuthService) Login(ctx context.Context, req LoginRequest) (*LoginResponse, error) {"),
		Line("	user, hashedPw, err := s.users.GetByEmail(ctx, req.Email)"),
		Line("	if err != nil {"),
		Line("		return nil, ErrUnauthorized"),
		Line("	}"),
		Blank(),
		Line("	if !s.hasher.Compare(hashedPw, req.Password) {"),
		Line("		return nil, ErrUnauthorized"),
		Line("	}"),
		Blank(),
		Line("	accessToken, err := GenerateToken(user.ID, user.Email, user.Role)"),
		Line("	if err != nil {"),
		Line("		return nil, err"),
		Line("	}"),
		Blank(),
		Line("	refreshToken, err := GenerateRefreshToken(user.ID)"),
		Line("	if err != nil {"),
		Line("		return nil, err"),
		Line("	}"),
		Blank(),
		Line("	return &LoginResponse{"),
		Line("		AccessToken:  accessToken,"),
		Line("		RefreshToken: refreshToken,"),
		Line("		ExpiresIn:    int64(authConfig.TokenExpiry.Seconds()),"),
		Line("		User:         *user,"),
		Line("	}, nil"),
		Line("}"),
		Blank(),
		Line("// Register creates a new user"),
		Line("func (s *AuthService) Register(ctx context.Context, req RegisterRequest) (*LoginResponse, error) {"),
		Line("	hashedPw, err := s.hasher.Hash(req.Password)"),
		Line("	if err != nil {"),
		Line("		return nil, err"),
		Line("	}"),
		Blank(),
		Line("	user, err := s.users.Create(ctx, req.Email, hashedPw, req.Name)"),
		Line("	if err != nil {"),
		Line("		return nil, err"),
		Line("	}"),
		Blank(),
		Line("	return s.Login(ctx, LoginRequest{Email: req.Email, Password: req.Password})"),
		Line("}"),
		Blank(),
	})
}

// =============================================================================
// REACT AUTH GENERATOR
// =============================================================================

func GenerateReactAuth() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-auth. DO NOT EDIT."),
		Blank(),
		Line(`import { createContext, useContext, useState, useEffect, ReactNode } from "react";`),
		Line(`import { useNavigate } from "react-router-dom";`),
		Blank(),
		generateAuthTypes(),
		generateAuthContext(),
		generateAuthHooks(),
		generateLoginPage(),
		generateRegisterPage(),
		generateProtectedRoute(),
	})
}

func generateAuthTypes() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Types"),
		Line("export interface AuthUser {"),
		Line("  id: string;"),
		Line("  email: string;"),
		Line("  role: 'user' | 'admin' | 'moderator';"),
		Line("}"),
		Blank(),
		Line("export interface LoginRequest {"),
		Line("  email: string;"),
		Line("  password: string;"),
		Line("}"),
		Blank(),
		Line("export interface RegisterRequest {"),
		Line("  email: string;"),
		Line("  password: string;"),
		Line("  name: string;"),
		Line("}"),
		Blank(),
		Line("export interface AuthResponse {"),
		Line("  access_token: string;"),
		Line("  refresh_token: string;"),
		Line("  expires_in: number;"),
		Line("  user: AuthUser;"),
		Line("}"),
		Blank(),
	})
}

func generateAuthContext() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Auth Context"),
		Line("interface AuthContextType {"),
		Line("  user: AuthUser | null;"),
		Line("  isLoading: boolean;"),
		Line("  isAuthenticated: boolean;"),
		Line("  login: (req: LoginRequest) => Promise<void>;"),
		Line("  register: (req: RegisterRequest) => Promise<void>;"),
		Line("  logout: () => void;"),
		Line("  hasRole: (roles: string[]) => boolean;"),
		Line("}"),
		Blank(),
		Line("const AuthContext = createContext<AuthContextType | null>(null);"),
		Blank(),
		Line("const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8080';"),
		Blank(),
		Line("export function AuthProvider({ children }: { children: ReactNode }) {"),
		Line("  const [user, setUser] = useState<AuthUser | null>(null);"),
		Line("  const [isLoading, setIsLoading] = useState(true);"),
		Blank(),
		Line("  useEffect(() => {"),
		Line("    // Check for existing token on mount"),
		Line("    const token = localStorage.getItem('access_token');"),
		Line("    const userData = localStorage.getItem('user');"),
		Line("    if (token && userData) {"),
		Line("      setUser(JSON.parse(userData));"),
		Line("    }"),
		Line("    setIsLoading(false);"),
		Line("  }, []);"),
		Blank(),
		Line("  const login = async (req: LoginRequest) => {"),
		Line("    const res = await fetch(`${API_URL}/auth/login`, {"),
		Line("      method: 'POST',"),
		Line("      headers: { 'Content-Type': 'application/json' },"),
		Line("      body: JSON.stringify(req),"),
		Line("    });"),
		Line("    if (!res.ok) throw new Error('Login failed');"),
		Line("    const data: AuthResponse = await res.json();"),
		Line("    localStorage.setItem('access_token', data.access_token);"),
		Line("    localStorage.setItem('refresh_token', data.refresh_token);"),
		Line("    localStorage.setItem('user', JSON.stringify(data.user));"),
		Line("    setUser(data.user);"),
		Line("  };"),
		Blank(),
		Line("  const register = async (req: RegisterRequest) => {"),
		Line("    const res = await fetch(`${API_URL}/auth/register`, {"),
		Line("      method: 'POST',"),
		Line("      headers: { 'Content-Type': 'application/json' },"),
		Line("      body: JSON.stringify(req),"),
		Line("    });"),
		Line("    if (!res.ok) throw new Error('Registration failed');"),
		Line("    const data: AuthResponse = await res.json();"),
		Line("    localStorage.setItem('access_token', data.access_token);"),
		Line("    localStorage.setItem('refresh_token', data.refresh_token);"),
		Line("    localStorage.setItem('user', JSON.stringify(data.user));"),
		Line("    setUser(data.user);"),
		Line("  };"),
		Blank(),
		Line("  const logout = () => {"),
		Line("    localStorage.removeItem('access_token');"),
		Line("    localStorage.removeItem('refresh_token');"),
		Line("    localStorage.removeItem('user');"),
		Line("    setUser(null);"),
		Line("  };"),
		Blank(),
		Line("  const hasRole = (roles: string[]) => {"),
		Line("    if (!user) return false;"),
		Line("    return roles.includes(user.role);"),
		Line("  };"),
		Blank(),
		Line("  return ("),
		Line("    <AuthContext.Provider value={{ user, isLoading, isAuthenticated: !!user, login, register, logout, hasRole }}>"),
		Line("      {children}"),
		Line("    </AuthContext.Provider>"),
		Line("  );"),
		Line("}"),
		Blank(),
	})
}

func generateAuthHooks() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Auth hooks"),
		Line("export function useAuth() {"),
		Line("  const context = useContext(AuthContext);"),
		Line("  if (!context) throw new Error('useAuth must be used within AuthProvider');"),
		Line("  return context;"),
		Line("}"),
		Blank(),
		Line("export function useRequireAuth() {"),
		Line("  const { isAuthenticated, isLoading } = useAuth();"),
		Line("  const navigate = useNavigate();"),
		Blank(),
		Line("  useEffect(() => {"),
		Line("    if (!isLoading && !isAuthenticated) {"),
		Line("      navigate('/login');"),
		Line("    }"),
		Line("  }, [isAuthenticated, isLoading, navigate]);"),
		Blank(),
		Line("  return { isAuthenticated, isLoading };"),
		Line("}"),
		Blank(),
		Line("export function useRequireRole(roles: string[]) {"),
		Line("  const { hasRole, isLoading } = useAuth();"),
		Line("  const navigate = useNavigate();"),
		Blank(),
		Line("  useEffect(() => {"),
		Line("    if (!isLoading && !hasRole(roles)) {"),
		Line("      navigate('/unauthorized');"),
		Line("    }"),
		Line("  }, [hasRole, isLoading, navigate, roles]);"),
		Line("}"),
		Blank(),
		Line("// Fetch with auth header"),
		Line("export function useAuthFetch() {"),
		Line("  return async (url: string, options: RequestInit = {}) => {"),
		Line("    const token = localStorage.getItem('access_token');"),
		Line("    return fetch(url, {"),
		Line("      ...options,"),
		Line("      headers: {"),
		Line("        ...options.headers,"),
		Line("        'Authorization': token ? `Bearer ${token}` : '',"),
		Line("      },"),
		Line("    });"),
		Line("  };"),
		Line("}"),
		Blank(),
	})
}

func generateLoginPage() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Login Page"),
		Line("export function LoginPage() {"),
		Line("  const [email, setEmail] = useState('');"),
		Line("  const [password, setPassword] = useState('');"),
		Line("  const [error, setError] = useState('');"),
		Line("  const [isLoading, setIsLoading] = useState(false);"),
		Line("  const { login } = useAuth();"),
		Line("  const navigate = useNavigate();"),
		Blank(),
		Line("  const handleSubmit = async (e: React.FormEvent) => {"),
		Line("    e.preventDefault();"),
		Line("    setError('');"),
		Line("    setIsLoading(true);"),
		Line("    try {"),
		Line("      await login({ email, password });"),
		Line("      navigate('/');"),
		Line("    } catch (err) {"),
		Line("      setError('Invalid email or password');"),
		Line("    } finally {"),
		Line("      setIsLoading(false);"),
		Line("    }"),
		Line("  };"),
		Blank(),
		Line("  return ("),
		Line("    <div className=\"min-h-screen flex items-center justify-center bg-gray-100\">"),
		Line("      <div className=\"bg-white p-8 rounded-lg shadow-md w-full max-w-md\">"),
		Line("        <h1 className=\"text-2xl font-bold mb-6 text-center\">Login</h1>"),
		Line("        {error && ("),
		Line("          <div className=\"mb-4 p-3 bg-red-100 text-red-700 rounded\">{error}</div>"),
		Line("        )}"),
		Line("        <form onSubmit={handleSubmit} className=\"space-y-4\">"),
		Line("          <div>"),
		Line("            <label className=\"block text-sm font-medium text-gray-700\">Email</label>"),
		Line("            <input"),
		Line("              type=\"email\""),
		Line("              value={email}"),
		Line("              onChange={(e) => setEmail(e.target.value)}"),
		Line("              required"),
		Line("              className=\"mt-1 block w-full rounded border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500\""),
		Line("            />"),
		Line("          </div>"),
		Line("          <div>"),
		Line("            <label className=\"block text-sm font-medium text-gray-700\">Password</label>"),
		Line("            <input"),
		Line("              type=\"password\""),
		Line("              value={password}"),
		Line("              onChange={(e) => setPassword(e.target.value)}"),
		Line("              required"),
		Line("              className=\"mt-1 block w-full rounded border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500\""),
		Line("            />"),
		Line("          </div>"),
		Line("          <button"),
		Line("            type=\"submit\""),
		Line("            disabled={isLoading}"),
		Line("            className=\"w-full py-2 px-4 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50\""),
		Line("          >"),
		Line("            {isLoading ? 'Logging in...' : 'Login'}"),
		Line("          </button>"),
		Line("        </form>"),
		Line("        <p className=\"mt-4 text-center text-sm text-gray-600\">"),
		Line("          Don't have an account? <a href=\"/register\" className=\"text-blue-600 hover:underline\">Register</a>"),
		Line("        </p>"),
		Line("      </div>"),
		Line("    </div>"),
		Line("  );"),
		Line("}"),
		Blank(),
	})
}

func generateRegisterPage() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Register Page"),
		Line("export function RegisterPage() {"),
		Line("  const [name, setName] = useState('');"),
		Line("  const [email, setEmail] = useState('');"),
		Line("  const [password, setPassword] = useState('');"),
		Line("  const [error, setError] = useState('');"),
		Line("  const [isLoading, setIsLoading] = useState(false);"),
		Line("  const { register } = useAuth();"),
		Line("  const navigate = useNavigate();"),
		Blank(),
		Line("  const handleSubmit = async (e: React.FormEvent) => {"),
		Line("    e.preventDefault();"),
		Line("    setError('');"),
		Line("    setIsLoading(true);"),
		Line("    try {"),
		Line("      await register({ name, email, password });"),
		Line("      navigate('/');"),
		Line("    } catch (err) {"),
		Line("      setError('Registration failed');"),
		Line("    } finally {"),
		Line("      setIsLoading(false);"),
		Line("    }"),
		Line("  };"),
		Blank(),
		Line("  return ("),
		Line("    <div className=\"min-h-screen flex items-center justify-center bg-gray-100\">"),
		Line("      <div className=\"bg-white p-8 rounded-lg shadow-md w-full max-w-md\">"),
		Line("        <h1 className=\"text-2xl font-bold mb-6 text-center\">Register</h1>"),
		Line("        {error && ("),
		Line("          <div className=\"mb-4 p-3 bg-red-100 text-red-700 rounded\">{error}</div>"),
		Line("        )}"),
		Line("        <form onSubmit={handleSubmit} className=\"space-y-4\">"),
		Line("          <div>"),
		Line("            <label className=\"block text-sm font-medium text-gray-700\">Name</label>"),
		Line("            <input"),
		Line("              type=\"text\""),
		Line("              value={name}"),
		Line("              onChange={(e) => setName(e.target.value)}"),
		Line("              required"),
		Line("              className=\"mt-1 block w-full rounded border-gray-300 shadow-sm\""),
		Line("            />"),
		Line("          </div>"),
		Line("          <div>"),
		Line("            <label className=\"block text-sm font-medium text-gray-700\">Email</label>"),
		Line("            <input"),
		Line("              type=\"email\""),
		Line("              value={email}"),
		Line("              onChange={(e) => setEmail(e.target.value)}"),
		Line("              required"),
		Line("              className=\"mt-1 block w-full rounded border-gray-300 shadow-sm\""),
		Line("            />"),
		Line("          </div>"),
		Line("          <div>"),
		Line("            <label className=\"block text-sm font-medium text-gray-700\">Password</label>"),
		Line("            <input"),
		Line("              type=\"password\""),
		Line("              value={password}"),
		Line("              onChange={(e) => setPassword(e.target.value)}"),
		Line("              required"),
		Line("              minLength={8}"),
		Line("              className=\"mt-1 block w-full rounded border-gray-300 shadow-sm\""),
		Line("            />"),
		Line("          </div>"),
		Line("          <button"),
		Line("            type=\"submit\""),
		Line("            disabled={isLoading}"),
		Line("            className=\"w-full py-2 px-4 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50\""),
		Line("          >"),
		Line("            {isLoading ? 'Creating account...' : 'Register'}"),
		Line("          </button>"),
		Line("        </form>"),
		Line("        <p className=\"mt-4 text-center text-sm text-gray-600\">"),
		Line("          Already have an account? <a href=\"/login\" className=\"text-blue-600 hover:underline\">Login</a>"),
		Line("        </p>"),
		Line("      </div>"),
		Line("    </div>"),
		Line("  );"),
		Line("}"),
		Blank(),
	})
}

func generateProtectedRoute() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Protected Route wrapper"),
		Line("export function ProtectedRoute({ children, roles }: { children: ReactNode; roles?: string[] }) {"),
		Line("  const { isAuthenticated, isLoading, hasRole } = useAuth();"),
		Line("  const navigate = useNavigate();"),
		Blank(),
		Line("  useEffect(() => {"),
		Line("    if (!isLoading) {"),
		Line("      if (!isAuthenticated) {"),
		Line("        navigate('/login');"),
		Line("      } else if (roles && !hasRole(roles)) {"),
		Line("        navigate('/unauthorized');"),
		Line("      }"),
		Line("    }"),
		Line("  }, [isAuthenticated, isLoading, hasRole, navigate, roles]);"),
		Blank(),
		Line("  if (isLoading) {"),
		Line("    return <div className=\"p-8 text-center\">Loading...</div>;"),
		Line("  }"),
		Blank(),
		Line("  if (!isAuthenticated) {"),
		Line("    return null;"),
		Line("  }"),
		Blank(),
		Line("  if (roles && !hasRole(roles)) {"),
		Line("    return null;"),
		Line("  }"),
		Blank(),
		Line("  return <>{children}</>;"),
		Line("}"),
		Blank(),
		Line("// Unauthorized Page"),
		Line("export function UnauthorizedPage() {"),
		Line("  return ("),
		Line("    <div className=\"min-h-screen flex items-center justify-center bg-gray-100\">"),
		Line("      <div className=\"text-center\">"),
		Line("        <h1 className=\"text-4xl font-bold text-gray-900 mb-4\">403</h1>"),
		Line("        <p className=\"text-gray-600 mb-4\">You don't have permission to access this page.</p>"),
		Line("        <a href=\"/\" className=\"text-blue-600 hover:underline\">Go home</a>"),
		Line("      </div>"),
		Line("    </div>"),
		Line("  );"),
		Line("}"),
	})
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			pkgName := string(f.GoPackageName)

			// Generate Go auth middleware
			goFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_auth.pb.go", f.GoImportPath)
			goFile.P(GenerateGoAuth(pkgName).Run())

			// Generate React auth components
			tsFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_auth.tsx", f.GoImportPath)
			tsFile.P(GenerateReactAuth().Run())
		}
		return nil
	})
}

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			result = append(result, '_')
		}
		result = append(result, unicode.ToLower(r))
	}
	return string(result)
}
