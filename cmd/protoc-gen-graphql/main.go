// protoc-gen-graphql generates GraphQL schema and resolvers from protobuf
// Uses Category Theory: Monoid + Functor + Fold
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	pluginpb "google.golang.org/protobuf/types/pluginpb"
)

type Code struct{ Run func() string }

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }
func Concat(codes []Code) string {
	var sb strings.Builder
	for _, c := range codes {
		sb.WriteString(c.Run())
	}
	return sb.String()
}

// =============================================================================
// SCHEMA GENERATOR
// =============================================================================

func protoToGraphQL(kind protoreflect.Kind, repeated bool) string {
	var base string
	switch kind {
	case protoreflect.BoolKind:
		base = "Boolean"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
		protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		base = "Int"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
		protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		base = "String" // GraphQL doesn't have Int64
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		base = "Float"
	case protoreflect.StringKind:
		base = "String"
	case protoreflect.BytesKind:
		base = "String" // Base64 encoded
	default:
		base = "String"
	}
	if repeated {
		return "[" + base + "!]"
	}
	return base
}

func GenerateSchema(file *protogen.File) string {
	codes := []Code{
		Line("# Code generated by protoc-gen-graphql. DO NOT EDIT."),
		Line("# GraphQL Schema"),
		Blank(),
		Line("scalar DateTime"),
		Line("scalar JSON"),
		Blank(),
	}

	// Generate types for each message
	for _, msg := range file.Messages {
		codes = append(codes, generateType(msg))
	}

	// Generate Query type
	codes = append(codes, Line("type Query {"))
	for _, msg := range file.Messages {
		name := msg.GoIdent.GoName
		lower := strings.ToLower(name[:1]) + name[1:]
		codes = append(codes, Linef("  %s(id: ID!): %s", lower, name))
		codes = append(codes, Linef("  %ss(limit: Int, offset: Int, filter: %sFilter): [%s!]!", lower, name, name))
	}
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	// Generate Mutation type
	codes = append(codes, Line("type Mutation {"))
	for _, msg := range file.Messages {
		name := msg.GoIdent.GoName
		codes = append(codes, Linef("  create%s(input: %sInput!): %s!", name, name, name))
		codes = append(codes, Linef("  update%s(id: ID!, input: %sInput!): %s!", name, name, name))
		codes = append(codes, Linef("  delete%s(id: ID!): Boolean!", name))
	}
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	// Generate Subscription type
	codes = append(codes, Line("type Subscription {"))
	for _, msg := range file.Messages {
		name := msg.GoIdent.GoName
		lower := strings.ToLower(name[:1]) + name[1:]
		codes = append(codes, Linef("  %sCreated: %s!", lower, name))
		codes = append(codes, Linef("  %sUpdated(id: ID): %s!", lower, name))
		codes = append(codes, Linef("  %sDeleted: ID!", lower))
	}
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	// Generate Input types
	for _, msg := range file.Messages {
		codes = append(codes, generateInput(msg))
	}

	// Generate Filter types
	for _, msg := range file.Messages {
		codes = append(codes, generateFilter(msg))
	}

	return Concat(codes)
}

func generateType(msg *protogen.Message) Code {
	codes := []Code{Linef("type %s {", msg.GoIdent.GoName)}

	for _, field := range msg.Fields {
		fieldName := string(field.Desc.Name())

		var gqlType string
		if field.Message != nil {
			if strings.Contains(field.Message.GoIdent.GoName, "Timestamp") {
				gqlType = "DateTime"
			} else {
				gqlType = field.Message.GoIdent.GoName
				if field.Desc.IsList() {
					gqlType = "[" + gqlType + "!]"
				}
			}
		} else if field.Enum != nil {
			gqlType = field.Enum.GoIdent.GoName
		} else {
			gqlType = protoToGraphQL(field.Desc.Kind(), field.Desc.IsList())
		}

		// ID field special handling
		if fieldName == "id" {
			gqlType = "ID!"
		}

		codes = append(codes, Linef("  %s: %s", fieldName, gqlType))
	}

	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	return Code{Run: func() string { return Concat(codes) }}
}

func generateInput(msg *protogen.Message) Code {
	codes := []Code{Linef("input %sInput {", msg.GoIdent.GoName)}

	for _, field := range msg.Fields {
		fieldName := string(field.Desc.Name())
		if fieldName == "id" {
			continue // Skip ID in input
		}

		var gqlType string
		if field.Message != nil {
			if strings.Contains(field.Message.GoIdent.GoName, "Timestamp") {
				gqlType = "DateTime"
			} else {
				gqlType = field.Message.GoIdent.GoName + "Input"
				if field.Desc.IsList() {
					gqlType = "[" + gqlType + "!]"
				}
			}
		} else if field.Enum != nil {
			gqlType = field.Enum.GoIdent.GoName
		} else {
			gqlType = protoToGraphQL(field.Desc.Kind(), field.Desc.IsList())
		}

		codes = append(codes, Linef("  %s: %s", fieldName, gqlType))
	}

	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	return Code{Run: func() string { return Concat(codes) }}
}

func generateFilter(msg *protogen.Message) Code {
	codes := []Code{Linef("input %sFilter {", msg.GoIdent.GoName)}

	for _, field := range msg.Fields {
		fieldName := string(field.Desc.Name())
		kind := field.Desc.Kind()

		// String fields get text search
		if kind == protoreflect.StringKind {
			codes = append(codes, Linef("  %s: String", fieldName))
			codes = append(codes, Linef("  %s_contains: String", fieldName))
			codes = append(codes, Linef("  %s_starts_with: String", fieldName))
		}

		// Numeric fields get comparison
		if kind == protoreflect.Int32Kind || kind == protoreflect.Int64Kind ||
			kind == protoreflect.FloatKind || kind == protoreflect.DoubleKind {
			baseType := protoToGraphQL(kind, false)
			codes = append(codes, Linef("  %s: %s", fieldName, baseType))
			codes = append(codes, Linef("  %s_gt: %s", fieldName, baseType))
			codes = append(codes, Linef("  %s_gte: %s", fieldName, baseType))
			codes = append(codes, Linef("  %s_lt: %s", fieldName, baseType))
			codes = append(codes, Linef("  %s_lte: %s", fieldName, baseType))
		}

		// Bool fields
		if kind == protoreflect.BoolKind {
			codes = append(codes, Linef("  %s: Boolean", fieldName))
		}
	}

	codes = append(codes, Line("  AND: ["+msg.GoIdent.GoName+"Filter!]"))
	codes = append(codes, Line("  OR: ["+msg.GoIdent.GoName+"Filter!]"))
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	return Code{Run: func() string { return Concat(codes) }}
}

// =============================================================================
// GO RESOLVER GENERATOR
// =============================================================================

func GenerateResolvers(pkgName string, file *protogen.File) string {
	codes := []Code{
		Line("// Code generated by protoc-gen-graphql. DO NOT EDIT."),
		Linef("package %s", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"strings"`),
		Line(`	"time"`),
		Line(")"),
		Blank(),
		Line("// Resolver is the root resolver"),
		Line("type Resolver struct {"),
	}

	// Add repository fields
	for _, msg := range file.Messages {
		codes = append(codes, Linef("	%sRepo %sRepository", msg.GoIdent.GoName, msg.GoIdent.GoName))
	}
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	// Query resolver
	codes = append(codes, Line("type queryResolver struct{ *Resolver }"))
	codes = append(codes, Line("func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }"))
	codes = append(codes, Blank())

	// Mutation resolver
	codes = append(codes, Line("type mutationResolver struct{ *Resolver }"))
	codes = append(codes, Line("func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }"))
	codes = append(codes, Blank())

	// Subscription resolver
	codes = append(codes, Line("type subscriptionResolver struct{ *Resolver }"))
	codes = append(codes, Line("func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }"))
	codes = append(codes, Blank())

	// Generate resolvers for each message
	for _, msg := range file.Messages {
		codes = append(codes, generateMessageResolvers(msg))
	}

	// Generate interfaces
	codes = append(codes, generateInterfaces(file))

	return Concat(codes)
}

func generateMessageResolvers(msg *protogen.Message) Code {
	name := msg.GoIdent.GoName

	codes := []Code{
		Line("// " + name + " Query Resolvers"),
		Linef("func (r *queryResolver) %s(ctx context.Context, id string) (*%s, error) {", name, name),
		Linef("	return r.%sRepo.Get(ctx, id)", name),
		Line("}"),
		Blank(),
		Linef("func (r *queryResolver) %ss(ctx context.Context, limit *int, offset *int, filter *%sFilter) ([]*%s, error) {", name, name, name),
		Linef("	items, err := r.%sRepo.List(ctx)", name),
		Line("	if err != nil { return nil, err }"),
		Blank(),
		Line("	// Apply filter"),
		Line("	if filter != nil {"),
		Line("		items = apply" + name + "Filter(items, filter)"),
		Line("	}"),
		Blank(),
		Line("	// Apply pagination"),
		Line("	start := 0"),
		Line("	if offset != nil { start = *offset }"),
		Line("	end := len(items)"),
		Line("	if limit != nil && start+*limit < end { end = start + *limit }"),
		Line("	if start > len(items) { start = len(items) }"),
		Line("	if end > len(items) { end = len(items) }"),
		Blank(),
		Line("	return items[start:end], nil"),
		Line("}"),
		Blank(),

		Line("// " + name + " Mutation Resolvers"),
		Linef("func (r *mutationResolver) Create%s(ctx context.Context, input %sInput) (*%s, error) {", name, name, name),
		Linef("	entity := input.To%s()", name),
		Linef("	id, err := r.%sRepo.Create(ctx, entity)", name),
		Line("	if err != nil { return nil, err }"),
		Line("	entity.Id = id"),
		Line("	return entity, nil"),
		Line("}"),
		Blank(),
		Linef("func (r *mutationResolver) Update%s(ctx context.Context, id string, input %sInput) (*%s, error) {", name, name, name),
		Linef("	entity := input.To%s()", name),
		Line("	entity.Id = id"),
		Linef("	if err := r.%sRepo.Update(ctx, entity); err != nil { return nil, err }", name),
		Line("	return entity, nil"),
		Line("}"),
		Blank(),
		Linef("func (r *mutationResolver) Delete%s(ctx context.Context, id string) (bool, error) {", name),
		Linef("	if err := r.%sRepo.Delete(ctx, id); err != nil { return false, err }", name),
		Line("	return true, nil"),
		Line("}"),
		Blank(),

		Line("// " + name + " Subscription Resolvers"),
		Linef("func (r *subscriptionResolver) %sCreated(ctx context.Context) (<-chan *%s, error) {", name, name),
		Linef("	ch := make(chan *%s, 1)", name),
		Line("	// TODO: Implement with your pubsub system"),
		Line("	return ch, nil"),
		Line("}"),
		Blank(),
		Linef("func (r *subscriptionResolver) %sUpdated(ctx context.Context, id *string) (<-chan *%s, error) {", name, name),
		Linef("	ch := make(chan *%s, 1)", name),
		Line("	// TODO: Implement with your pubsub system"),
		Line("	return ch, nil"),
		Line("}"),
		Blank(),
		Linef("func (r *subscriptionResolver) %sDeleted(ctx context.Context) (<-chan string, error) {", name),
		Line("	ch := make(chan string, 1)"),
		Line("	// TODO: Implement with your pubsub system"),
		Line("	return ch, nil"),
		Line("}"),
		Blank(),

		// Input converter
		Linef("type %sInput struct {", name),
	}

	for _, field := range msg.Fields {
		if string(field.Desc.Name()) == "id" {
			continue
		}
		goType := getGoType(field)
		codes = append(codes, Linef("	%s %s", field.GoName, goType))
	}
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	codes = append(codes, Linef("func (i *%sInput) To%s() *%s {", name, name, name))
	codes = append(codes, Linef("	return &%s{", name))
	for _, field := range msg.Fields {
		if string(field.Desc.Name()) == "id" {
			continue
		}
		codes = append(codes, Linef("		%s: i.%s,", field.GoName, field.GoName))
	}
	codes = append(codes, Line("	}"))
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	// Filter type
	codes = append(codes, Linef("type %sFilter struct {", name))
	for _, field := range msg.Fields {
		kind := field.Desc.Kind()
		fieldName := field.GoName
		if kind == protoreflect.StringKind {
			codes = append(codes, Linef("	%s *string", fieldName))
			codes = append(codes, Linef("	%sContains *string", fieldName))
			codes = append(codes, Linef("	%sStartsWith *string", fieldName))
		} else if kind == protoreflect.Int32Kind || kind == protoreflect.Int64Kind {
			codes = append(codes, Linef("	%s *int", fieldName))
			codes = append(codes, Linef("	%sGt *int", fieldName))
			codes = append(codes, Linef("	%sGte *int", fieldName))
			codes = append(codes, Linef("	%sLt *int", fieldName))
			codes = append(codes, Linef("	%sLte *int", fieldName))
		} else if kind == protoreflect.BoolKind {
			codes = append(codes, Linef("	%s *bool", fieldName))
		}
	}
	codes = append(codes, Linef("	AND []*%sFilter", name))
	codes = append(codes, Linef("	OR  []*%sFilter", name))
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	// Filter function
	codes = append(codes, Linef("func apply%sFilter(items []*%s, f *%sFilter) []*%s {", name, name, name, name))
	codes = append(codes, Linef("	var result []*%s", name))
	codes = append(codes, Line("	for _, item := range items {"))
	codes = append(codes, Line("		if matches"+name+"(item, f) {"))
	codes = append(codes, Line("			result = append(result, item)"))
	codes = append(codes, Line("		}"))
	codes = append(codes, Line("	}"))
	codes = append(codes, Line("	return result"))
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	codes = append(codes, Linef("func matches%s(item *%s, f *%sFilter) bool {", name, name, name))
	for _, field := range msg.Fields {
		kind := field.Desc.Kind()
		fieldName := field.GoName
		if kind == protoreflect.StringKind {
			codes = append(codes, Linef("	if f.%s != nil && item.%s != *f.%s { return false }", fieldName, fieldName, fieldName))
			codes = append(codes, Linef("	if f.%sContains != nil && !strings.Contains(item.%s, *f.%sContains) { return false }", fieldName, fieldName, fieldName))
			codes = append(codes, Linef("	if f.%sStartsWith != nil && !strings.HasPrefix(item.%s, *f.%sStartsWith) { return false }", fieldName, fieldName, fieldName))
		}
	}
	codes = append(codes, Line("	// AND conditions"))
	codes = append(codes, Line("	for _, af := range f.AND {"))
	codes = append(codes, Line("		if !matches"+name+"(item, af) { return false }"))
	codes = append(codes, Line("	}"))
	codes = append(codes, Line("	// OR conditions"))
	codes = append(codes, Line("	if len(f.OR) > 0 {"))
	codes = append(codes, Line("		anyMatch := false"))
	codes = append(codes, Line("		for _, of := range f.OR {"))
	codes = append(codes, Line("			if matches"+name+"(item, of) { anyMatch = true; break }"))
	codes = append(codes, Line("		}"))
	codes = append(codes, Line("		if !anyMatch { return false }"))
	codes = append(codes, Line("	}"))
	codes = append(codes, Line("	return true"))
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	return Code{Run: func() string { return Concat(codes) }}
}

func getGoType(field *protogen.Field) string {
	if field.Message != nil {
		if strings.Contains(field.Message.GoIdent.GoName, "Timestamp") {
			return "*time.Time"
		}
		t := "*" + field.Message.GoIdent.GoName
		if field.Desc.IsList() {
			return "[]" + t
		}
		return t
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return "interface{}"
	}
}

func generateInterfaces(file *protogen.File) Code {
	codes := []Code{
		Line("// Resolver interfaces"),
		Line("type QueryResolver interface {"),
	}

	for _, msg := range file.Messages {
		name := msg.GoIdent.GoName
		codes = append(codes, Linef("	%s(ctx context.Context, id string) (*%s, error)", name, name))
		codes = append(codes, Linef("	%ss(ctx context.Context, limit *int, offset *int, filter *%sFilter) ([]*%s, error)", name, name, name))
	}
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	codes = append(codes, Line("type MutationResolver interface {"))
	for _, msg := range file.Messages {
		name := msg.GoIdent.GoName
		codes = append(codes, Linef("	Create%s(ctx context.Context, input %sInput) (*%s, error)", name, name, name))
		codes = append(codes, Linef("	Update%s(ctx context.Context, id string, input %sInput) (*%s, error)", name, name, name))
		codes = append(codes, Linef("	Delete%s(ctx context.Context, id string) (bool, error)", name))
	}
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	codes = append(codes, Line("type SubscriptionResolver interface {"))
	for _, msg := range file.Messages {
		name := msg.GoIdent.GoName
		codes = append(codes, Linef("	%sCreated(ctx context.Context) (<-chan *%s, error)", name, name))
		codes = append(codes, Linef("	%sUpdated(ctx context.Context, id *string) (<-chan *%s, error)", name, name))
		codes = append(codes, Linef("	%sDeleted(ctx context.Context) (<-chan string, error)", name))
	}
	codes = append(codes, Line("}"))
	codes = append(codes, Blank())

	return Code{Run: func() string { return Concat(codes) }}
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate || len(f.Messages) == 0 {
				continue
			}

			pkgName := string(f.GoPackageName)

			// Generate GraphQL schema
			schemaFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_graphql.graphql", "")
			schemaFile.P(GenerateSchema(f))

			// Generate Go resolvers
			resolverFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_graphql_resolvers.pb.go", f.GoImportPath)
			resolverFile.P(GenerateResolvers(pkgName, f))
		}
		return nil
	})
}
