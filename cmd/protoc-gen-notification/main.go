// protoc-gen-notification generates push notification services
// Detects NotificationPrefs message embedded in User entity
// Supports FCM (Firebase), APNS (Apple), Email, SMS
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

type Code struct{ Run func() string }

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }
func Concat(codes []Code) string {
	var sb strings.Builder
	for _, c := range codes {
		sb.WriteString(c.Run())
	}
	return sb.String()
}

type NotificationConfig struct {
	// NotificationPrefs message
	NotificationPrefsMsg string

	// Fields detected
	HasFCMToken        bool
	HasAPNSToken       bool
	HasEmail           bool
	HasPhone           bool
	HasPushEnabled     bool
	HasEmailEnabled    bool
	HasSMSEnabled      bool
	HasQuietHoursStart bool
	HasQuietHoursEnd   bool

	// Parent message
	ParentMsg        string
	ParentGoField    string
	ParentEmailField string
	ParentPhoneField string
}

func DetectNotificationPrefs(file *protogen.File) *NotificationConfig {
	var config NotificationConfig
	var prefsMsg *protogen.Message

	// Find NotificationPrefs message
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == "NotificationPrefs" {
			prefsMsg = msg
			config.NotificationPrefsMsg = msg.GoIdent.GoName
			break
		}
	}

	if prefsMsg == nil {
		return nil
	}

	// Analyze fields
	for _, f := range prefsMsg.Fields {
		switch string(f.Desc.Name()) {
		case "fcm_token":
			config.HasFCMToken = true
		case "apns_token":
			config.HasAPNSToken = true
		case "email":
			config.HasEmail = true
		case "phone":
			config.HasPhone = true
		case "push_enabled":
			config.HasPushEnabled = true
		case "email_enabled":
			config.HasEmailEnabled = true
		case "sms_enabled":
			config.HasSMSEnabled = true
		case "quiet_hours_start":
			config.HasQuietHoursStart = true
		case "quiet_hours_end":
			config.HasQuietHoursEnd = true
		}
	}

	// Find parent
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == "NotificationPrefs" {
			continue
		}
		for _, f := range msg.Fields {
			if f.Message != nil && f.Message.GoIdent.GoName == "NotificationPrefs" {
				config.ParentMsg = msg.GoIdent.GoName
				config.ParentGoField = f.GoName
				for _, pf := range msg.Fields {
					name := string(pf.Desc.Name())
					if name == "email" {
						config.ParentEmailField = pf.GoName
					}
					if name == "phone" {
						config.ParentPhoneField = pf.GoName
					}
				}
				return &config
			}
		}
	}

	return nil
}

func GenerateBackend(pkgName string, cfg *NotificationConfig) string {
	p := cfg.ParentMsg
	nf := cfg.ParentGoField

	return Concat([]Code{
		Line("// Code generated by protoc-gen-notification. DO NOT EDIT."),
		Linef("// Notification service for %s.%s", p, nf),
		Blank(),
		Linef("package %s", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"bytes"`),
		Line(`	"context"`),
		Line(`	"encoding/json"`),
		Line(`	"errors"`),
		Line(`	"fmt"`),
		Line(`	"net/http"`),
		Line(`	"sync"`),
		Line(`	"time"`),
		Line(")"),
		Blank(),

		// Errors
		Line("var ("),
		Line(`	ErrNotificationDisabled = errors.New("notifications disabled")`),
		Line(`	ErrQuietHours           = errors.New("quiet hours active")`),
		Line(`	ErrNoToken              = errors.New("no device token")`),
		Line(`	ErrSendFailed           = errors.New("send failed")`),
		Line(")"),
		Blank(),

		// Types
		Line("type NotificationType string"),
		Line("const ("),
		Line(`	NotificationTypePush  NotificationType = "push"`),
		Line(`	NotificationTypeEmail NotificationType = "email"`),
		Line(`	NotificationTypeSMS   NotificationType = "sms"`),
		Line(")"),
		Blank(),

		Line("type Notification struct {"),
		Line("	ID        string"),
		Line("	UserID    string"),
		Line("	Type      NotificationType"),
		Line("	Title     string"),
		Line("	Body      string"),
		Line("	Data      map[string]string"),
		Line("	ImageURL  string"),
		Line("	ActionURL string"),
		Line("	Priority  string // high, normal, low"),
		Line("	CreatedAt time.Time"),
		Line("	SentAt    *time.Time"),
		Line("	ReadAt    *time.Time"),
		Line("}"),
		Blank(),

		// Providers
		generateProviders(),

		// Service
		generateService(cfg, p, nf),

		// Templates
		generateTemplates(),
	})
}

func generateProviders() Code {
	return Code{Run: func() string {
		return `// Push Provider interface
type PushProvider interface {
	Send(ctx context.Context, token string, n *Notification) error
}

// FCM Provider (Firebase Cloud Messaging)
type FCMProvider struct {
	ServerKey string
	ProjectID string
}

func NewFCMProvider(serverKey, projectID string) *FCMProvider {
	return &FCMProvider{ServerKey: serverKey, ProjectID: projectID}
}

func (p *FCMProvider) Send(ctx context.Context, token string, n *Notification) error {
	payload := map[string]interface{}{
		"message": map[string]interface{}{
			"token": token,
			"notification": map[string]string{
				"title": n.Title,
				"body":  n.Body,
			},
			"data": n.Data,
		},
	}
	if n.ImageURL != "" {
		payload["message"].(map[string]interface{})["notification"].(map[string]string)["image"] = n.ImageURL
	}

	body, _ := json.Marshal(payload)
	url := fmt.Sprintf("https://fcm.googleapis.com/v1/projects/%s/messages:send", p.ProjectID)
	
	req, _ := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+p.ServerKey)
	req.Header.Set("Content-Type", "application/json")
	
	resp, err := http.DefaultClient.Do(req)
	if err != nil { return err }
	defer resp.Body.Close()
	
	if resp.StatusCode >= 400 { return ErrSendFailed }
	return nil
}

// APNS Provider (Apple Push Notification Service)
type APNSProvider struct {
	KeyID      string
	TeamID     string
	BundleID   string
	PrivateKey []byte
	Production bool
}

func NewAPNSProvider(keyID, teamID, bundleID string, privateKey []byte, production bool) *APNSProvider {
	return &APNSProvider{KeyID: keyID, TeamID: teamID, BundleID: bundleID, PrivateKey: privateKey, Production: production}
}

func (p *APNSProvider) Send(ctx context.Context, token string, n *Notification) error {
	payload := map[string]interface{}{
		"aps": map[string]interface{}{
			"alert": map[string]string{
				"title": n.Title,
				"body":  n.Body,
			},
			"sound": "default",
		},
	}
	for k, v := range n.Data {
		payload[k] = v
	}

	body, _ := json.Marshal(payload)
	
	host := "api.sandbox.push.apple.com"
	if p.Production { host = "api.push.apple.com" }
	url := fmt.Sprintf("https://%s/3/device/%s", host, token)
	
	req, _ := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	req.Header.Set("apns-topic", p.BundleID)
	req.Header.Set("apns-push-type", "alert")
	// Note: In production, use JWT auth with the private key
	
	resp, err := http.DefaultClient.Do(req)
	if err != nil { return err }
	defer resp.Body.Close()
	
	if resp.StatusCode >= 400 { return ErrSendFailed }
	return nil
}

// Email Provider interface
type EmailProvider interface {
	Send(ctx context.Context, to, subject, htmlBody, textBody string) error
}

// SMTP Email Provider
type SMTPEmailProvider struct {
	Host     string
	Port     int
	Username string
	Password string
	From     string
}

func (p *SMTPEmailProvider) Send(ctx context.Context, to, subject, htmlBody, textBody string) error {
	// Simplified - in production use net/smtp or a library
	fmt.Printf("[EMAIL] To: %s, Subject: %s\n", to, subject)
	return nil
}

// SMS Provider interface
type SMSProvider interface {
	Send(ctx context.Context, to, message string) error
}

// Twilio SMS Provider
type TwilioSMSProvider struct {
	AccountSID string
	AuthToken  string
	FromNumber string
}

func (p *TwilioSMSProvider) Send(ctx context.Context, to, message string) error {
	url := fmt.Sprintf("https://api.twilio.com/2010-04-01/Accounts/%s/Messages.json", p.AccountSID)
	
	data := fmt.Sprintf("To=%s&From=%s&Body=%s", to, p.FromNumber, message)
	req, _ := http.NewRequestWithContext(ctx, "POST", url, strings.NewReader(data))
	req.SetBasicAuth(p.AccountSID, p.AuthToken)
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	
	resp, err := http.DefaultClient.Do(req)
	if err != nil { return err }
	defer resp.Body.Close()
	
	if resp.StatusCode >= 400 { return ErrSendFailed }
	return nil
}

`
	}}
}

func generateService(cfg *NotificationConfig, p, nf string) Code {
	return Code{Run: func() string {
		return fmt.Sprintf(`// Notification Service
type NotificationService struct {
	repo         %sRepository
	fcm          PushProvider
	apns         PushProvider
	email        EmailProvider
	sms          SMSProvider
	templates    *TemplateEngine
	
	// In-memory notification store (replace with persistent storage)
	mu            sync.RWMutex
	notifications map[string][]*Notification
}

func NewNotificationService(repo %sRepository) *NotificationService {
	return &NotificationService{
		repo:          repo,
		templates:     NewTemplateEngine(),
		notifications: make(map[string][]*Notification),
	}
}

func (s *NotificationService) SetFCMProvider(p PushProvider)   { s.fcm = p }
func (s *NotificationService) SetAPNSProvider(p PushProvider)  { s.apns = p }
func (s *NotificationService) SetEmailProvider(p EmailProvider) { s.email = p }
func (s *NotificationService) SetSMSProvider(p SMSProvider)    { s.sms = p }

// Send notification to user
func (s *NotificationService) Send(ctx context.Context, n *Notification) error {
	user, err := s.repo.Get(ctx, n.UserID)
	if err != nil { return err }
	
	prefs := user.%s
	if prefs == nil { return ErrNotificationDisabled }
	
	// Check quiet hours
	if s.isQuietHours(prefs) { return ErrQuietHours }
	
	now := time.Now()
	n.CreatedAt = now
	
	var sendErr error
	
	switch n.Type {
	case NotificationTypePush:
		if prefs.PushEnabled {
			if prefs.FcmToken != "" && s.fcm != nil {
				sendErr = s.fcm.Send(ctx, prefs.FcmToken, n)
			} else if prefs.ApnsToken != "" && s.apns != nil {
				sendErr = s.apns.Send(ctx, prefs.ApnsToken, n)
			} else {
				sendErr = ErrNoToken
			}
		} else {
			sendErr = ErrNotificationDisabled
		}
		
	case NotificationTypeEmail:
		if prefs.EmailEnabled && s.email != nil {
			email := user.Email
			if prefs.Email != "" { email = prefs.Email }
			sendErr = s.email.Send(ctx, email, n.Title, n.Body, n.Body)
		} else {
			sendErr = ErrNotificationDisabled
		}
		
	case NotificationTypeSMS:
		if prefs.SmsEnabled && s.sms != nil {
			phone := ""
			if prefs.Phone != "" { phone = prefs.Phone }
			if phone != "" {
				sendErr = s.sms.Send(ctx, phone, n.Body)
			} else {
				sendErr = ErrNoToken
			}
		} else {
			sendErr = ErrNotificationDisabled
		}
	}
	
	if sendErr == nil {
		n.SentAt = &now
	}
	
	// Store notification
	s.mu.Lock()
	s.notifications[n.UserID] = append(s.notifications[n.UserID], n)
	s.mu.Unlock()
	
	return sendErr
}

// SendMulti sends to multiple users
func (s *NotificationService) SendMulti(ctx context.Context, userIDs []string, n *Notification) map[string]error {
	results := make(map[string]error)
	for _, uid := range userIDs {
		notification := *n
		notification.UserID = uid
		notification.ID = fmt.Sprintf("%%s-%%d", uid, time.Now().UnixNano())
		results[uid] = s.Send(ctx, &notification)
	}
	return results
}

// SendBroadcast sends to all users
func (s *NotificationService) SendBroadcast(ctx context.Context, n *Notification) (sent int, failed int) {
	users, err := s.repo.List(ctx)
	if err != nil { return 0, 0 }
	
	for _, user := range users {
		notification := *n
		notification.UserID = user.Id
		notification.ID = fmt.Sprintf("%%s-%%d", user.Id, time.Now().UnixNano())
		if s.Send(ctx, &notification) == nil {
			sent++
		} else {
			failed++
		}
	}
	return sent, failed
}

// SendTemplate sends using a template
func (s *NotificationService) SendTemplate(ctx context.Context, userID, templateID string, data map[string]interface{}) error {
	title, body, err := s.templates.Render(templateID, data)
	if err != nil { return err }
	
	return s.Send(ctx, &Notification{
		ID:     fmt.Sprintf("%%s-%%d", userID, time.Now().UnixNano()),
		UserID: userID,
		Type:   NotificationTypePush,
		Title:  title,
		Body:   body,
	})
}

// GetUserNotifications returns notifications for a user
func (s *NotificationService) GetUserNotifications(ctx context.Context, userID string, limit int) []*Notification {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	notifs := s.notifications[userID]
	if limit > 0 && len(notifs) > limit {
		return notifs[len(notifs)-limit:]
	}
	return notifs
}

// MarkAsRead marks notification as read
func (s *NotificationService) MarkAsRead(ctx context.Context, userID, notificationID string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	for _, n := range s.notifications[userID] {
		if n.ID == notificationID {
			now := time.Now()
			n.ReadAt = &now
			return nil
		}
	}
	return errors.New("notification not found")
}

// GetUnreadCount returns unread notification count
func (s *NotificationService) GetUnreadCount(ctx context.Context, userID string) int {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	count := 0
	for _, n := range s.notifications[userID] {
		if n.ReadAt == nil { count++ }
	}
	return count
}

// UpdateToken updates device token
func (s *NotificationService) UpdateFCMToken(ctx context.Context, userID, token string) error {
	user, err := s.repo.Get(ctx, userID)
	if err != nil { return err }
	
	if user.%s == nil { user.%s = &NotificationPrefs{} }
	user.%s.FcmToken = token
	
	return s.repo.Update(ctx, user)
}

func (s *NotificationService) UpdateAPNSToken(ctx context.Context, userID, token string) error {
	user, err := s.repo.Get(ctx, userID)
	if err != nil { return err }
	
	if user.%s == nil { user.%s = &NotificationPrefs{} }
	user.%s.ApnsToken = token
	
	return s.repo.Update(ctx, user)
}

// UpdatePreferences updates notification preferences
func (s *NotificationService) UpdatePreferences(ctx context.Context, userID string, prefs *NotificationPrefs) error {
	user, err := s.repo.Get(ctx, userID)
	if err != nil { return err }
	
	user.%s = prefs
	return s.repo.Update(ctx, user)
}

func (s *NotificationService) isQuietHours(prefs *NotificationPrefs) bool {
	if prefs.QuietHoursStart == "" || prefs.QuietHoursEnd == "" {
		return false
	}
	
	now := time.Now()
	hour := now.Hour()
	
	start, _ := time.Parse("15:04", prefs.QuietHoursStart)
	end, _ := time.Parse("15:04", prefs.QuietHoursEnd)
	
	startHour := start.Hour()
	endHour := end.Hour()
	
	if startHour < endHour {
		return hour >= startHour && hour < endHour
	}
	// Overnight quiet hours
	return hour >= startHour || hour < endHour
}

`, p, p, nf, nf, nf, nf, nf, nf, nf, nf, nf, nf)
	}}
}

func generateTemplates() Code {
	return Code{Run: func() string {
		return `// Template Engine
type NotificationTemplate struct {
	ID        string
	Title     string
	Body      string
	Type      NotificationType
}

type TemplateEngine struct {
	templates map[string]*NotificationTemplate
}

func NewTemplateEngine() *TemplateEngine {
	e := &TemplateEngine{templates: make(map[string]*NotificationTemplate)}
	
	// Default templates
	e.Register(&NotificationTemplate{
		ID:    "welcome",
		Title: "Welcome to {{.AppName}}!",
		Body:  "Hi {{.Name}}, thanks for joining us!",
		Type:  NotificationTypePush,
	})
	e.Register(&NotificationTemplate{
		ID:    "order_confirmed",
		Title: "Order Confirmed",
		Body:  "Your order #{{.OrderID}} has been confirmed.",
		Type:  NotificationTypePush,
	})
	e.Register(&NotificationTemplate{
		ID:    "password_reset",
		Title: "Password Reset",
		Body:  "Click here to reset your password: {{.ResetURL}}",
		Type:  NotificationTypeEmail,
	})
	
	return e
}

func (e *TemplateEngine) Register(t *NotificationTemplate) {
	e.templates[t.ID] = t
}

func (e *TemplateEngine) Render(templateID string, data map[string]interface{}) (title, body string, err error) {
	t, ok := e.templates[templateID]
	if !ok { return "", "", errors.New("template not found") }
	
	title = e.interpolate(t.Title, data)
	body = e.interpolate(t.Body, data)
	return title, body, nil
}

func (e *TemplateEngine) interpolate(s string, data map[string]interface{}) string {
	result := s
	for k, v := range data {
		result = strings.ReplaceAll(result, "{{."+k+"}}", fmt.Sprintf("%v", v))
	}
	return result
}
`
	}}
}

func generateFrontend() string {
	return `// notification.tsx
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';

interface Notification {
  id: string;
  type: 'push' | 'email' | 'sms';
  title: string;
  body: string;
  createdAt: string;
  readAt?: string;
}

interface NotificationPrefs {
  fcmToken?: string;
  apnsToken?: string;
  pushEnabled: boolean;
  emailEnabled: boolean;
  smsEnabled: boolean;
  quietHoursStart?: string;
  quietHoursEnd?: string;
}

interface NotificationContextType {
  notifications: Notification[];
  unreadCount: number;
  prefs: NotificationPrefs | null;
  markAsRead: (id: string) => Promise<void>;
  markAllAsRead: () => Promise<void>;
  updatePrefs: (prefs: Partial<NotificationPrefs>) => Promise<void>;
  requestPermission: () => Promise<boolean>;
  refresh: () => Promise<void>;
}

const NotificationContext = createContext<NotificationContextType | null>(null);

export function NotificationProvider({ children, client }: { children: React.ReactNode; client: any }) {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [prefs, setPrefs] = useState<NotificationPrefs | null>(null);

  const refresh = useCallback(async () => {
    try {
      const [notifs, p] = await Promise.all([
        client.getNotifications({}),
        client.getPreferences({})
      ]);
      setNotifications(notifs.notifications || []);
      setPrefs(p.prefs);
    } catch {}
  }, [client]);

  useEffect(() => { refresh(); }, [refresh]);

  const unreadCount = notifications.filter(n => !n.readAt).length;

  const markAsRead = useCallback(async (id: string) => {
    await client.markAsRead({ id });
    setNotifications(ns => ns.map(n => n.id === id ? { ...n, readAt: new Date().toISOString() } : n));
  }, [client]);

  const markAllAsRead = useCallback(async () => {
    await client.markAllAsRead({});
    setNotifications(ns => ns.map(n => ({ ...n, readAt: new Date().toISOString() })));
  }, [client]);

  const updatePrefs = useCallback(async (updates: Partial<NotificationPrefs>) => {
    const newPrefs = { ...prefs, ...updates } as NotificationPrefs;
    await client.updatePreferences({ prefs: newPrefs });
    setPrefs(newPrefs);
  }, [client, prefs]);

  const requestPermission = useCallback(async () => {
    if (!('Notification' in window)) return false;
    const permission = await Notification.requestPermission();
    if (permission === 'granted') {
      // Get FCM token and update
      // This requires Firebase setup
      return true;
    }
    return false;
  }, []);

  return (
    <NotificationContext.Provider value={{ notifications, unreadCount, prefs, markAsRead, markAllAsRead, updatePrefs, requestPermission, refresh }}>
      {children}
    </NotificationContext.Provider>
  );
}

export function useNotifications() {
  const ctx = useContext(NotificationContext);
  if (!ctx) throw new Error('useNotifications requires NotificationProvider');
  return ctx;
}

// Components
export function NotificationBell() {
  const { unreadCount } = useNotifications();
  const [open, setOpen] = useState(false);

  return (
    <div className="relative">
      <button onClick={() => setOpen(!open)} className="p-2 rounded-full hover:bg-gray-100">
        ðŸ””
        {unreadCount > 0 && (
          <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs w-5 h-5 rounded-full flex items-center justify-center">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </button>
      {open && <NotificationDropdown onClose={() => setOpen(false)} />}
    </div>
  );
}

function NotificationDropdown({ onClose }: { onClose: () => void }) {
  const { notifications, markAsRead, markAllAsRead } = useNotifications();

  return (
    <div className="absolute right-0 mt-2 w-80 bg-white rounded-lg shadow-lg border z-50">
      <div className="p-3 border-b flex justify-between items-center">
        <span className="font-medium">Notifications</span>
        <button onClick={markAllAsRead} className="text-sm text-blue-600">Mark all read</button>
      </div>
      <div className="max-h-96 overflow-y-auto">
        {notifications.length === 0 ? (
          <div className="p-4 text-center text-gray-500">No notifications</div>
        ) : (
          notifications.map(n => (
            <div key={n.id} onClick={() => markAsRead(n.id)}
              className={"p-3 border-b cursor-pointer hover:bg-gray-50 " + (!n.readAt ? "bg-blue-50" : "")}>
              <div className="font-medium">{n.title}</div>
              <div className="text-sm text-gray-600">{n.body}</div>
              <div className="text-xs text-gray-400 mt-1">{new Date(n.createdAt).toLocaleString()}</div>
            </div>
          ))
        )}
      </div>
    </div>
  );
}

export function NotificationPreferences() {
  const { prefs, updatePrefs, requestPermission } = useNotifications();
  
  if (!prefs) return <div className="animate-pulse h-48 bg-gray-100 rounded" />;

  return (
    <div className="space-y-4">
      <h3 className="font-medium text-lg">Notification Preferences</h3>
      
      <div className="space-y-3">
        <label className="flex items-center justify-between">
          <span>Push Notifications</span>
          <input type="checkbox" checked={prefs.pushEnabled} onChange={e => {
            if (e.target.checked) requestPermission();
            updatePrefs({ pushEnabled: e.target.checked });
          }} className="toggle" />
        </label>
        
        <label className="flex items-center justify-between">
          <span>Email Notifications</span>
          <input type="checkbox" checked={prefs.emailEnabled} onChange={e => updatePrefs({ emailEnabled: e.target.checked })} className="toggle" />
        </label>
        
        <label className="flex items-center justify-between">
          <span>SMS Notifications</span>
          <input type="checkbox" checked={prefs.smsEnabled} onChange={e => updatePrefs({ smsEnabled: e.target.checked })} className="toggle" />
        </label>
      </div>
      
      <div className="pt-4 border-t">
        <h4 className="font-medium mb-2">Quiet Hours</h4>
        <div className="flex gap-4">
          <label className="flex-1">
            <span className="text-sm text-gray-600">Start</span>
            <input type="time" value={prefs.quietHoursStart || ''} onChange={e => updatePrefs({ quietHoursStart: e.target.value })}
              className="w-full px-3 py-2 border rounded" />
          </label>
          <label className="flex-1">
            <span className="text-sm text-gray-600">End</span>
            <input type="time" value={prefs.quietHoursEnd || ''} onChange={e => updatePrefs({ quietHoursEnd: e.target.value })}
              className="w-full px-3 py-2 border rounded" />
          </label>
        </div>
      </div>
    </div>
  );
}
`
}

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			cfg := DetectNotificationPrefs(f)
			if cfg == nil {
				continue
			}

			pkgName := string(f.GoPackageName)

			// Go backend
			goFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_notification.pb.go", f.GoImportPath)
			goFile.P(GenerateBackend(pkgName, cfg))

			// React frontend
			basePath := strings.Replace(f.GeneratedFilenamePrefix, "/go/", "/ui/", 1)
			tsFile := gen.NewGeneratedFile(basePath+"_notification.tsx", "")
			tsFile.P(generateFrontend())
		}
		return nil
	})
}
