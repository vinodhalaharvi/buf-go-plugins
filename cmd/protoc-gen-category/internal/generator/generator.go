package generator

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// CombineStrategy mirrors the proto enum
type CombineStrategy int32

const (
	CombineInfer   CombineStrategy = 0
	CombineConcat  CombineStrategy = 1
	CombineSum     CombineStrategy = 2
	CombineProduct CombineStrategy = 3
	CombineAll     CombineStrategy = 4
	CombineAny     CombineStrategy = 5
	CombineFirst   CombineStrategy = 6
	CombineLast    CombineStrategy = 7
	CombineMerge   CombineStrategy = 8
)

// EffectKind mirrors the proto enum
type EffectKind int32

const (
	EffectNetwork  EffectKind = 0
	EffectDatabase EffectKind = 1
	EffectDisk     EffectKind = 2
)

func (e EffectKind) String() string {
	switch e {
	case EffectNetwork:
		return "Network"
	case EffectDatabase:
		return "DB"
	case EffectDisk:
		return "Disk"
	default:
		return "Unknown"
	}
}

func (e EffectKind) TypeName() string {
	return e.String() + "Op"
}

// MessageOptions holds parsed message options
type MessageOptions struct {
	Functor            bool
	Monoid             bool
	Semigroup          bool
	Foldable           bool
	Traversable        bool
	Monad              bool
	Bifunctor          bool
	Combine            CombineStrategy
	FirestoreBridge    bool
	Global             bool
	StripeCustomer     bool
	StripeSubscription bool
}

// ServiceOptions holds parsed service options
type ServiceOptions struct {
	Kleisli        bool
	Middleware     bool
	Parallel       bool
	Retry          bool
	CircuitBreaker bool
	Fanout         bool
	Mock           bool
	ConnectBridge  bool
	StripeBilling  bool
}

// MethodOptions holds parsed method options
type MethodOptions struct {
	Idempotent bool
	Fallback   string
	CacheKey   string
	MinPlan    string
	Metered    bool
	MeterEvent string
}

// FieldOptions holds parsed field options
type FieldOptions struct {
	Combine CombineStrategy
	Empty   string
}

// FileOptions holds parsed file options
type FileOptions struct {
	Effects []EffectKind
	Stripe  *StripeFileConfig
}

// StripeFileConfig holds file-level Stripe config
type StripeFileConfig struct {
	Plans            []string
	WebhookSecretEnv string
	ApiKeyEnv        string
}

// Generator handles code generation
type Generator struct {
	plugin *protogen.Plugin
}

// New creates a new Generator
func New(plugin *protogen.Plugin) *Generator {
	return &Generator{plugin: plugin}
}

// GenerateFile generates code for a single proto file
func (g *Generator) GenerateFile(f *protogen.File) error {
	fileOpts := g.parseFileOptions(f)

	// Check if any generation is needed
	hasWork := false
	needsConnect := false
	needsFirestore := false
	needsStripe := fileOpts.Stripe != nil
	for _, m := range f.Messages {
		if opts := g.parseMessageOptions(m); opts != nil {
			hasWork = true
			if opts.FirestoreBridge {
				needsFirestore = true
			}
			if opts.StripeCustomer || opts.StripeSubscription {
				needsStripe = true
			}
		}
	}
	for _, s := range f.Services {
		if opts := g.parseServiceOptions(s); opts != nil {
			hasWork = true
			if opts.ConnectBridge {
				needsConnect = true
			}
			if opts.StripeBilling {
				needsStripe = true
			}
		}
	}
	if !hasWork && len(fileOpts.Effects) == 0 && !needsStripe {
		return nil
	}

	filename := f.GeneratedFilenamePrefix + "_category.go"
	gf := g.plugin.NewGeneratedFile(filename, f.GoImportPath)

	// Header
	gf.P("// Code generated by protoc-gen-category. DO NOT EDIT.")
	gf.P()
	gf.P("package ", f.GoPackageName)
	gf.P()

	// Imports
	gf.P("import (")
	gf.P(`	"context"`)
	gf.P(`	"errors"`)
	if needsStripe {
		gf.P(`	"encoding/json"`)
		gf.P(`	"io"`)
		gf.P(`	"net/http"`)
		gf.P(`	"os"`)
	}
	gf.P(`	"sync"`)
	gf.P(`	"time"`)
	gf.P()
	gf.P(`	"golang.org/x/sync/errgroup"`)
	if needsConnect {
		gf.P(`	"connectrpc.com/connect"`)
	}
	if needsFirestore {
		gf.P(`	"cloud.google.com/go/firestore"`)
		gf.P(`	"google.golang.org/api/iterator"`)
	}
	if needsStripe {
		gf.P(`	"github.com/stripe/stripe-go/v76"`)
		gf.P(`	"github.com/stripe/stripe-go/v76/customer"`)
		gf.P(`	"github.com/stripe/stripe-go/v76/subscription"`)
		gf.P(`	"github.com/stripe/stripe-go/v76/webhook"`)
	}
	gf.P(")")
	gf.P()

	// Generate core types
	g.generateCoreTypes(gf)

	// Generate effect types
	for _, effect := range fileOpts.Effects {
		g.generateEffectType(gf, effect)
	}

	// Generate natural transformations between effects
	if len(fileOpts.Effects) > 1 {
		g.generateNaturalTransformations(gf, fileOpts.Effects)
	}

	// Generate Stripe core types if configured
	if fileOpts.Stripe != nil {
		g.generateStripeCore(gf, fileOpts.Stripe)
	}

	// Generate message-level code
	for _, m := range f.Messages {
		opts := g.parseMessageOptions(m)
		if opts == nil {
			continue
		}
		g.generateMessageCode(gf, m, opts, fileOpts.Effects)

		// Generate Stripe message operations
		if opts.StripeCustomer {
			g.generateStripeCustomerOps(gf, m, fileOpts.Stripe)
		}
		if opts.StripeSubscription {
			g.generateStripeSubscriptionOps(gf, m, fileOpts.Stripe)
		}
	}

	// Generate service-level code
	for _, s := range f.Services {
		opts := g.parseServiceOptions(s)
		if opts == nil {
			continue
		}
		g.generateServiceCode(gf, s, opts, fileOpts.Effects)

		// Generate Stripe billing interceptor
		if opts.StripeBilling && fileOpts.Stripe != nil {
			g.generateStripeBillingInterceptor(gf, s, fileOpts.Stripe)
		}
	}

	return nil
}

func (g *Generator) generateCoreTypes(gf *protogen.GeneratedFile) {
	gf.P("// --- Core Category Theory Types ---")
	gf.P()

	// Morphism
	gf.P("// Morphism represents a function from A to B")
	gf.P("type Morphism[A, B any] func(A) B")
	gf.P()

	// Identity
	gf.P("// Id returns the identity morphism")
	gf.P("func Id[A any]() Morphism[A, A] {")
	gf.P("	return func(a A) A { return a }")
	gf.P("}")
	gf.P()

	// Compose
	gf.P("// Compose composes two morphisms (g . f)")
	gf.P("func Compose[A, B, C any](g Morphism[B, C], f Morphism[A, B]) Morphism[A, C] {")
	gf.P("	return func(a A) C { return g(f(a)) }")
	gf.P("}")
	gf.P()

	// Semigroup
	gf.P("// Semigroup provides an associative binary operation")
	gf.P("type Semigroup[A any] struct {")
	gf.P("	Combine func(A, A) A")
	gf.P("}")
	gf.P()

	// Monoid
	gf.P("// Monoid extends Semigroup with an identity element")
	gf.P("type Monoid[A any] struct {")
	gf.P("	Semigroup[A]")
	gf.P("	Empty func() A")
	gf.P("}")
	gf.P()

	// Product
	gf.P("// Product represents a pair of values")
	gf.P("type Product[A, B any] struct {")
	gf.P("	Fst A")
	gf.P("	Snd B")
	gf.P("}")
	gf.P()

	// Coproduct / Either
	gf.P("// Either represents a sum type (coproduct)")
	gf.P("type Either[L, R any] struct {")
	gf.P("	Left  L")
	gf.P("	Right R")
	gf.P("	IsRight bool")
	gf.P("}")
	gf.P()

	// Result for error handling
	gf.P("// Result represents a computation that may fail")
	gf.P("type Result[E, A any] struct {")
	gf.P("	Value A")
	gf.P("	Err   E")
	gf.P("	IsOk  bool")
	gf.P("}")
	gf.P()

	// Bifunctor for Result
	gf.P("// BimapResult applies f to error and g to value")
	gf.P("func BimapResult[E1, E2, A, B any](f Morphism[E1, E2], g Morphism[A, B], r Result[E1, A]) Result[E2, B] {")
	gf.P("	if r.IsOk {")
	gf.P("		return Result[E2, B]{Value: g(r.Value), IsOk: true}")
	gf.P("	}")
	gf.P("	return Result[E2, B]{Err: f(r.Err), IsOk: false}")
	gf.P("}")
	gf.P()

	gf.P("// MapLeftResult transforms the error type")
	gf.P("func MapLeftResult[E1, E2, A any](f Morphism[E1, E2], r Result[E1, A]) Result[E2, A] {")
	gf.P("	return BimapResult(f, Id[A](), r)")
	gf.P("}")
	gf.P()

	gf.P("// MapRightResult transforms the value type")
	gf.P("func MapRightResult[E, A, B any](g Morphism[A, B], r Result[E, A]) Result[E, B] {")
	gf.P("	return BimapResult(Id[E](), g, r)")
	gf.P("}")
	gf.P()

	// Generic fold operations
	gf.P("// FoldLeft performs left fold over a slice")
	gf.P("func FoldLeft[A, B any](xs []A, z B, f func(B, A) B) B {")
	gf.P("	acc := z")
	gf.P("	for _, x := range xs {")
	gf.P("		acc = f(acc, x)")
	gf.P("	}")
	gf.P("	return acc")
	gf.P("}")
	gf.P()

	gf.P("// FoldRight performs right fold over a slice")
	gf.P("func FoldRight[A, B any](xs []A, z B, f func(A, B) B) B {")
	gf.P("	acc := z")
	gf.P("	for i := len(xs) - 1; i >= 0; i-- {")
	gf.P("		acc = f(xs[i], acc)")
	gf.P("	}")
	gf.P("	return acc")
	gf.P("}")
	gf.P()

	gf.P("// FoldMap maps and folds using a monoid")
	gf.P("func FoldMap[A, M any](xs []A, f Morphism[A, M], m Monoid[M]) M {")
	gf.P("	return FoldLeft(xs, m.Empty(), func(acc M, a A) M {")
	gf.P("		return m.Combine(acc, f(a))")
	gf.P("	})")
	gf.P("}")
	gf.P()

	// Generic FMap
	gf.P("// FMap applies a morphism to each element of a slice")
	gf.P("func FMap[A, B any](f Morphism[A, B], xs []A) []B {")
	gf.P("	result := make([]B, len(xs))")
	gf.P("	for i, x := range xs {")
	gf.P("		result[i] = f(x)")
	gf.P("	}")
	gf.P("	return result")
	gf.P("}")
	gf.P()

	// Utility functions
	gf.P("// --- Utility Functions ---")
	gf.P()
	gf.P("func lastNonZero[T comparable](a, b T) T {")
	gf.P("	var zero T")
	gf.P("	if b != zero {")
	gf.P("		return b")
	gf.P("	}")
	gf.P("	return a")
	gf.P("}")
	gf.P()

	gf.P("func firstNonZero[T comparable](a, b T) T {")
	gf.P("	var zero T")
	gf.P("	if a != zero {")
	gf.P("		return a")
	gf.P("	}")
	gf.P("	return b")
	gf.P("}")
	gf.P()

	// Tenant context helpers
	gf.P("// --- Multi-Tenancy Context Helpers ---")
	gf.P()
	gf.P("type tenantKey struct{}")
	gf.P()
	gf.P("// WithTenantID adds tenant ID to context")
	gf.P("func WithTenantID(ctx context.Context, tenantID string) context.Context {")
	gf.P("	return context.WithValue(ctx, tenantKey{}, tenantID)")
	gf.P("}")
	gf.P()
	gf.P("// TenantIDFromContext extracts tenant ID from context")
	gf.P("func TenantIDFromContext(ctx context.Context) (string, bool) {")
	gf.P("	id, ok := ctx.Value(tenantKey{}).(string)")
	gf.P("	return id, ok")
	gf.P("}")
	gf.P()
	gf.P("// MustTenantID extracts tenant ID or panics")
	gf.P("func MustTenantID(ctx context.Context) string {")
	gf.P("	id, ok := TenantIDFromContext(ctx)")
	gf.P("	if !ok {")
	gf.P("		panic(\"tenant ID not in context\")")
	gf.P("	}")
	gf.P("	return id")
	gf.P("}")
	gf.P()

	// Suppress unused import warnings
	gf.P("var (")
	gf.P("	_ = context.Background")
	gf.P("	_ = errors.New")
	gf.P("	_ = sync.Mutex{}")
	gf.P("	_ = time.Second")
	gf.P("	_ = errgroup.Group{}")
	gf.P(")")
	gf.P()
}

func (g *Generator) generateEffectType(gf *protogen.GeneratedFile, effect EffectKind) {
	name := effect.TypeName()

	gf.P("// --- ", name, " Effect Type ---")
	gf.P()

	// Effect type
	gf.P("// ", name, " represents a ", strings.ToLower(effect.String()), " operation")
	gf.P("type ", name, "[A any] func(ctx context.Context) (A, error)")
	gf.P()

	// Pure
	gf.P("// Pure", name, " lifts a pure value into the effect")
	gf.P("func Pure", name, "[A any](a A) ", name, "[A] {")
	gf.P("	return func(ctx context.Context) (A, error) { return a, nil }")
	gf.P("}")
	gf.P()

	// FMap
	gf.P("// FMap", name, " applies a morphism inside the effect")
	gf.P("func FMap", name, "[A, B any](f Morphism[A, B], fa ", name, "[A]) ", name, "[B] {")
	gf.P("	return func(ctx context.Context) (B, error) {")
	gf.P("		a, err := fa(ctx)")
	gf.P("		if err != nil {")
	gf.P("			var zero B")
	gf.P("			return zero, err")
	gf.P("		}")
	gf.P("		return f(a), nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Ap (Applicative)
	gf.P("// Ap", name, " applies a wrapped function to a wrapped value")
	gf.P("func Ap", name, "[A, B any](ff ", name, "[Morphism[A, B]], fa ", name, "[A]) ", name, "[B] {")
	gf.P("	return func(ctx context.Context) (B, error) {")
	gf.P("		f, err := ff(ctx)")
	gf.P("		if err != nil {")
	gf.P("			var zero B")
	gf.P("			return zero, err")
	gf.P("		}")
	gf.P("		a, err := fa(ctx)")
	gf.P("		if err != nil {")
	gf.P("			var zero B")
	gf.P("			return zero, err")
	gf.P("		}")
	gf.P("		return f(a), nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Lift2
	gf.P("// Lift2", name, " lifts a binary function into the effect")
	gf.P("func Lift2", name, "[A, B, C any](f func(A, B) C, fa ", name, "[A], fb ", name, "[B]) ", name, "[C] {")
	gf.P("	return func(ctx context.Context) (C, error) {")
	gf.P("		a, err := fa(ctx)")
	gf.P("		if err != nil {")
	gf.P("			var zero C")
	gf.P("			return zero, err")
	gf.P("		}")
	gf.P("		b, err := fb(ctx)")
	gf.P("		if err != nil {")
	gf.P("			var zero C")
	gf.P("			return zero, err")
	gf.P("		}")
	gf.P("		return f(a, b), nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Bind (Monad)
	gf.P("// Bind", name, " chains effectful computations")
	gf.P("func Bind", name, "[A, B any](fa ", name, "[A], f func(A) ", name, "[B]) ", name, "[B] {")
	gf.P("	return func(ctx context.Context) (B, error) {")
	gf.P("		a, err := fa(ctx)")
	gf.P("		if err != nil {")
	gf.P("			var zero B")
	gf.P("			return zero, err")
	gf.P("		}")
	gf.P("		return f(a)(ctx)")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Kleisli composition
	gf.P("// ComposeKleisli", name, " composes Kleisli arrows")
	gf.P("func ComposeKleisli", name, "[A, B, C any](f func(A) ", name, "[B], g func(B) ", name, "[C]) func(A) ", name, "[C] {")
	gf.P("	return func(a A) ", name, "[C] {")
	gf.P("		return Bind", name, "(f(a), g)")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Traverse
	gf.P("// Traverse", name, " applies an effectful function to each element")
	gf.P("func Traverse", name, "[A, B any](xs []A, f func(A) ", name, "[B]) ", name, "[[]B] {")
	gf.P("	return func(ctx context.Context) ([]B, error) {")
	gf.P("		results := make([]B, len(xs))")
	gf.P("		for i, x := range xs {")
	gf.P("			b, err := f(x)(ctx)")
	gf.P("			if err != nil {")
	gf.P("				return nil, err")
	gf.P("			}")
	gf.P("			results[i] = b")
	gf.P("		}")
	gf.P("		return results, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Sequence
	gf.P("// Sequence", name, " converts []Effect[A] to Effect[[]A]")
	gf.P("func Sequence", name, "[A any](xs []", name, "[A]) ", name, "[[]A] {")
	gf.P("	return Traverse", name, "(xs, func(op ", name, "[A]) ", name, "[A] { return op })")
	gf.P("}")
	gf.P()

	// Parallel traverse
	gf.P("// TraverseParallel", name, " applies an effectful function in parallel")
	gf.P("func TraverseParallel", name, "[A, B any](xs []A, f func(A) ", name, "[B]) ", name, "[[]B] {")
	gf.P("	return func(ctx context.Context) ([]B, error) {")
	gf.P("		results := make([]B, len(xs))")
	gf.P("		g, ctx := errgroup.WithContext(ctx)")
	gf.P("		for i, x := range xs {")
	gf.P("			i, x := i, x")
	gf.P("			g.Go(func() error {")
	gf.P("				b, err := f(x)(ctx)")
	gf.P("				if err != nil {")
	gf.P("					return err")
	gf.P("				}")
	gf.P("				results[i] = b")
	gf.P("				return nil")
	gf.P("			})")
	gf.P("		}")
	gf.P("		if err := g.Wait(); err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P("		return results, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Parallel sequence
	gf.P("// SequenceParallel", name, " runs effects in parallel")
	gf.P("func SequenceParallel", name, "[A any](xs []", name, "[A]) ", name, "[[]A] {")
	gf.P("	return TraverseParallel", name, "(xs, func(op ", name, "[A]) ", name, "[A] { return op })")
	gf.P("}")
	gf.P()

	// Retry
	gf.P("// Retry", name, " retries an effect with exponential backoff")
	gf.P("func Retry", name, "[A any](op ", name, "[A], maxAttempts int, baseDelay, maxDelay time.Duration) ", name, "[A] {")
	gf.P("	return func(ctx context.Context) (A, error) {")
	gf.P("		var lastErr error")
	gf.P("		delay := baseDelay")
	gf.P("		for attempt := 0; attempt < maxAttempts; attempt++ {")
	gf.P("			result, err := op(ctx)")
	gf.P("			if err == nil {")
	gf.P("				return result, nil")
	gf.P("			}")
	gf.P("			lastErr = err")
	gf.P("			select {")
	gf.P("			case <-ctx.Done():")
	gf.P("				var zero A")
	gf.P("				return zero, ctx.Err()")
	gf.P("			case <-time.After(delay):")
	gf.P("			}")
	gf.P("			delay = min(delay*2, maxDelay)")
	gf.P("		}")
	gf.P("		var zero A")
	gf.P("		return zero, lastErr")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Fallback
	gf.P("// Fallback", name, " tries primary, falls back to secondary on error")
	gf.P("func Fallback", name, "[A any](primary, fallback ", name, "[A]) ", name, "[A] {")
	gf.P("	return func(ctx context.Context) (A, error) {")
	gf.P("		result, err := primary(ctx)")
	gf.P("		if err == nil {")
	gf.P("			return result, nil")
	gf.P("		}")
	gf.P("		return fallback(ctx)")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Timeout
	gf.P("// Timeout", name, " adds a timeout to an effect")
	gf.P("func Timeout", name, "[A any](op ", name, "[A], d time.Duration) ", name, "[A] {")
	gf.P("	return func(ctx context.Context) (A, error) {")
	gf.P("		ctx, cancel := context.WithTimeout(ctx, d)")
	gf.P("		defer cancel()")
	gf.P("		return op(ctx)")
	gf.P("	}")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateNaturalTransformations(gf *protogen.GeneratedFile, effects []EffectKind) {
	gf.P("// --- Natural Transformations ---")
	gf.P()

	for i, from := range effects {
		for j, to := range effects {
			if i == j {
				continue
			}
			fromName := from.TypeName()
			toName := to.TypeName()
			gf.P("// Lift", fromName, "To", toName, " is a natural transformation")
			gf.P("func Lift", fromName, "To", toName, "[A any](fa ", fromName, "[A]) ", toName, "[A] {")
			gf.P("	return func(ctx context.Context) (A, error) {")
			gf.P("		return fa(ctx)")
			gf.P("	}")
			gf.P("}")
			gf.P()
		}
	}
}

func (g *Generator) generateMessageCode(gf *protogen.GeneratedFile, m *protogen.Message, opts *MessageOptions, effects []EffectKind) {
	typeName := m.GoIdent.GoName

	gf.P("// --- ", typeName, " ---")
	gf.P()

	// Semigroup
	if opts.Semigroup || opts.Monoid {
		g.generateSemigroup(gf, m, opts)
	}

	// Monoid
	if opts.Monoid {
		g.generateMonoid(gf, m, opts)
	}

	// Typed FMap for slices of this message
	if opts.Functor {
		gf.P("// FMap", typeName, " applies a morphism to each ", typeName, " in a slice")
		gf.P("func FMap", typeName, "[B any](f Morphism[*", typeName, ", B], xs []*", typeName, ") []B {")
		gf.P("	return FMap(f, xs)")
		gf.P("}")
		gf.P()
	}

	// Foldable
	if opts.Foldable {
		gf.P("// Fold", typeName, " folds over a slice of ", typeName, " using a monoid")
		gf.P("func Fold", typeName, "(xs []*", typeName, ", m Monoid[*", typeName, "]) *", typeName, " {")
		gf.P("	return FoldMap(xs, Id[*", typeName, "](), m)")
		gf.P("}")
		gf.P()

		gf.P("// FoldMap", typeName, " maps and folds over a slice of ", typeName)
		gf.P("func FoldMap", typeName, "[M any](xs []*", typeName, ", f Morphism[*", typeName, ", M], m Monoid[M]) M {")
		gf.P("	return FoldMap(xs, f, m)")
		gf.P("}")
		gf.P()
	}

	// Traversable for each effect
	if opts.Traversable {
		for _, effect := range effects {
			effectName := effect.TypeName()
			gf.P("// Traverse", typeName, effectName, " applies an effectful function to each ", typeName)
			gf.P("func Traverse", typeName, effectName, "[B any](xs []*", typeName, ", f func(*", typeName, ") ", effectName, "[B]) ", effectName, "[[]B] {")
			gf.P("	return Traverse", effectName, "(xs, f)")
			gf.P("}")
			gf.P()

			gf.P("// TraverseParallel", typeName, effectName, " applies an effectful function in parallel")
			gf.P("func TraverseParallel", typeName, effectName, "[B any](xs []*", typeName, ", f func(*", typeName, ") ", effectName, "[B]) ", effectName, "[[]B] {")
			gf.P("	return TraverseParallel", effectName, "(xs, f)")
			gf.P("}")
			gf.P()
		}
	}

	// Firestore bridge
	if opts.FirestoreBridge {
		g.generateFirestoreBridge(gf, m, opts)
	}
}

func (g *Generator) generateSemigroup(gf *protogen.GeneratedFile, m *protogen.Message, opts *MessageOptions) {
	typeName := m.GoIdent.GoName

	gf.P("// ", typeName, "Semigroup provides Combine for ", typeName)
	gf.P("var ", typeName, "Semigroup = Semigroup[*", typeName, "]{")
	gf.P("	Combine: func(a, b *", typeName, ") *", typeName, " {")
	gf.P("		if a == nil {")
	gf.P("			return b")
	gf.P("		}")
	gf.P("		if b == nil {")
	gf.P("			return a")
	gf.P("		}")
	gf.P("		return &", typeName, "{")

	for _, f := range m.Fields {
		fieldName := f.GoName
		fieldOpts := g.parseFieldOptions(f)
		strategy := g.inferCombineStrategy(f, opts, fieldOpts)
		combineExpr := g.getCombineExpr("a."+fieldName, "b."+fieldName, f, strategy)
		gf.P("			", fieldName, ": ", combineExpr, ",")
	}

	gf.P("		}")
	gf.P("	},")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateMonoid(gf *protogen.GeneratedFile, m *protogen.Message, opts *MessageOptions) {
	typeName := m.GoIdent.GoName

	gf.P("// ", typeName, "Monoid provides Empty and Combine for ", typeName)
	gf.P("var ", typeName, "Monoid = Monoid[*", typeName, "]{")
	gf.P("	Semigroup: ", typeName, "Semigroup,")
	gf.P("	Empty: func() *", typeName, " {")
	gf.P("		return &", typeName, "{}")
	gf.P("	},")
	gf.P("}")
	gf.P()
}

func (g *Generator) inferCombineStrategy(f *protogen.Field, msgOpts *MessageOptions, fieldOpts *FieldOptions) CombineStrategy {
	// Field-level override
	if fieldOpts != nil && fieldOpts.Combine != CombineInfer {
		return fieldOpts.Combine
	}

	// Message-level override
	if msgOpts.Combine != CombineInfer {
		return msgOpts.Combine
	}

	// Infer from type
	if f.Desc.IsList() {
		return CombineConcat
	}

	switch f.Desc.Kind() {
	case protoreflect.StringKind, protoreflect.BytesKind:
		return CombineConcat
	case protoreflect.Int32Kind, protoreflect.Int64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind,
		protoreflect.Sint32Kind, protoreflect.Sint64Kind,
		protoreflect.Fixed32Kind, protoreflect.Fixed64Kind,
		protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind,
		protoreflect.FloatKind, protoreflect.DoubleKind:
		return CombineSum
	case protoreflect.BoolKind:
		return CombineAll
	case protoreflect.MessageKind:
		return CombineMerge
	default:
		return CombineLast
	}
}

func (g *Generator) getCombineExpr(a, b string, f *protogen.Field, strategy CombineStrategy) string {
	if f.Desc.IsList() {
		return fmt.Sprintf("append(%s, %s...)", a, b)
	}

	switch strategy {
	case CombineConcat:
		return fmt.Sprintf("%s + %s", a, b)
	case CombineSum:
		return fmt.Sprintf("%s + %s", a, b)
	case CombineProduct:
		return fmt.Sprintf("%s * %s", a, b)
	case CombineAll:
		return fmt.Sprintf("%s && %s", a, b)
	case CombineAny:
		return fmt.Sprintf("%s || %s", a, b)
	case CombineFirst:
		return fmt.Sprintf("firstNonZero(%s, %s)", a, b)
	case CombineLast:
		return fmt.Sprintf("lastNonZero(%s, %s)", a, b)
	case CombineMerge:
		// For messages, just take b if non-nil (simplified)
		return fmt.Sprintf("lastNonZero(%s, %s)", a, b)
	default:
		return fmt.Sprintf("lastNonZero(%s, %s)", a, b)
	}
}

func (g *Generator) generateServiceCode(gf *protogen.GeneratedFile, s *protogen.Service, opts *ServiceOptions, effects []EffectKind) {
	serviceName := s.GoName

	gf.P("// --- ", serviceName, " ---")
	gf.P()

	// Default to Network effect for services
	effectName := "NetworkOp"
	if len(effects) > 0 {
		effectName = effects[0].TypeName()
	}

	// Kleisli service type
	if opts.Kleisli {
		gf.P("// ", serviceName, "K represents the service as Kleisli arrows")
		gf.P("type ", serviceName, "K struct {")
		for _, m := range s.Methods {
			methodOpts := g.parseMethodOptions(m)
			gf.P("	", m.GoName, " func(*", m.Input.GoIdent.GoName, ") ", effectName, "[*", m.Output.GoIdent.GoName, "]")
			_ = methodOpts // Used later for retry/fallback
		}
		gf.P("}")
		gf.P()

		// Compose functions (standalone, not methods - Go doesn't allow generic methods)
		for _, m := range s.Methods {
			inType := m.Input.GoIdent.GoName
			outType := m.Output.GoIdent.GoName

			gf.P("// ", serviceName, m.GoName, "AndThen chains ", m.GoName, " with another effectful function")
			gf.P("func ", serviceName, m.GoName, "AndThen[B any](s *", serviceName, "K, f func(*", outType, ") ", effectName, "[B]) func(*", inType, ") ", effectName, "[B] {")
			gf.P("	return ComposeKleisli", effectName, "(s.", m.GoName, ", f)")
			gf.P("}")
			gf.P()
		}
	}

	// Typed middleware
	if opts.Middleware {
		gf.P("// ", serviceName, "Middleware wraps service methods")
		gf.P("type ", serviceName, "Middleware struct {")
		for _, m := range s.Methods {
			inType := m.Input.GoIdent.GoName
			outType := m.Output.GoIdent.GoName
			gf.P("	", m.GoName, " func(func(*", inType, ") ", effectName, "[*", outType, "]) func(*", inType, ") ", effectName, "[*", outType, "]")
		}
		gf.P("}")
		gf.P()

		gf.P("// Apply", serviceName, "Middleware applies middleware to a service")
		gf.P("func Apply", serviceName, "Middleware(s *", serviceName, "K, mw *", serviceName, "Middleware) *", serviceName, "K {")
		gf.P("	result := &", serviceName, "K{}")
		for _, m := range s.Methods {
			gf.P("	if mw.", m.GoName, " != nil {")
			gf.P("		result.", m.GoName, " = mw.", m.GoName, "(s.", m.GoName, ")")
			gf.P("	} else {")
			gf.P("		result.", m.GoName, " = s.", m.GoName)
			gf.P("	}")
		}
		gf.P("	return result")
		gf.P("}")
		gf.P()
	}

	// Parallel execution helpers
	if opts.Parallel {
		for _, m := range s.Methods {
			inType := m.Input.GoIdent.GoName
			outType := m.Output.GoIdent.GoName

			gf.P("// Parallel", m.GoName, " executes multiple requests in parallel")
			gf.P("func (s *", serviceName, "K) Parallel", m.GoName, "(reqs []*", inType, ") ", effectName, "[[]*", outType, "] {")
			gf.P("	return TraverseParallel", effectName, "(reqs, s.", m.GoName, ")")
			gf.P("}")
			gf.P()
		}
	}

	// Fanout with monoid
	if opts.Fanout {
		for _, m := range s.Methods {
			inType := m.Input.GoIdent.GoName
			outType := m.Output.GoIdent.GoName

			gf.P("// Fanout", m.GoName, " calls multiple services and combines results")
			gf.P("func Fanout", m.GoName, "(services []*", serviceName, "K, combine Monoid[*", outType, "]) func(*", inType, ") ", effectName, "[*", outType, "] {")
			gf.P("	return func(req *", inType, ") ", effectName, "[*", outType, "] {")
			gf.P("		ops := make([]", effectName, "[*", outType, "], len(services))")
			gf.P("		for i, svc := range services {")
			gf.P("			ops[i] = svc.", m.GoName, "(req)")
			gf.P("		}")
			gf.P("		return FMap", effectName, "(")
			gf.P("			func(results []*", outType, ") *", outType, " {")
			gf.P("				return FoldMap(results, Id[*", outType, "](), combine)")
			gf.P("			},")
			gf.P("			SequenceParallel", effectName, "(ops),")
			gf.P("		)")
			gf.P("	}")
			gf.P("}")
			gf.P()
		}
	}

	// Circuit breaker
	if opts.CircuitBreaker {
		gf.P("// ", serviceName, "CircuitBreaker wraps the service with circuit breakers")
		gf.P("type ", serviceName, "CircuitBreaker struct {")
		gf.P("	service *", serviceName, "K")
		for _, m := range s.Methods {
			gf.P("	", lowerFirst(m.GoName), "CB *circuitBreaker")
		}
		gf.P("}")
		gf.P()

		gf.P("type circuitBreaker struct {")
		gf.P("	mu          sync.Mutex")
		gf.P("	failures    int")
		gf.P("	threshold   int")
		gf.P("	resetAfter  time.Duration")
		gf.P("	lastFailure time.Time")
		gf.P("	state       string")
		gf.P("}")
		gf.P()

		gf.P("func newCircuitBreaker(threshold int, resetAfter time.Duration) *circuitBreaker {")
		gf.P("	return &circuitBreaker{")
		gf.P("		threshold:  threshold,")
		gf.P("		resetAfter: resetAfter,")
		gf.P("		state:      \"closed\",")
		gf.P("	}")
		gf.P("}")
		gf.P()

		gf.P("// New", serviceName, "CircuitBreaker creates a circuit breaker wrapper")
		gf.P("func New", serviceName, "CircuitBreaker(s *", serviceName, "K, threshold int, resetAfter time.Duration) *", serviceName, "CircuitBreaker {")
		gf.P("	return &", serviceName, "CircuitBreaker{")
		gf.P("		service: s,")
		for _, m := range s.Methods {
			gf.P("		", lowerFirst(m.GoName), "CB: newCircuitBreaker(threshold, resetAfter),")
		}
		gf.P("	}")
		gf.P("}")
		gf.P()

		for _, m := range s.Methods {
			inType := m.Input.GoIdent.GoName
			outType := m.Output.GoIdent.GoName
			cbField := lowerFirst(m.GoName) + "CB"

			gf.P("// ", m.GoName, " calls the service with circuit breaker protection")
			gf.P("func (cb *", serviceName, "CircuitBreaker) ", m.GoName, "(req *", inType, ") ", effectName, "[*", outType, "] {")
			gf.P("	return func(ctx context.Context) (*", outType, ", error) {")
			gf.P("		cb.", cbField, ".mu.Lock()")
			gf.P("		if cb.", cbField, ".state == \"open\" {")
			gf.P("			if time.Since(cb.", cbField, ".lastFailure) > cb.", cbField, ".resetAfter {")
			gf.P("				cb.", cbField, ".state = \"half-open\"")
			gf.P("			} else {")
			gf.P("				cb.", cbField, ".mu.Unlock()")
			gf.P("				return nil, errors.New(\"circuit open\")")
			gf.P("			}")
			gf.P("		}")
			gf.P("		cb.", cbField, ".mu.Unlock()")
			gf.P()
			gf.P("		result, err := cb.service.", m.GoName, "(req)(ctx)")
			gf.P()
			gf.P("		cb.", cbField, ".mu.Lock()")
			gf.P("		defer cb.", cbField, ".mu.Unlock()")
			gf.P("		if err != nil {")
			gf.P("			cb.", cbField, ".failures++")
			gf.P("			cb.", cbField, ".lastFailure = time.Now()")
			gf.P("			if cb.", cbField, ".failures >= cb.", cbField, ".threshold {")
			gf.P("				cb.", cbField, ".state = \"open\"")
			gf.P("			}")
			gf.P("			return result, err")
			gf.P("		}")
			gf.P("		cb.", cbField, ".failures = 0")
			gf.P("		cb.", cbField, ".state = \"closed\"")
			gf.P("		return result, nil")
			gf.P("	}")
			gf.P("}")
			gf.P()
		}
	}

	// Mock implementation
	if opts.Mock {
		gf.P("// Mock", serviceName, "K creates a mock implementation")
		gf.P("type Mock", serviceName, "K struct {")
		for _, m := range s.Methods {
			inType := m.Input.GoIdent.GoName
			outType := m.Output.GoIdent.GoName
			gf.P("	", m.GoName, "Func func(*", inType, ") ", effectName, "[*", outType, "]")
			gf.P("	", m.GoName, "Calls []*", inType)
		}
		gf.P("}")
		gf.P()

		gf.P("// NewMock", serviceName, "K creates a new mock")
		gf.P("func NewMock", serviceName, "K() *Mock", serviceName, "K {")
		gf.P("	return &Mock", serviceName, "K{}")
		gf.P("}")
		gf.P()

		for _, m := range s.Methods {
			inType := m.Input.GoIdent.GoName
			outType := m.Output.GoIdent.GoName

			gf.P("// ", m.GoName, " records the call and delegates to the mock function")
			gf.P("func (m *Mock", serviceName, "K) ", m.GoName, "(req *", inType, ") ", effectName, "[*", outType, "] {")
			gf.P("	m.", m.GoName, "Calls = append(m.", m.GoName, "Calls, req)")
			gf.P("	if m.", m.GoName, "Func != nil {")
			gf.P("		return m.", m.GoName, "Func(req)")
			gf.P("	}")
			gf.P("	return Pure", effectName, "[*", outType, "](nil)")
			gf.P("}")
			gf.P()
		}

		gf.P("// ToKleisli converts mock to Kleisli service")
		gf.P("func (m *Mock", serviceName, "K) ToKleisli() *", serviceName, "K {")
		gf.P("	return &", serviceName, "K{")
		for _, m := range s.Methods {
			gf.P("		", m.GoName, ": m.", m.GoName, ",")
		}
		gf.P("	}")
		gf.P("}")
		gf.P()
	}

	// Connect bridge
	if opts.ConnectBridge {
		g.generateConnectBridge(gf, s, effectName)
	}
}

func (g *Generator) generateConnectBridge(gf *protogen.GeneratedFile, s *protogen.Service, effectName string) {
	serviceName := s.GoName
	// Infer connect package path from proto package
	connectPkg := fmt.Sprintf("%sconnect", strings.ToLower(serviceName))

	gf.P("// --- ", serviceName, " Connect Bridge ---")
	gf.P()
	gf.P("// Connect bridge requires: connectrpc.com/connect")
	gf.P("// Import the generated connect package for your service")
	gf.P()

	// Client interface that mirrors what connect-go generates
	gf.P("// ", serviceName, "ConnectClient interface mirrors connect-go generated client")
	gf.P("type ", serviceName, "ConnectClient interface {")
	for _, m := range s.Methods {
		inType := m.Input.GoIdent.GoName
		outType := m.Output.GoIdent.GoName
		gf.P("	", m.GoName, "(context.Context, *connect.Request[", inType, "]) (*connect.Response[", outType, "], error)")
	}
	gf.P("}")
	gf.P()

	// Client adapter: Connect -> Kleisli
	gf.P("// New", serviceName, "KFromConnect wraps a Connect client as Kleisli arrows")
	gf.P("func New", serviceName, "KFromConnect(client ", serviceName, "ConnectClient) *", serviceName, "K {")
	gf.P("	return &", serviceName, "K{")
	for _, m := range s.Methods {
		inType := m.Input.GoIdent.GoName
		outType := m.Output.GoIdent.GoName
		gf.P("		", m.GoName, ": func(req *", inType, ") ", effectName, "[*", outType, "] {")
		gf.P("			return func(ctx context.Context) (*", outType, ", error) {")
		gf.P("				resp, err := client.", m.GoName, "(ctx, connect.NewRequest(req))")
		gf.P("				if err != nil {")
		gf.P("					return nil, err")
		gf.P("				}")
		gf.P("				return resp.Msg, nil")
		gf.P("			}")
		gf.P("		},")
	}
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Handler adapter: Kleisli -> Connect
	gf.P("// ", serviceName, "ConnectHandler implements Connect handler using Kleisli service")
	gf.P("type ", serviceName, "ConnectHandler struct {")
	gf.P("	svc *", serviceName, "K")
	gf.P("}")
	gf.P()

	gf.P("// New", serviceName, "ConnectHandler creates a Connect handler from Kleisli service")
	gf.P("func New", serviceName, "ConnectHandler(svc *", serviceName, "K) *", serviceName, "ConnectHandler {")
	gf.P("	return &", serviceName, "ConnectHandler{svc: svc}")
	gf.P("}")
	gf.P()

	for _, m := range s.Methods {
		inType := m.Input.GoIdent.GoName
		outType := m.Output.GoIdent.GoName

		gf.P("// ", m.GoName, " implements ", connectPkg, ".", serviceName, "Handler")
		gf.P("func (h *", serviceName, "ConnectHandler) ", m.GoName, "(")
		gf.P("	ctx context.Context,")
		gf.P("	req *connect.Request[", inType, "],")
		gf.P(") (*connect.Response[", outType, "], error) {")
		gf.P("	result, err := h.svc.", m.GoName, "(req.Msg)(ctx)")
		gf.P("	if err != nil {")
		gf.P("		return nil, err")
		gf.P("	}")
		gf.P("	return connect.NewResponse(result), nil")
		gf.P("}")
		gf.P()
	}

	// Convenience: wrap with standard resilience patterns
	gf.P("// New", serviceName, "KFromConnectWithDefaults wraps Connect client with retry and timeout")
	gf.P("func New", serviceName, "KFromConnectWithDefaults(")
	gf.P("	client ", serviceName, "ConnectClient,")
	gf.P("	timeout time.Duration,")
	gf.P("	maxRetries int,")
	gf.P(") *", serviceName, "K {")
	gf.P("	base := New", serviceName, "KFromConnect(client)")
	gf.P("	return &", serviceName, "K{")

	effectBase := effectName // Use full name for helper functions
	for _, m := range s.Methods {
		inType := m.Input.GoIdent.GoName
		outType := m.Output.GoIdent.GoName
		methodOpts := g.parseMethodOptions(m)

		// Check if method is idempotent (safe to retry)
		if methodOpts != nil && methodOpts.Idempotent {
			gf.P("		", m.GoName, ": func(req *", inType, ") ", effectName, "[*", outType, "] {")
			gf.P("			return Timeout", effectBase, "(")
			gf.P("				Retry", effectBase, "(base.", m.GoName, "(req), maxRetries, 100*time.Millisecond, 2*time.Second),")
			gf.P("				timeout,")
			gf.P("			)")
			gf.P("		},")
		} else {
			// Non-idempotent: timeout only, no retry
			gf.P("		", m.GoName, ": func(req *", inType, ") ", effectName, "[*", outType, "] {")
			gf.P("			return Timeout", effectBase, "(base.", m.GoName, "(req), timeout)")
			gf.P("		},")
		}
	}

	gf.P("	}")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateFirestoreBridge(gf *protogen.GeneratedFile, m *protogen.Message, opts *MessageOptions) {
	typeName := m.GoIdent.GoName
	collectionName := toSnakeCase(typeName) + "s" // Simple pluralization
	isGlobal := opts.Global

	gf.P("// --- ", typeName, " Firestore Bridge ---")
	gf.P()

	// Collection type
	gf.P("// ", typeName, "Collection provides Firestore operations for ", typeName)
	gf.P("type ", typeName, "Collection struct {")
	gf.P("	client *firestore.Client")
	gf.P("	path   string")
	gf.P("	global bool")
	gf.P("}")
	gf.P()

	// Constructor
	gf.P("// New", typeName, "Collection creates a new collection accessor")
	if isGlobal {
		gf.P("func New", typeName, "Collection(client *firestore.Client) *", typeName, "Collection {")
		gf.P("	return &", typeName, "Collection{client: client, path: \"", collectionName, "\", global: true}")
		gf.P("}")
	} else {
		gf.P("func New", typeName, "Collection(client *firestore.Client) *", typeName, "Collection {")
		gf.P("	return &", typeName, "Collection{client: client, path: \"", collectionName, "\", global: false}")
		gf.P("}")
	}
	gf.P()

	// WithPath for custom collection paths
	gf.P("// New", typeName, "CollectionWithPath creates a collection accessor with custom path")
	if isGlobal {
		gf.P("func New", typeName, "CollectionWithPath(client *firestore.Client, path string) *", typeName, "Collection {")
		gf.P("	return &", typeName, "Collection{client: client, path: path, global: true}")
		gf.P("}")
	} else {
		gf.P("func New", typeName, "CollectionWithPath(client *firestore.Client, path string) *", typeName, "Collection {")
		gf.P("	return &", typeName, "Collection{client: client, path: path, global: false}")
		gf.P("}")
	}
	gf.P()

	// resolveCollectionRef helper - tenant-aware
	gf.P("// resolveCollectionRef resolves the collection path, scoping to tenant if present")
	gf.P("func (c *", typeName, "Collection) resolveCollectionRef(ctx context.Context) *firestore.CollectionRef {")
	gf.P("	if c.global {")
	gf.P("		return c.client.Collection(c.path)")
	gf.P("	}")
	gf.P("	if tenantID, ok := TenantIDFromContext(ctx); ok {")
	gf.P("		return c.client.Collection(\"tenants\").Doc(tenantID).Collection(c.path)")
	gf.P("	}")
	gf.P("	return c.client.Collection(c.path)")
	gf.P("}")
	gf.P()

	// Doc accessor
	gf.P("// Doc returns a document reference")
	gf.P("func (c *", typeName, "Collection) Doc(id string) *", typeName, "Doc {")
	gf.P("	return &", typeName, "Doc{")
	gf.P("		id:   id,")
	gf.P("		coll: c,")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Collection ref accessor (context-aware)
	gf.P("// Ref returns the underlying Firestore collection reference (requires context for tenant scoping)")
	gf.P("func (c *", typeName, "Collection) Ref(ctx context.Context) *firestore.CollectionRef {")
	gf.P("	return c.resolveCollectionRef(ctx)")
	gf.P("}")
	gf.P()

	// Document type
	gf.P("// ", typeName, "Doc provides document operations")
	gf.P("type ", typeName, "Doc struct {")
	gf.P("	id   string")
	gf.P("	coll *", typeName, "Collection")
	gf.P("}")
	gf.P()

	// resolveDocRef helper
	gf.P("// resolveDocRef resolves the document path, scoping to tenant if present")
	gf.P("func (d *", typeName, "Doc) resolveDocRef(ctx context.Context) *firestore.DocumentRef {")
	gf.P("	return d.coll.resolveCollectionRef(ctx).Doc(d.id)")
	gf.P("}")
	gf.P()

	// Ref accessor (context-aware)
	gf.P("// Ref returns the underlying Firestore document reference (requires context for tenant scoping)")
	gf.P("func (d *", typeName, "Doc) Ref(ctx context.Context) *firestore.DocumentRef {")
	gf.P("	return d.resolveDocRef(ctx)")
	gf.P("}")
	gf.P()

	// Get as DBOp
	gf.P("// Get retrieves the document as a DBOp")
	gf.P("func (d *", typeName, "Doc) Get() DBOp[*", typeName, "] {")
	gf.P("	return func(ctx context.Context) (*", typeName, ", error) {")
	gf.P("		snap, err := d.resolveDocRef(ctx).Get(ctx)")
	gf.P("		if err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P("		var result ", typeName)
	gf.P("		if err := snap.DataTo(&result); err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P("		return &result, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Exists check
	gf.P("// Exists checks if the document exists")
	gf.P("func (d *", typeName, "Doc) Exists() DBOp[bool] {")
	gf.P("	return func(ctx context.Context) (bool, error) {")
	gf.P("		snap, err := d.resolveDocRef(ctx).Get(ctx)")
	gf.P("		if err != nil {")
	gf.P("			return false, err")
	gf.P("		}")
	gf.P("		return snap.Exists(), nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Set (overwrite)
	gf.P("// Set creates or overwrites the document")
	gf.P("func (d *", typeName, "Doc) Set(data *", typeName, ") DBOp[bool] {")
	gf.P("	return func(ctx context.Context) (bool, error) {")
	gf.P("		_, err := d.resolveDocRef(ctx).Set(ctx, data)")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// SetMerge
	gf.P("// SetMerge merges data into the document")
	gf.P("func (d *", typeName, "Doc) SetMerge(data *", typeName, ") DBOp[bool] {")
	gf.P("	return func(ctx context.Context) (bool, error) {")
	gf.P("		_, err := d.resolveDocRef(ctx).Set(ctx, data, firestore.MergeAll)")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Create (fails if exists)
	gf.P("// Create creates the document (fails if it already exists)")
	gf.P("func (d *", typeName, "Doc) Create(data *", typeName, ") DBOp[bool] {")
	gf.P("	return func(ctx context.Context) (bool, error) {")
	gf.P("		_, err := d.resolveDocRef(ctx).Create(ctx, data)")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Update
	gf.P("// Update updates specific fields")
	gf.P("func (d *", typeName, "Doc) Update(updates []firestore.Update) DBOp[bool] {")
	gf.P("	return func(ctx context.Context) (bool, error) {")
	gf.P("		_, err := d.resolveDocRef(ctx).Update(ctx, updates)")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Delete
	gf.P("// Delete removes the document")
	gf.P("func (d *", typeName, "Doc) Delete() DBOp[bool] {")
	gf.P("	return func(ctx context.Context) (bool, error) {")
	gf.P("		_, err := d.resolveDocRef(ctx).Delete(ctx)")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// --- Transaction Operations ---
	gf.P("// --- ", typeName, " Transaction Operations ---")
	gf.P()

	// Transaction type alias
	gf.P("// ", typeName, "Tx represents a transactional operation on ", typeName)
	gf.P("type ", typeName, "Tx[A any] func(ctx context.Context, tx *firestore.Transaction) (A, error)")
	gf.P()

	// Pure for transaction
	gf.P("// Pure", typeName, "Tx lifts a value into a transaction")
	gf.P("func Pure", typeName, "Tx[A any](a A) ", typeName, "Tx[A] {")
	gf.P("	return func(ctx context.Context, tx *firestore.Transaction) (A, error) {")
	gf.P("		return a, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Bind for transaction
	gf.P("// Bind", typeName, "Tx chains transactional operations")
	gf.P("func Bind", typeName, "Tx[A, B any](fa ", typeName, "Tx[A], f func(A) ", typeName, "Tx[B]) ", typeName, "Tx[B] {")
	gf.P("	return func(ctx context.Context, tx *firestore.Transaction) (B, error) {")
	gf.P("		a, err := fa(ctx, tx)")
	gf.P("		if err != nil {")
	gf.P("			var zero B")
	gf.P("			return zero, err")
	gf.P("		}")
	gf.P("		return f(a)(ctx, tx)")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// FMap for transaction
	gf.P("// FMap", typeName, "Tx applies a function inside a transaction")
	gf.P("func FMap", typeName, "Tx[A, B any](f func(A) B, fa ", typeName, "Tx[A]) ", typeName, "Tx[B] {")
	gf.P("	return func(ctx context.Context, tx *firestore.Transaction) (B, error) {")
	gf.P("		a, err := fa(ctx, tx)")
	gf.P("		if err != nil {")
	gf.P("			var zero B")
	gf.P("			return zero, err")
	gf.P("		}")
	gf.P("		return f(a), nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// GetTx
	gf.P("// GetTx retrieves the document in a transaction")
	gf.P("func (d *", typeName, "Doc) GetTx() ", typeName, "Tx[*", typeName, "] {")
	gf.P("	return func(ctx context.Context, tx *firestore.Transaction) (*", typeName, ", error) {")
	gf.P("		snap, err := tx.Get(d.resolveDocRef(ctx))")
	gf.P("		if err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P("		var result ", typeName)
	gf.P("		if err := snap.DataTo(&result); err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P("		return &result, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// SetTx
	gf.P("// SetTx sets the document in a transaction")
	gf.P("func (d *", typeName, "Doc) SetTx(data *", typeName, ") ", typeName, "Tx[bool] {")
	gf.P("	return func(ctx context.Context, tx *firestore.Transaction) (bool, error) {")
	gf.P("		err := tx.Set(d.resolveDocRef(ctx), data)")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// UpdateTx
	gf.P("// UpdateTx updates the document in a transaction")
	gf.P("func (d *", typeName, "Doc) UpdateTx(updates []firestore.Update) ", typeName, "Tx[bool] {")
	gf.P("	return func(ctx context.Context, tx *firestore.Transaction) (bool, error) {")
	gf.P("		err := tx.Update(d.resolveDocRef(ctx), updates)")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// DeleteTx
	gf.P("// DeleteTx deletes the document in a transaction")
	gf.P("func (d *", typeName, "Doc) DeleteTx() ", typeName, "Tx[bool] {")
	gf.P("	return func(ctx context.Context, tx *firestore.Transaction) (bool, error) {")
	gf.P("		err := tx.Delete(d.resolveDocRef(ctx))")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// RunTransaction
	gf.P("// Run", typeName, "Transaction executes a transaction and returns a DBOp")
	gf.P("func (c *", typeName, "Collection) RunTransaction(op ", typeName, "Tx[*", typeName, "]) DBOp[*", typeName, "] {")
	gf.P("	return func(ctx context.Context) (*", typeName, ", error) {")
	gf.P("		var result *", typeName)
	gf.P("		err := c.client.RunTransaction(ctx, func(ctx context.Context, tx *firestore.Transaction) error {")
	gf.P("			var txErr error")
	gf.P("			result, txErr = op(ctx, tx)")
	gf.P("			return txErr")
	gf.P("		})")
	gf.P("		return result, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Generic transaction runner
	gf.P("// Run", typeName, "TransactionT executes a transaction with any result type")
	gf.P("func Run", typeName, "TransactionT[A any](c *", typeName, "Collection, op ", typeName, "Tx[A]) DBOp[A] {")
	gf.P("	return func(ctx context.Context) (A, error) {")
	gf.P("		var result A")
	gf.P("		err := c.client.RunTransaction(ctx, func(ctx context.Context, tx *firestore.Transaction) error {")
	gf.P("			var txErr error")
	gf.P("			result, txErr = op(ctx, tx)")
	gf.P("			return txErr")
	gf.P("		})")
	gf.P("		return result, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// --- Query Operations ---
	gf.P("// --- ", typeName, " Query Operations ---")
	gf.P()

	// Query type
	gf.P("// ", typeName, "Query wraps a Firestore query")
	gf.P("type ", typeName, "Query struct {")
	gf.P("	query firestore.Query")
	gf.P("	coll  *", typeName, "Collection")
	gf.P("}")
	gf.P()

	// Where
	gf.P("// Where creates a filtered query")
	gf.P("func (c *", typeName, "Collection) Where(path, op string, value interface{}) *", typeName, "Query {")
	gf.P("	return &", typeName, "Query{")
	gf.P("		query: c.client.Collection(c.path).Where(path, op, value),")
	gf.P("		coll:  c,")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Chained Where
	gf.P("// Where adds another filter to the query")
	gf.P("func (q *", typeName, "Query) Where(path, op string, value interface{}) *", typeName, "Query {")
	gf.P("	return &", typeName, "Query{")
	gf.P("		query: q.query.Where(path, op, value),")
	gf.P("		coll:  q.coll,")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// OrderBy
	gf.P("// OrderBy orders results by a field")
	gf.P("func (q *", typeName, "Query) OrderBy(path string, dir firestore.Direction) *", typeName, "Query {")
	gf.P("	return &", typeName, "Query{")
	gf.P("		query: q.query.OrderBy(path, dir),")
	gf.P("		coll:  q.coll,")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Limit
	gf.P("// Limit limits the number of results")
	gf.P("func (q *", typeName, "Query) Limit(n int) *", typeName, "Query {")
	gf.P("	return &", typeName, "Query{")
	gf.P("		query: q.query.Limit(n),")
	gf.P("		coll:  q.coll,")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Offset
	gf.P("// Offset skips the first n results")
	gf.P("func (q *", typeName, "Query) Offset(n int) *", typeName, "Query {")
	gf.P("	return &", typeName, "Query{")
	gf.P("		query: q.query.Offset(n),")
	gf.P("		coll:  q.coll,")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// GetAll
	gf.P("// GetAll retrieves all matching documents")
	gf.P("func (q *", typeName, "Query) GetAll() DBOp[[]*", typeName, "] {")
	gf.P("	return func(ctx context.Context) ([]*", typeName, ", error) {")
	gf.P("		iter := q.query.Documents(ctx)")
	gf.P("		defer iter.Stop()")
	gf.P("		var results []*", typeName)
	gf.P("		for {")
	gf.P("			snap, err := iter.Next()")
	gf.P("			if err == iterator.Done {")
	gf.P("				break")
	gf.P("			}")
	gf.P("			if err != nil {")
	gf.P("				return nil, err")
	gf.P("			}")
	gf.P("			var item ", typeName)
	gf.P("			if err := snap.DataTo(&item); err != nil {")
	gf.P("				return nil, err")
	gf.P("			}")
	gf.P("			results = append(results, &item)")
	gf.P("		}")
	gf.P("		return results, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// First
	gf.P("// First retrieves the first matching document")
	gf.P("func (q *", typeName, "Query) First() DBOp[*", typeName, "] {")
	gf.P("	return func(ctx context.Context) (*", typeName, ", error) {")
	gf.P("		iter := q.query.Limit(1).Documents(ctx)")
	gf.P("		defer iter.Stop()")
	gf.P("		snap, err := iter.Next()")
	gf.P("		if err == iterator.Done {")
	gf.P("			return nil, nil")
	gf.P("		}")
	gf.P("		if err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P("		var item ", typeName)
	gf.P("		if err := snap.DataTo(&item); err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P("		return &item, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Count
	gf.P("// Count returns the number of matching documents")
	gf.P("func (q *", typeName, "Query) Count() DBOp[int64] {")
	gf.P("	return func(ctx context.Context) (int64, error) {")
	gf.P("		agg, err := q.query.NewAggregationQuery().WithCount(\"count\").Get(ctx)")
	gf.P("		if err != nil {")
	gf.P("			return 0, err")
	gf.P("		}")
	gf.P("		count, ok := agg[\"count\"]")
	gf.P("		if !ok {")
	gf.P("			return 0, nil")
	gf.P("		}")
	gf.P("		if v, ok := count.(*int64); ok {")
	gf.P("			return *v, nil")
	gf.P("		}")
	gf.P("		if v, ok := count.(int64); ok {")
	gf.P("			return v, nil")
	gf.P("		}")
	gf.P("		return 0, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// GetAll on collection (all docs)
	gf.P("// GetAll retrieves all documents in the collection")
	gf.P("func (c *", typeName, "Collection) GetAll() DBOp[[]*", typeName, "] {")
	gf.P("	return func(ctx context.Context) ([]*", typeName, ", error) {")
	gf.P("		iter := c.client.Collection(c.path).Documents(ctx)")
	gf.P("		defer iter.Stop()")
	gf.P("		var results []*", typeName)
	gf.P("		for {")
	gf.P("			snap, err := iter.Next()")
	gf.P("			if err == iterator.Done {")
	gf.P("				break")
	gf.P("			}")
	gf.P("			if err != nil {")
	gf.P("				return nil, err")
	gf.P("			}")
	gf.P("			var item ", typeName)
	gf.P("			if err := snap.DataTo(&item); err != nil {")
	gf.P("				return nil, err")
	gf.P("			}")
	gf.P("			results = append(results, &item)")
	gf.P("		}")
	gf.P("		return results, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// --- Batch Operations ---
	gf.P("// --- ", typeName, " Batch Operations ---")
	gf.P()

	// BatchSet
	gf.P("// BatchSet sets multiple documents in a batch")
	gf.P("func (c *", typeName, "Collection) BatchSet(items map[string]*", typeName, ") DBOp[bool] {")
	gf.P("	return func(ctx context.Context) (bool, error) {")
	gf.P("		batch := c.client.Batch()")
	gf.P("		for id, item := range items {")
	gf.P("			ref := c.client.Collection(c.path).Doc(id)")
	gf.P("			batch.Set(ref, item)")
	gf.P("		}")
	gf.P("		_, err := batch.Commit(ctx)")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// BatchDelete
	gf.P("// BatchDelete deletes multiple documents in a batch")
	gf.P("func (c *", typeName, "Collection) BatchDelete(ids []string) DBOp[bool] {")
	gf.P("	return func(ctx context.Context) (bool, error) {")
	gf.P("		batch := c.client.Batch()")
	gf.P("		for _, id := range ids {")
	gf.P("			ref := c.client.Collection(c.path).Doc(id)")
	gf.P("			batch.Delete(ref)")
	gf.P("		}")
	gf.P("		_, err := batch.Commit(ctx)")
	gf.P("		return err == nil, err")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// GetMultiple using Traverse
	gf.P("// GetMultiple retrieves multiple documents by ID")
	gf.P("func (c *", typeName, "Collection) GetMultiple(ids []string) DBOp[[]*", typeName, "] {")
	gf.P("	return TraverseDBOp(ids, func(id string) DBOp[*", typeName, "] {")
	gf.P("		return c.Doc(id).Get()")
	gf.P("	})")
	gf.P("}")
	gf.P()

	// GetMultipleParallel
	gf.P("// GetMultipleParallel retrieves multiple documents in parallel")
	gf.P("func (c *", typeName, "Collection) GetMultipleParallel(ids []string) DBOp[[]*", typeName, "] {")
	gf.P("	return TraverseParallelDBOp(ids, func(id string) DBOp[*", typeName, "] {")
	gf.P("		return c.Doc(id).Get()")
	gf.P("	})")
	gf.P("}")
	gf.P()

	// --- Subcollection Support ---
	gf.P("// --- ", typeName, " Subcollection Support ---")
	gf.P()

	gf.P("// Subcollection returns a collection nested under a document (requires context for tenant scoping)")
	gf.P("func (d *", typeName, "Doc) Subcollection(ctx context.Context, name string) *firestore.CollectionRef {")
	gf.P("	return d.resolveDocRef(ctx).Collection(name)")
	gf.P("}")
	gf.P()
}

// toSnakeCase converts CamelCase to snake_case
func toSnakeCase(s string) string {
	var result []byte
	for i, c := range s {
		if i > 0 && c >= 'A' && c <= 'Z' {
			result = append(result, '_')
		}
		if c >= 'A' && c <= 'Z' {
			result = append(result, byte(c+32))
		} else {
			result = append(result, byte(c))
		}
	}
	return string(result)
}

// Option parsing helpers

func (g *Generator) parseFileOptions(f *protogen.File) FileOptions {
	opts := FileOptions{}
	if f.Desc.Options() == nil {
		return opts
	}

	// Parse extension from raw bytes
	raw := f.Desc.Options().(proto.Message)
	data := parseExtension(raw, ExtFieldCategoryFile)
	fileOpts := parseCategoryFileOptions(data)
	if fileOpts == nil {
		return opts
	}

	for _, e := range fileOpts.Effects {
		opts.Effects = append(opts.Effects, EffectKind(e))
	}

	// Parse Stripe config
	if fileOpts.Stripe != nil {
		opts.Stripe = &StripeFileConfig{
			Plans:            fileOpts.Stripe.Plans,
			WebhookSecretEnv: fileOpts.Stripe.WebhookSecretEnv,
			ApiKeyEnv:        fileOpts.Stripe.ApiKeyEnv,
		}
		// Set defaults
		if opts.Stripe.WebhookSecretEnv == "" {
			opts.Stripe.WebhookSecretEnv = "STRIPE_WEBHOOK_SECRET"
		}
		if opts.Stripe.ApiKeyEnv == "" {
			opts.Stripe.ApiKeyEnv = "STRIPE_SECRET_KEY"
		}
	}

	return opts
}

func (g *Generator) parseMessageOptions(m *protogen.Message) *MessageOptions {
	if m.Desc.Options() == nil {
		return nil
	}

	raw := m.Desc.Options().(proto.Message)
	data := parseExtension(raw, ExtFieldCategory)
	msgOpts := parseCategoryMessageOptions(data)
	if msgOpts == nil {
		return nil
	}

	// Check if any option is set
	if !msgOpts.Functor && !msgOpts.Monoid && !msgOpts.Semigroup &&
		!msgOpts.Foldable && !msgOpts.Traversable && !msgOpts.Monad &&
		!msgOpts.Bifunctor && !msgOpts.FirestoreBridge &&
		!msgOpts.StripeCustomer && !msgOpts.StripeSubscription {
		return nil
	}

	return &MessageOptions{
		Functor:            msgOpts.Functor,
		Monoid:             msgOpts.Monoid,
		Semigroup:          msgOpts.Semigroup,
		Foldable:           msgOpts.Foldable,
		Traversable:        msgOpts.Traversable,
		Monad:              msgOpts.Monad,
		Bifunctor:          msgOpts.Bifunctor,
		Combine:            CombineStrategy(msgOpts.Combine),
		FirestoreBridge:    msgOpts.FirestoreBridge,
		Global:             msgOpts.Global,
		StripeCustomer:     msgOpts.StripeCustomer,
		StripeSubscription: msgOpts.StripeSubscription,
	}
}

func (g *Generator) parseServiceOptions(s *protogen.Service) *ServiceOptions {
	if s.Desc.Options() == nil {
		return nil
	}

	raw := s.Desc.Options().(proto.Message)
	data := parseExtension(raw, ExtFieldCategoryService)
	svcOpts := parseCategoryServiceOptions(data)
	if svcOpts == nil {
		return nil
	}

	// Check if any option is set
	if !svcOpts.Kleisli && !svcOpts.Middleware && !svcOpts.Parallel &&
		!svcOpts.Retry && !svcOpts.CircuitBreaker && !svcOpts.Fanout &&
		!svcOpts.Mock && !svcOpts.ConnectBridge && !svcOpts.StripeBilling {
		return nil
	}

	return &ServiceOptions{
		Kleisli:        svcOpts.Kleisli,
		Middleware:     svcOpts.Middleware,
		Parallel:       svcOpts.Parallel,
		Retry:          svcOpts.Retry,
		CircuitBreaker: svcOpts.CircuitBreaker,
		Fanout:         svcOpts.Fanout,
		Mock:           svcOpts.Mock,
		ConnectBridge:  svcOpts.ConnectBridge,
		StripeBilling:  svcOpts.StripeBilling,
	}
}

func (g *Generator) parseMethodOptions(m *protogen.Method) *MethodOptions {
	if m.Desc.Options() == nil {
		return nil
	}

	raw := m.Desc.Options().(proto.Message)
	data := parseExtension(raw, ExtFieldCategoryMethod)
	methodOpts := parseCategoryMethodOptions(data)
	if methodOpts == nil {
		return nil
	}

	return &MethodOptions{
		Idempotent: methodOpts.Idempotent,
		Fallback:   methodOpts.Fallback,
		CacheKey:   methodOpts.CacheKey,
		MinPlan:    methodOpts.MinPlan,
		Metered:    methodOpts.Metered,
		MeterEvent: methodOpts.MeterEvent,
	}
}

func (g *Generator) parseFieldOptions(f *protogen.Field) *FieldOptions {
	if f.Desc.Options() == nil {
		return nil
	}

	raw := f.Desc.Options().(proto.Message)
	data := parseExtension(raw, ExtFieldFieldCategory)
	fieldOpts := parseFieldCategoryOptions(data)
	if fieldOpts == nil {
		return nil
	}

	return &FieldOptions{
		Combine: CombineStrategy(fieldOpts.Combine),
		Empty:   fieldOpts.Empty,
	}
}

// --- Stripe Code Generation ---

func (g *Generator) generateStripeCore(gf *protogen.GeneratedFile, cfg *StripeFileConfig) {
	gf.P("// --- Stripe Core Types ---")
	gf.P()

	// Plan type
	gf.P("// Plan represents subscription plans")
	gf.P("type Plan string")
	gf.P()
	gf.P("const (")
	for _, plan := range cfg.Plans {
		gf.P("	Plan", strings.Title(plan), " Plan = \"", plan, "\"")
	}
	gf.P(")")
	gf.P()

	// Plan ordering for comparison
	gf.P("// planOrder defines plan hierarchy for comparison")
	gf.P("var planOrder = map[Plan]int{")
	for i, plan := range cfg.Plans {
		gf.P("	Plan", strings.Title(plan), ": ", i, ",")
	}
	gf.P("}")
	gf.P()

	// PlanAtLeast helper
	gf.P("// PlanAtLeast checks if plan meets minimum requirement")
	gf.P("func PlanAtLeast(current, minimum Plan) bool {")
	gf.P("	return planOrder[current] >= planOrder[minimum]")
	gf.P("}")
	gf.P()

	// PlanError
	gf.P("// PlanError indicates insufficient plan")
	gf.P("type PlanError struct {")
	gf.P("	Required Plan")
	gf.P("	Current  Plan")
	gf.P("}")
	gf.P()
	gf.P("func (e *PlanError) Error() string {")
	gf.P("	return \"requires plan \" + string(e.Required) + \", current: \" + string(e.Current)")
	gf.P("}")
	gf.P()

	// User context helpers
	gf.P("type userIDKey struct{}")
	gf.P()
	gf.P("// WithUserID adds user ID to context")
	gf.P("func WithUserID(ctx context.Context, userID string) context.Context {")
	gf.P("	return context.WithValue(ctx, userIDKey{}, userID)")
	gf.P("}")
	gf.P()
	gf.P("// UserIDFromContext extracts user ID from context")
	gf.P("func UserIDFromContext(ctx context.Context) (string, bool) {")
	gf.P("	id, ok := ctx.Value(userIDKey{}).(string)")
	gf.P("	return id, ok")
	gf.P("}")
	gf.P()
	gf.P("// MustUserID extracts user ID or panics")
	gf.P("func MustUserID(ctx context.Context) string {")
	gf.P("	id, ok := UserIDFromContext(ctx)")
	gf.P("	if !ok {")
	gf.P("		panic(\"user ID not in context\")")
	gf.P("	}")
	gf.P("	return id")
	gf.P("}")
	gf.P()

	// Stripe key initialization
	gf.P("// initStripe initializes Stripe API key from environment")
	gf.P("func initStripe() {")
	gf.P("	stripe.Key = os.Getenv(\"", cfg.ApiKeyEnv, "\")")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateStripeCustomerOps(gf *protogen.GeneratedFile, m *protogen.Message, cfg *StripeFileConfig) {
	typeName := m.GoIdent.GoName

	// Find stripe_customer_id field
	var customerIDField string
	var emailField string
	for _, f := range m.Fields {
		fieldName := f.GoName
		if strings.Contains(strings.ToLower(fieldName), "stripecustomerid") ||
			strings.Contains(strings.ToLower(fieldName), "stripe_customer_id") {
			customerIDField = fieldName
		}
		if strings.ToLower(fieldName) == "email" {
			emailField = fieldName
		}
	}

	if customerIDField == "" {
		customerIDField = "StripeCustomerId" // default
	}

	gf.P("// --- ", typeName, " Stripe Customer Operations ---")
	gf.P()

	// Ops struct
	gf.P("// ", typeName, "StripeOps provides Stripe customer operations for ", typeName)
	gf.P("type ", typeName, "StripeOps struct {")
	gf.P("	collection *", typeName, "Collection")
	gf.P("}")
	gf.P()

	// Constructor
	gf.P("// New", typeName, "StripeOps creates Stripe operations for ", typeName)
	gf.P("func New", typeName, "StripeOps(collection *", typeName, "Collection) *", typeName, "StripeOps {")
	gf.P("	initStripe()")
	gf.P("	return &", typeName, "StripeOps{collection: collection}")
	gf.P("}")
	gf.P()

	// CreateCustomer
	gf.P("// CreateCustomer creates a Stripe customer and links to ", typeName)
	gf.P("func (s *", typeName, "StripeOps) CreateCustomer(id string) NetworkOp[*", typeName, "] {")
	gf.P("	return BindNetwork(")
	gf.P("		LiftDBOpToNetworkOp(s.collection.Doc(id).Get()),")
	gf.P("		func(entity *", typeName, ") NetworkOp[*", typeName, "] {")
	gf.P("			return func(ctx context.Context) (*", typeName, ", error) {")
	gf.P("				params := &stripe.CustomerParams{")
	if emailField != "" {
		gf.P("					Email: stripe.String(entity.", emailField, "),")
	}
	gf.P("					Metadata: map[string]string{")
	gf.P("						\"id\": id,")
	gf.P("					},")
	gf.P("				}")
	gf.P("				cust, err := customer.New(params)")
	gf.P("				if err != nil {")
	gf.P("					return nil, err")
	gf.P("				}")
	gf.P("				entity.", customerIDField, " = cust.ID")
	gf.P("				if _, err := s.collection.Doc(id).Set(entity)(ctx); err != nil {")
	gf.P("					return nil, err")
	gf.P("				}")
	gf.P("				return entity, nil")
	gf.P("			}")
	gf.P("		},")
	gf.P("	)")
	gf.P("}")
	gf.P()

	// GetOrCreateCustomer
	gf.P("// GetOrCreateCustomer gets existing or creates new Stripe customer")
	gf.P("func (s *", typeName, "StripeOps) GetOrCreateCustomer(id string) NetworkOp[*", typeName, "] {")
	gf.P("	return BindNetwork(")
	gf.P("		LiftDBOpToNetworkOp(s.collection.Doc(id).Get()),")
	gf.P("		func(entity *", typeName, ") NetworkOp[*", typeName, "] {")
	gf.P("			if entity.", customerIDField, " != \"\" {")
	gf.P("				return PureNetwork(entity)")
	gf.P("			}")
	gf.P("			return s.CreateCustomer(id)")
	gf.P("		},")
	gf.P("	)")
	gf.P("}")
	gf.P()

	// GetStripeCustomer
	gf.P("// GetStripeCustomer retrieves the Stripe customer object")
	gf.P("func (s *", typeName, "StripeOps) GetStripeCustomer(id string) NetworkOp[*stripe.Customer] {")
	gf.P("	return BindNetwork(")
	gf.P("		LiftDBOpToNetworkOp(s.collection.Doc(id).Get()),")
	gf.P("		func(entity *", typeName, ") NetworkOp[*stripe.Customer] {")
	gf.P("			return func(ctx context.Context) (*stripe.Customer, error) {")
	gf.P("				if entity.", customerIDField, " == \"\" {")
	gf.P("					return nil, errors.New(\"no stripe customer ID\")")
	gf.P("				}")
	gf.P("				return customer.Get(entity.", customerIDField, ", nil)")
	gf.P("			}")
	gf.P("		},")
	gf.P("	)")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateStripeSubscriptionOps(gf *protogen.GeneratedFile, m *protogen.Message, cfg *StripeFileConfig) {
	typeName := m.GoIdent.GoName

	// Find relevant fields
	var subIDField, userIDField, planField, statusField string
	for _, f := range m.Fields {
		fieldName := f.GoName
		lower := strings.ToLower(fieldName)
		if strings.Contains(lower, "stripesubscriptionid") || strings.Contains(lower, "stripe_subscription_id") {
			subIDField = fieldName
		}
		if lower == "userid" || lower == "user_id" {
			userIDField = fieldName
		}
		if lower == "plan" {
			planField = fieldName
		}
		if lower == "status" {
			statusField = fieldName
		}
	}

	if subIDField == "" {
		subIDField = "StripeSubscriptionId"
	}
	if userIDField == "" {
		userIDField = "UserId"
	}
	if planField == "" {
		planField = "Plan"
	}
	if statusField == "" {
		statusField = "Status"
	}

	gf.P("// --- ", typeName, " Stripe Subscription Operations ---")
	gf.P()

	// Ops struct
	gf.P("// ", typeName, "StripeOps provides Stripe subscription operations")
	gf.P("type ", typeName, "StripeSubOps struct {")
	gf.P("	collection *", typeName, "Collection")
	gf.P("	priceIDs   map[Plan]string")
	gf.P("}")
	gf.P()

	// Constructor
	gf.P("// New", typeName, "StripeSubOps creates subscription operations")
	gf.P("func New", typeName, "StripeSubOps(collection *", typeName, "Collection, priceIDs map[Plan]string) *", typeName, "StripeSubOps {")
	gf.P("	initStripe()")
	gf.P("	return &", typeName, "StripeSubOps{collection: collection, priceIDs: priceIDs}")
	gf.P("}")
	gf.P()

	// Subscribe
	gf.P("// Subscribe creates a new subscription")
	gf.P("func (s *", typeName, "StripeSubOps) Subscribe(customerID string, plan Plan, paymentMethodID string) NetworkOp[*", typeName, "] {")
	gf.P("	return func(ctx context.Context) (*", typeName, ", error) {")
	gf.P("		priceID, ok := s.priceIDs[plan]")
	gf.P("		if !ok {")
	gf.P("			return nil, errors.New(\"unknown plan: \" + string(plan))")
	gf.P("		}")
	gf.P()
	gf.P("		params := &stripe.SubscriptionParams{")
	gf.P("			Customer: stripe.String(customerID),")
	gf.P("			Items: []*stripe.SubscriptionItemsParams{")
	gf.P("				{Price: stripe.String(priceID)},")
	gf.P("			},")
	gf.P("			DefaultPaymentMethod: stripe.String(paymentMethodID),")
	gf.P("		}")
	gf.P()
	gf.P("		sub, err := subscription.New(params)")
	gf.P("		if err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P()
	gf.P("		userID, _ := UserIDFromContext(ctx)")
	gf.P("		entity := &", typeName, "{")
	gf.P("			", subIDField, ": sub.ID,")
	gf.P("			", userIDField, ": userID,")
	gf.P("		}")
	gf.P()
	gf.P("		if _, err := s.collection.Doc(sub.ID).Set(entity)(ctx); err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P()
	gf.P("		return entity, nil")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// Cancel
	gf.P("// Cancel cancels subscription at period end")
	gf.P("func (s *", typeName, "StripeSubOps) Cancel(subscriptionID string) NetworkOp[*", typeName, "] {")
	gf.P("	return func(ctx context.Context) (*", typeName, ", error) {")
	gf.P("		params := &stripe.SubscriptionParams{")
	gf.P("			CancelAtPeriodEnd: stripe.Bool(true),")
	gf.P("		}")
	gf.P("		_, err := subscription.Update(subscriptionID, params)")
	gf.P("		if err != nil {")
	gf.P("			return nil, err")
	gf.P("		}")
	gf.P()
	gf.P("		return s.collection.Doc(subscriptionID).Get()(ctx)")
	gf.P("	}")
	gf.P("}")
	gf.P()

	// GetByUserID
	gf.P("// GetByUserID finds active subscription for user")
	gf.P("func (s *", typeName, "StripeSubOps) GetByUserID(userID string) DBOp[*", typeName, "] {")
	gf.P("	return s.collection.Where(\"", toSnakeCase(userIDField), "\", \"==\", userID).First()")
	gf.P("}")
	gf.P()

	// Webhook handler
	gf.P("// New", typeName, "WebhookHandler creates HTTP handler for Stripe webhooks")
	gf.P("func New", typeName, "WebhookHandler(collection *", typeName, "Collection, webhookSecret string) http.Handler {")
	gf.P("	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {")
	gf.P("		payload, err := io.ReadAll(r.Body)")
	gf.P("		if err != nil {")
	gf.P("			http.Error(w, err.Error(), http.StatusBadRequest)")
	gf.P("			return")
	gf.P("		}")
	gf.P()
	gf.P("		event, err := webhook.ConstructEvent(payload, r.Header.Get(\"Stripe-Signature\"), webhookSecret)")
	gf.P("		if err != nil {")
	gf.P("			http.Error(w, err.Error(), http.StatusBadRequest)")
	gf.P("			return")
	gf.P("		}")
	gf.P()
	gf.P("		ctx := r.Context()")
	gf.P()
	gf.P("		switch event.Type {")
	gf.P("		case \"customer.subscription.created\", \"customer.subscription.updated\":")
	gf.P("			var sub stripe.Subscription")
	gf.P("			if err := json.Unmarshal(event.Data.Raw, &sub); err != nil {")
	gf.P("				http.Error(w, err.Error(), http.StatusBadRequest)")
	gf.P("				return")
	gf.P("			}")
	gf.P("			entity, _ := collection.Doc(sub.ID).Get()(ctx)")
	gf.P("			if entity == nil {")
	gf.P("				entity = &", typeName, "{", subIDField, ": sub.ID}")
	gf.P("			}")
	gf.P("			collection.Doc(sub.ID).Set(entity)(ctx)")
	gf.P()
	gf.P("		case \"customer.subscription.deleted\":")
	gf.P("			var sub stripe.Subscription")
	gf.P("			if err := json.Unmarshal(event.Data.Raw, &sub); err != nil {")
	gf.P("				http.Error(w, err.Error(), http.StatusBadRequest)")
	gf.P("				return")
	gf.P("			}")
	gf.P("			collection.Doc(sub.ID).Delete()(ctx)")
	gf.P("		}")
	gf.P()
	gf.P("		w.WriteHeader(http.StatusOK)")
	gf.P("	})")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateStripeBillingInterceptor(gf *protogen.GeneratedFile, s *protogen.Service, cfg *StripeFileConfig) {
	serviceName := s.GoName

	gf.P("// --- ", serviceName, " Stripe Billing ---")
	gf.P()

	// Method plan requirements map
	gf.P("// ", serviceName, "MethodPlans maps methods to minimum required plans")
	gf.P("var ", serviceName, "MethodPlans = map[string]Plan{")
	for _, m := range s.Methods {
		methodOpts := g.parseMethodOptions(m)
		if methodOpts != nil && methodOpts.MinPlan != "" {
			gf.P("	\"/", s.Desc.FullName(), "/", m.Desc.Name(), "\": Plan", strings.Title(methodOpts.MinPlan), ",")
		}
	}
	gf.P("}")
	gf.P()

	// Metered methods
	gf.P("// ", serviceName, "MeteredMethods defines which methods are metered")
	gf.P("var ", serviceName, "MeteredMethods = map[string]string{")
	for _, m := range s.Methods {
		methodOpts := g.parseMethodOptions(m)
		if methodOpts != nil && methodOpts.Metered {
			meterEvent := methodOpts.MeterEvent
			if meterEvent == "" {
				meterEvent = toSnakeCase(m.GoName)
			}
			gf.P("	\"/", s.Desc.FullName(), "/", m.Desc.Name(), "\": \"", meterEvent, "\",")
		}
	}
	gf.P("}")
	gf.P()

	// RequirePlan helper
	gf.P("// Require", serviceName, "Plan checks if user meets plan requirement")
	gf.P("func Require", serviceName, "Plan(ctx context.Context, getUserPlan func(ctx context.Context, userID string) (Plan, error), method string) error {")
	gf.P("	minPlan, ok := ", serviceName, "MethodPlans[method]")
	gf.P("	if !ok {")
	gf.P("		return nil // no plan requirement")
	gf.P("	}")
	gf.P()
	gf.P("	userID, ok := UserIDFromContext(ctx)")
	gf.P("	if !ok {")
	gf.P("		return errors.New(\"user ID required\")")
	gf.P("	}")
	gf.P()
	gf.P("	currentPlan, err := getUserPlan(ctx, userID)")
	gf.P("	if err != nil {")
	gf.P("		return err")
	gf.P("	}")
	gf.P()
	gf.P("	if !PlanAtLeast(currentPlan, minPlan) {")
	gf.P("		return &PlanError{Required: minPlan, Current: currentPlan}")
	gf.P("	}")
	gf.P()
	gf.P("	return nil")
	gf.P("}")
	gf.P()

	// Connect interceptor
	gf.P("// ", serviceName, "BillingInterceptor creates a Connect interceptor for plan checks")
	gf.P("func ", serviceName, "BillingInterceptor(getUserPlan func(ctx context.Context, userID string) (Plan, error)) connect.UnaryInterceptorFunc {")
	gf.P("	return func(next connect.UnaryFunc) connect.UnaryFunc {")
	gf.P("		return func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {")
	gf.P("			if err := Require", serviceName, "Plan(ctx, getUserPlan, req.Spec().Procedure); err != nil {")
	gf.P("				return nil, connect.NewError(connect.CodePermissionDenied, err)")
	gf.P("			}")
	gf.P("			return next(ctx, req)")
	gf.P("		}")
	gf.P("	}")
	gf.P("}")
	gf.P()
}

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}
