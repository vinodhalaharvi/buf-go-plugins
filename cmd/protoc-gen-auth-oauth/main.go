// protoc-gen-auth-oauth generates OAuth authentication (Google, GitHub, Apple)
// Detects AuthOAuth message embedded in a parent entity (User)
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	pluginpb "google.golang.org/protobuf/types/pluginpb"
)

type Code struct{ Run func() string }

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }
func Concat(codes []Code) string {
	var sb strings.Builder
	for _, c := range codes {
		sb.WriteString(c.Run())
	}
	return sb.String()
}

type AuthOAuthConfig struct {
	AuthOAuthMsg     string
	ParentMsg        string
	ParentGoField    string
	ParentEmailField string
	ParentNameField  string
}

func DetectAuthOAuth(file *protogen.File) *AuthOAuthConfig {
	var config AuthOAuthConfig
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == "AuthOAuth" {
			config.AuthOAuthMsg = msg.GoIdent.GoName
			break
		}
	}
	if config.AuthOAuthMsg == "" {
		return nil
	}
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == "AuthOAuth" || msg.GoIdent.GoName == "OAuthLink" {
			continue
		}
		for _, f := range msg.Fields {
			if f.Message != nil && f.Message.GoIdent.GoName == "AuthOAuth" {
				config.ParentMsg = msg.GoIdent.GoName
				config.ParentGoField = f.GoName
				for _, pf := range msg.Fields {
					name := string(pf.Desc.Name())
					if name == "email" {
						config.ParentEmailField = pf.GoName
					}
					if name == "name" {
						config.ParentNameField = pf.GoName
					}
				}
				if config.ParentEmailField != "" {
					return &config
				}
			}
		}
	}
	return nil
}

func GenerateBackend(pkgName string, cfg *AuthOAuthConfig) string {
	p := cfg.ParentMsg
	af := cfg.ParentGoField
	ef := cfg.ParentEmailField
	nf := cfg.ParentNameField

	return Concat([]Code{
		Line("// Code generated by protoc-gen-auth-oauth. DO NOT EDIT."),
		Linef("package %s", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"crypto/rand"`),
		Line(`	"encoding/base64"`),
		Line(`	"encoding/json"`),
		Line(`	"errors"`),
		Line(`	"fmt"`),
		Line(`	"net/http"`),
		Line(`	"net/url"`),
		Line(`	"strings"`),
		Line(`	"sync"`),
		Line(`	"time"`),
		Line(")"),
		Blank(),
		Line("var ("),
		Line(`	ErrOAuthInvalidState    = errors.New("invalid state")`),
		Line(`	ErrOAuthExchangeFailed  = errors.New("token exchange failed")`),
		Line(`	ErrOAuthUserInfoFailed  = errors.New("user info failed")`),
		Line(`	ErrOAuthUnknownProvider = errors.New("unknown provider")`),
		Line(`	ErrOAuthCannotUnlink    = errors.New("cannot unlink last auth")`),
		Line(")"),
		Blank(),
		Line("type OAuthProvider interface {"),
		Line("	Name() string"),
		Line("	AuthURL(state, redirect string) string"),
		Line("	Exchange(ctx context.Context, code, redirect string) (*OAuthToken, error)"),
		Line("	UserInfo(ctx context.Context, token *OAuthToken) (*OAuthUserInfo, error)"),
		Line("}"),
		Blank(),
		Line("type OAuthToken struct {"),
		Line("	AccessToken string `json:\"access_token\"`"),
		Line("	TokenType   string `json:\"token_type\"`"),
		Line("}"),
		Blank(),
		Line("type OAuthUserInfo struct { ID, Email, Name, Picture string; EmailVerified bool }"),
		Blank(),
		Line("type OAuthStateManager struct { mu sync.Mutex; states map[string]time.Time; ttl time.Duration }"),
		Line("func NewOAuthStateManager() *OAuthStateManager { return &OAuthStateManager{states: make(map[string]time.Time), ttl: 10*time.Minute} }"),
		Line("func (m *OAuthStateManager) Generate() string { b := make([]byte, 32); rand.Read(b); s := base64.URLEncoding.EncodeToString(b); m.mu.Lock(); m.states[s] = time.Now().Add(m.ttl); m.mu.Unlock(); return s }"),
		Line("func (m *OAuthStateManager) Validate(s string) bool { m.mu.Lock(); defer m.mu.Unlock(); exp, ok := m.states[s]; if !ok { return false }; delete(m.states, s); return time.Now().Before(exp) }"),
		Blank(),
		Line("type GoogleProvider struct { ClientID, ClientSecret string }"),
		Line("func (p *GoogleProvider) Name() string { return \"google\" }"),
		Line("func (p *GoogleProvider) AuthURL(state, redirect string) string { v := url.Values{}; v.Set(\"client_id\", p.ClientID); v.Set(\"redirect_uri\", redirect); v.Set(\"response_type\", \"code\"); v.Set(\"scope\", \"openid email profile\"); v.Set(\"state\", state); return \"https://accounts.google.com/o/oauth2/v2/auth?\" + v.Encode() }"),
		Line("func (p *GoogleProvider) Exchange(ctx context.Context, code, redirect string) (*OAuthToken, error) { v := url.Values{}; v.Set(\"code\", code); v.Set(\"client_id\", p.ClientID); v.Set(\"client_secret\", p.ClientSecret); v.Set(\"redirect_uri\", redirect); v.Set(\"grant_type\", \"authorization_code\"); resp, err := http.PostForm(\"https://oauth2.googleapis.com/token\", v); if err != nil { return nil, err }; defer resp.Body.Close(); var t OAuthToken; json.NewDecoder(resp.Body).Decode(&t); return &t, nil }"),
		Line("func (p *GoogleProvider) UserInfo(ctx context.Context, t *OAuthToken) (*OAuthUserInfo, error) { req, _ := http.NewRequestWithContext(ctx, \"GET\", \"https://www.googleapis.com/oauth2/v2/userinfo\", nil); req.Header.Set(\"Authorization\", \"Bearer \"+t.AccessToken); resp, err := http.DefaultClient.Do(req); if err != nil { return nil, err }; defer resp.Body.Close(); var d struct { ID string `json:\"id\"`; Email string `json:\"email\"`; Verified bool `json:\"verified_email\"`; Name string `json:\"name\"`; Picture string `json:\"picture\"` }; json.NewDecoder(resp.Body).Decode(&d); return &OAuthUserInfo{ID: d.ID, Email: d.Email, EmailVerified: d.Verified, Name: d.Name, Picture: d.Picture}, nil }"),
		Blank(),
		Line("type GitHubProvider struct { ClientID, ClientSecret string }"),
		Line("func (p *GitHubProvider) Name() string { return \"github\" }"),
		Line("func (p *GitHubProvider) AuthURL(state, redirect string) string { v := url.Values{}; v.Set(\"client_id\", p.ClientID); v.Set(\"redirect_uri\", redirect); v.Set(\"scope\", \"user:email\"); v.Set(\"state\", state); return \"https://github.com/login/oauth/authorize?\" + v.Encode() }"),
		Line("func (p *GitHubProvider) Exchange(ctx context.Context, code, redirect string) (*OAuthToken, error) { v := url.Values{}; v.Set(\"code\", code); v.Set(\"client_id\", p.ClientID); v.Set(\"client_secret\", p.ClientSecret); req, _ := http.NewRequest(\"POST\", \"https://github.com/login/oauth/access_token\", strings.NewReader(v.Encode())); req.Header.Set(\"Accept\", \"application/json\"); req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\"); resp, err := http.DefaultClient.Do(req); if err != nil { return nil, err }; defer resp.Body.Close(); var t OAuthToken; json.NewDecoder(resp.Body).Decode(&t); return &t, nil }"),
		Line("func (p *GitHubProvider) UserInfo(ctx context.Context, t *OAuthToken) (*OAuthUserInfo, error) { req, _ := http.NewRequestWithContext(ctx, \"GET\", \"https://api.github.com/user\", nil); req.Header.Set(\"Authorization\", \"Bearer \"+t.AccessToken); resp, err := http.DefaultClient.Do(req); if err != nil { return nil, err }; defer resp.Body.Close(); var d struct { ID int64 `json:\"id\"`; Email string `json:\"email\"`; Name string `json:\"name\"`; Avatar string `json:\"avatar_url\"` }; json.NewDecoder(resp.Body).Decode(&d); return &OAuthUserInfo{ID: fmt.Sprintf(\"%d\", d.ID), Email: d.Email, EmailVerified: true, Name: d.Name, Picture: d.Avatar}, nil }"),
		Blank(),
		Line("type AuthOAuthService struct {"),
		Linef("	repo      %sRepository", p),
		Line("	providers map[string]OAuthProvider"),
		Line("	states    *OAuthStateManager"),
		Line("}"),
		Blank(),
		Linef("func NewAuthOAuthService(repo %sRepository) *AuthOAuthService {", p),
		Line("	return &AuthOAuthService{repo: repo, providers: make(map[string]OAuthProvider), states: NewOAuthStateManager()}"),
		Line("}"),
		Blank(),
		Line("func (s *AuthOAuthService) RegisterProvider(p OAuthProvider) { s.providers[p.Name()] = p }"),
		Blank(),
		Line("func (s *AuthOAuthService) StartAuth(provider, redirect string) (string, error) {"),
		Line("	p, ok := s.providers[provider]; if !ok { return \"\", ErrOAuthUnknownProvider }"),
		Line("	return p.AuthURL(s.states.Generate(), redirect), nil"),
		Line("}"),
		Blank(),
		Line("type OAuthLoginResult struct {"),
		Line("	AccessToken, RefreshToken string"),
		Line("	ExpiresAt time.Time"),
		Linef("	%s *%s", p, p),
		Line("	IsNewUser bool"),
		Line("}"),
		Blank(),
		Line("func (s *AuthOAuthService) HandleCallback(ctx context.Context, provider, code, state, redirect string) (*OAuthLoginResult, error) {"),
		Line("	if !s.states.Validate(state) { return nil, ErrOAuthInvalidState }"),
		Line("	p, ok := s.providers[provider]; if !ok { return nil, ErrOAuthUnknownProvider }"),
		Line("	token, err := p.Exchange(ctx, code, redirect); if err != nil { return nil, ErrOAuthExchangeFailed }"),
		Line("	info, err := p.UserInfo(ctx, token); if err != nil { return nil, ErrOAuthUserInfoFailed }"),
		Blank(),
		Line("	users, _ := s.repo.List(ctx)"),
		Linef("	var user *%s", p),
		Line("	var isNew bool"),
		Blank(),
		Line("	// Find by OAuth link"),
		Line("	for _, u := range users {"),
		Linef("		if u.%s != nil {", af),
		Linef("			for _, link := range u.%s.Links {", af),
		Line("				if link.Provider == provider && link.ProviderId == info.ID { user = u; break }"),
		Line("			}"),
		Line("		}"),
		Line("		if user != nil { break }"),
		Line("	}"),
		Blank(),
		Line("	// Find by email"),
		Linef("	if user == nil && info.Email != \"\" { user, _ = s.repo.GetBy%s(ctx, info.Email) }", ef),
		Blank(),
		Line("	// Create new"),
		Line("	if user == nil {"),
		Linef("		user = &%s{%s: info.Email, %s: info.Name}", p, ef, nf),
		Line("		isNew = true"),
		Line("	}"),
		Blank(),
		Linef("	if user.%s == nil { user.%s = &AuthOAuth{} }", af, af),
		Blank(),
		Line("	// Add link"),
		Line("	found := false"),
		Linef("	for _, l := range user.%s.Links { if l.Provider == provider { found = true; break } }", af),
		Line("	if !found {"),
		Line("		now := time.Now()"),
		Linef("		user.%s.Links = append(user.%s.Links, &OAuthLink{Provider: provider, ProviderId: info.ID, Email: info.Email, LinkedAt: &now})", af, af),
		Line("	}"),
		Blank(),
		Line("	if isNew { id, _ := s.repo.Create(ctx, user); user.Id = id } else { s.repo.Update(ctx, user) }"),
		Blank(),
		Line("	b := make([]byte, 32); rand.Read(b); at := base64.URLEncoding.EncodeToString(b)"),
		Line("	rand.Read(b); rt := base64.URLEncoding.EncodeToString(b)"),
		Linef("	return &OAuthLoginResult{AccessToken: at, RefreshToken: rt, ExpiresAt: time.Now().Add(24*time.Hour), %s: user, IsNewUser: isNew}, nil", p),
		Line("}"),
		Blank(),
		Line("func (s *AuthOAuthService) UnlinkProvider(ctx context.Context, userID, provider string) error {"),
		Line("	user, err := s.repo.Get(ctx, userID); if err != nil { return err }"),
		Linef("	if user.%s == nil || len(user.%s.Links) <= 1 { return ErrOAuthCannotUnlink }", af, af),
		Line("	var links []*OAuthLink"),
		Linef("	for _, l := range user.%s.Links { if l.Provider != provider { links = append(links, l) } }", af),
		Linef("	user.%s.Links = links", af),
		Line("	return s.repo.Update(ctx, user)"),
		Line("}"),
		Blank(),
		Line("func (s *AuthOAuthService) GetLinkedProviders(ctx context.Context, userID string) ([]string, error) {"),
		Line("	user, err := s.repo.Get(ctx, userID); if err != nil { return nil, err }"),
		Linef("	if user.%s == nil { return nil, nil }", af),
		Line("	var out []string"),
		Linef("	for _, l := range user.%s.Links { out = append(out, l.Provider) }", af),
		Line("	return out, nil"),
		Line("}"),
	})
}

func generateFrontend() string {
	return `// auth_oauth.tsx
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';

interface AuthOAuthContextType {
  startAuth: (provider: string) => Promise<void>;
  handleCallback: (provider: string, code: string, state: string) => Promise<any>;
  unlinkProvider: (provider: string) => Promise<void>;
  linkedProviders: string[];
}

const AuthOAuthContext = createContext<AuthOAuthContextType | null>(null);

export function AuthOAuthProvider({ children, client, redirectUri }: { children: React.ReactNode; client: any; redirectUri: string }) {
  const [linkedProviders, setLinkedProviders] = useState<string[]>([]);

  useEffect(() => { client.getLinkedProviders?.().then((r: any) => setLinkedProviders(r.providers || [])).catch(() => {}); }, [client]);

  const startAuth = useCallback(async (provider: string) => {
    const { url } = await client.startAuth({ provider, redirectUri });
    window.location.href = url;
  }, [client, redirectUri]);

  const handleCallback = useCallback(async (provider: string, code: string, state: string) => {
    const result = await client.handleCallback({ provider, code, state, redirectUri });
    localStorage.setItem('auth', JSON.stringify({ user: result.user, accessToken: result.accessToken, refreshToken: result.refreshToken }));
    return result;
  }, [client, redirectUri]);

  const unlinkProvider = useCallback(async (provider: string) => {
    await client.unlinkProvider({ provider });
    setLinkedProviders(p => p.filter(x => x !== provider));
  }, [client]);

  return <AuthOAuthContext.Provider value={{ startAuth, handleCallback, unlinkProvider, linkedProviders }}>{children}</AuthOAuthContext.Provider>;
}

export function useAuthOAuth() { const ctx = useContext(AuthOAuthContext); if (!ctx) throw new Error('useAuthOAuth requires AuthOAuthProvider'); return ctx; }

const providers: Record<string, { name: string; bg: string }> = {
  google: { name: 'Google', bg: '#4285F4' },
  github: { name: 'GitHub', bg: '#333' },
};

export function OAuthButtons({ items = ['google', 'github'], mode = 'login' }: { items?: string[]; mode?: 'login' | 'signup' | 'link' }) {
  const { startAuth, linkedProviders } = useAuthOAuth();
  const label = mode === 'login' ? 'Sign in with' : mode === 'signup' ? 'Sign up with' : 'Link';

  return (
    <div className="space-y-2">
      {items.map(p => {
        const cfg = providers[p] || { name: p, bg: '#666' };
        const linked = linkedProviders.includes(p);
        return (
          <button key={p} onClick={() => startAuth(p)} disabled={mode === 'link' && linked}
            className="w-full py-2 px-4 rounded text-white disabled:opacity-50" style={{ backgroundColor: cfg.bg }}>
            {linked ? cfg.name + ' Linked' : label + ' ' + cfg.name}
          </button>
        );
      })}
    </div>
  );
}

export function OAuthCallback({ onSuccess }: { onSuccess?: (result: any) => void }) {
  const { handleCallback } = useAuthOAuth();
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');

  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const code = params.get('code'), state = params.get('state');
    const provider = window.location.pathname.split('/').pop() || 'google';
    if (!code || !state) { setStatus('error'); return; }
    handleCallback(provider, code, state).then(r => { setStatus('success'); onSuccess?.(r); }).catch(() => setStatus('error'));
  }, [handleCallback, onSuccess]);

  if (status === 'loading') return <div className="p-8 text-center">Completing sign in...</div>;
  if (status === 'error') return <div className="p-8 text-center text-red-600">Authentication failed</div>;
  return <div className="p-8 text-center text-green-600">Success!</div>;
}
`
}

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			cfg := DetectAuthOAuth(f)
			if cfg == nil {
				continue
			}
			pkgName := string(f.GoPackageName)
			goFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_auth_oauth.pb.go", f.GoImportPath)
			goFile.P(GenerateBackend(pkgName, cfg))
			basePath := strings.Replace(f.GeneratedFilenamePrefix, "/go/", "/ui/", 1)
			tsFile := gen.NewGeneratedFile(basePath+"_auth_oauth.tsx", "")
			tsFile.P(generateFrontend())
		}
		return nil
	})
}
