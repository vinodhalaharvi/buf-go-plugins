// protoc-gen-stripe generates Stripe payment integration
// Detects StripeCustomer message embedded in a parent entity (User)
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	pluginpb "google.golang.org/protobuf/types/pluginpb"
)

type Code struct{ Run func() string }

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }
func Concat(codes []Code) string {
	var sb strings.Builder
	for _, c := range codes {
		sb.WriteString(c.Run())
	}
	return sb.String()
}

type StripeConfig struct {
	StripeCustomerMsg string
	ParentMsg         string
	ParentGoField     string
	ParentEmailField  string
	ParentNameField   string

	// Fields detected in StripeCustomer
	HasCustomerID         bool
	HasSubscriptionID     bool
	HasSubscriptionStatus bool
	HasPriceID            bool
	HasCurrentPeriodEnd   bool
	HasCancelAtPeriodEnd  bool
}

func DetectStripeCustomer(file *protogen.File) *StripeConfig {
	var config StripeConfig
	var stripeMsg *protogen.Message

	// Find StripeCustomer message
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == "StripeCustomer" {
			stripeMsg = msg
			config.StripeCustomerMsg = msg.GoIdent.GoName
			break
		}
	}

	if stripeMsg == nil {
		return nil
	}

	// Analyze StripeCustomer fields
	for _, f := range stripeMsg.Fields {
		switch string(f.Desc.Name()) {
		case "customer_id":
			config.HasCustomerID = true
		case "subscription_id":
			config.HasSubscriptionID = true
		case "subscription_status":
			config.HasSubscriptionStatus = true
		case "price_id":
			config.HasPriceID = true
		case "current_period_end":
			config.HasCurrentPeriodEnd = true
		case "cancel_at_period_end":
			config.HasCancelAtPeriodEnd = true
		}
	}

	if !config.HasCustomerID {
		return nil
	}

	// Find parent that embeds StripeCustomer
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == "StripeCustomer" {
			continue
		}
		for _, f := range msg.Fields {
			if f.Message != nil && f.Message.GoIdent.GoName == "StripeCustomer" {
				config.ParentMsg = msg.GoIdent.GoName
				config.ParentGoField = f.GoName
				for _, pf := range msg.Fields {
					name := string(pf.Desc.Name())
					if name == "email" {
						config.ParentEmailField = pf.GoName
					}
					if name == "name" {
						config.ParentNameField = pf.GoName
					}
				}
				if config.ParentEmailField != "" {
					return &config
				}
			}
		}
	}
	return nil
}

func GenerateBackend(pkgName string, cfg *StripeConfig) string {
	p := cfg.ParentMsg
	sf := cfg.ParentGoField
	ef := cfg.ParentEmailField
	nf := cfg.ParentNameField

	return Concat([]Code{
		Line("// Code generated by protoc-gen-stripe. DO NOT EDIT."),
		Linef("// Stripe payments for %s.%s", p, sf),
		Blank(),
		Linef("package %s", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"encoding/json"`),
		Line(`	"errors"`),
		Line(`	"fmt"`),
		Line(`	"io"`),
		Line(`	"net/http"`),
		Line(`	"time"`),
		Blank(),
		Line(`	"github.com/stripe/stripe-go/v76"`),
		Line(`	"github.com/stripe/stripe-go/v76/checkout/session"`),
		Line(`	"github.com/stripe/stripe-go/v76/customer"`),
		Line(`	billingportal "github.com/stripe/stripe-go/v76/billingportal/session"`),
		Line(`	"github.com/stripe/stripe-go/v76/subscription"`),
		Line(`	"github.com/stripe/stripe-go/v76/webhook"`),
		Line(")"),
		Blank(),
		Line("var ("),
		Line(`	ErrStripeCustomerNotFound = errors.New("stripe customer not found")`),
		Line(`	ErrStripeCheckoutFailed   = errors.New("checkout failed")`),
		Line(`	ErrStripeWebhookInvalid   = errors.New("invalid webhook")`),
		Line(")"),
		Blank(),
		Line("type StripeServiceConfig struct {"),
		Line("	SecretKey       string"),
		Line("	WebhookSecret   string"),
		Line("	SuccessURL      string"),
		Line("	CancelURL       string"),
		Line("	PortalReturnURL string"),
		Line("}"),
		Blank(),
		Line("func InitStripe(cfg StripeServiceConfig) { stripe.Key = cfg.SecretKey }"),
		Blank(),

		// StripeService
		Linef("type StripeService struct {"),
		Linef("	repo   %sRepository", p),
		Line("	config StripeServiceConfig"),
		Line("}"),
		Blank(),
		Linef("func NewStripeService(repo %sRepository, cfg StripeServiceConfig) *StripeService {", p),
		Line("	return &StripeService{repo: repo, config: cfg}"),
		Line("}"),
		Blank(),

		// GetOrCreateCustomer
		Line("func (s *StripeService) GetOrCreateCustomer(ctx context.Context, userID string) (string, error) {"),
		Line("	user, err := s.repo.Get(ctx, userID)"),
		Line("	if err != nil { return \"\", err }"),
		Blank(),
		Linef("	if user.%s != nil && user.%s.CustomerId != \"\" {", sf, sf),
		Linef("		return user.%s.CustomerId, nil", sf),
		Line("	}"),
		Blank(),
		Line("	// Create Stripe customer"),
		Line("	params := &stripe.CustomerParams{"),
		Linef("		Email: stripe.String(user.%s),", ef),
		Linef("		Name:  stripe.String(user.%s),", nf),
		Line("		Metadata: map[string]string{\"user_id\": userID},"),
		Line("	}"),
		Line("	cust, err := customer.New(params)"),
		Line("	if err != nil { return \"\", err }"),
		Blank(),
		Linef("	if user.%s == nil { user.%s = &StripeCustomer{} }", sf, sf),
		Linef("	user.%s.CustomerId = cust.ID", sf),
		Line("	s.repo.Update(ctx, user)"),
		Blank(),
		Line("	return cust.ID, nil"),
		Line("}"),
		Blank(),

		// CreateCheckoutSession
		Line("type CheckoutRequest struct {"),
		Line("	UserID    string"),
		Line("	PriceID   string"),
		Line("	Mode      string // subscription or payment"),
		Line("	TrialDays int64"),
		Line("}"),
		Blank(),
		Line("type CheckoutResult struct { SessionID, URL string }"),
		Blank(),
		Line("func (s *StripeService) CreateCheckoutSession(ctx context.Context, req CheckoutRequest) (*CheckoutResult, error) {"),
		Line("	custID, err := s.GetOrCreateCustomer(ctx, req.UserID)"),
		Line("	if err != nil { return nil, err }"),
		Blank(),
		Line("	mode := stripe.CheckoutSessionModeSubscription"),
		Line("	if req.Mode == \"payment\" { mode = stripe.CheckoutSessionModePayment }"),
		Blank(),
		Line("	params := &stripe.CheckoutSessionParams{"),
		Line("		Customer: stripe.String(custID),"),
		Line("		Mode:     stripe.String(string(mode)),"),
		Line("		LineItems: []*stripe.CheckoutSessionLineItemParams{{"),
		Line("			Price:    stripe.String(req.PriceID),"),
		Line("			Quantity: stripe.Int64(1),"),
		Line("		}},"),
		Line("		SuccessURL: stripe.String(s.config.SuccessURL + \"?session_id={CHECKOUT_SESSION_ID}\"),"),
		Line("		CancelURL:  stripe.String(s.config.CancelURL),"),
		Line("	}"),
		Blank(),
		Line("	if mode == stripe.CheckoutSessionModeSubscription && req.TrialDays > 0 {"),
		Line("		params.SubscriptionData = &stripe.CheckoutSessionSubscriptionDataParams{"),
		Line("			TrialPeriodDays: stripe.Int64(req.TrialDays),"),
		Line("		}"),
		Line("	}"),
		Blank(),
		Line("	sess, err := session.New(params)"),
		Line("	if err != nil { return nil, ErrStripeCheckoutFailed }"),
		Blank(),
		Line("	return &CheckoutResult{SessionID: sess.ID, URL: sess.URL}, nil"),
		Line("}"),
		Blank(),

		// CreatePortalSession
		Line("func (s *StripeService) CreatePortalSession(ctx context.Context, userID string) (string, error) {"),
		Line("	user, err := s.repo.Get(ctx, userID)"),
		Line("	if err != nil { return \"\", err }"),
		Linef("	if user.%s == nil || user.%s.CustomerId == \"\" { return \"\", ErrStripeCustomerNotFound }", sf, sf),
		Blank(),
		Line("	params := &stripe.BillingPortalSessionParams{"),
		Linef("		Customer:  stripe.String(user.%s.CustomerId),", sf),
		Line("		ReturnURL: stripe.String(s.config.PortalReturnURL),"),
		Line("	}"),
		Line("	sess, err := billingportal.New(params)"),
		Line("	if err != nil { return \"\", err }"),
		Line("	return sess.URL, nil"),
		Line("}"),
		Blank(),

		// CancelSubscription
		Line("func (s *StripeService) CancelSubscription(ctx context.Context, userID string) error {"),
		Line("	user, err := s.repo.Get(ctx, userID)"),
		Line("	if err != nil { return err }"),
		Linef("	if user.%s == nil || user.%s.SubscriptionId == \"\" { return nil }", sf, sf),
		Blank(),
		Linef("	_, err = subscription.Update(user.%s.SubscriptionId, &stripe.SubscriptionParams{", sf),
		Line("		CancelAtPeriodEnd: stripe.Bool(true),"),
		Line("	})"),
		Line("	if err != nil { return err }"),
		Blank(),
		Linef("	user.%s.CancelAtPeriodEnd = true", sf),
		Line("	return s.repo.Update(ctx, user)"),
		Line("}"),
		Blank(),

		// ReactivateSubscription
		Line("func (s *StripeService) ReactivateSubscription(ctx context.Context, userID string) error {"),
		Line("	user, err := s.repo.Get(ctx, userID)"),
		Line("	if err != nil { return err }"),
		Linef("	if user.%s == nil || user.%s.SubscriptionId == \"\" { return nil }", sf, sf),
		Blank(),
		Linef("	_, err = subscription.Update(user.%s.SubscriptionId, &stripe.SubscriptionParams{", sf),
		Line("		CancelAtPeriodEnd: stripe.Bool(false),"),
		Line("	})"),
		Line("	if err != nil { return err }"),
		Blank(),
		Linef("	user.%s.CancelAtPeriodEnd = false", sf),
		Line("	return s.repo.Update(ctx, user)"),
		Line("}"),
		Blank(),

		// GetSubscriptionStatus
		Linef("func (s *StripeService) GetSubscriptionStatus(ctx context.Context, userID string) (*StripeCustomer, error) {"),
		Line("	user, err := s.repo.Get(ctx, userID)"),
		Line("	if err != nil { return nil, err }"),
		Linef("	return user.%s, nil", sf),
		Line("}"),
		Blank(),

		// WebhookHandler
		Line("type StripeWebhookHandler struct {"),
		Linef("	repo          %sRepository", p),
		Line("	webhookSecret string"),
		Line("}"),
		Blank(),
		Linef("func NewStripeWebhookHandler(repo %sRepository, secret string) *StripeWebhookHandler {", p),
		Line("	return &StripeWebhookHandler{repo: repo, webhookSecret: secret}"),
		Line("}"),
		Blank(),
		Line("func (h *StripeWebhookHandler) HandleWebhook(w http.ResponseWriter, r *http.Request) {"),
		Line("	body, err := io.ReadAll(r.Body)"),
		Line("	if err != nil { http.Error(w, \"read error\", 400); return }"),
		Blank(),
		Line("	event, err := webhook.ConstructEvent(body, r.Header.Get(\"Stripe-Signature\"), h.webhookSecret)"),
		Line("	if err != nil { http.Error(w, \"invalid signature\", 400); return }"),
		Blank(),
		Line("	ctx := r.Context()"),
		Blank(),
		Line("	switch event.Type {"),
		Line("	case \"customer.subscription.created\", \"customer.subscription.updated\":"),
		Line("		var sub stripe.Subscription"),
		Line("		json.Unmarshal(event.Data.Raw, &sub)"),
		Line("		h.handleSubscriptionUpdate(ctx, &sub)"),
		Line("	case \"customer.subscription.deleted\":"),
		Line("		var sub stripe.Subscription"),
		Line("		json.Unmarshal(event.Data.Raw, &sub)"),
		Line("		h.handleSubscriptionDeleted(ctx, &sub)"),
		Line("	}"),
		Blank(),
		Line("	w.WriteHeader(200)"),
		Line("}"),
		Blank(),
		Line("func (h *StripeWebhookHandler) handleSubscriptionUpdate(ctx context.Context, sub *stripe.Subscription) {"),
		Line("	users, _ := h.repo.List(ctx)"),
		Line("	for _, user := range users {"),
		Linef("		if user.%s != nil && user.%s.CustomerId == sub.Customer.ID {", sf, sf),
		Linef("			user.%s.SubscriptionId = sub.ID", sf),
		Linef("			user.%s.SubscriptionStatus = string(sub.Status)", sf),
		Line("			if len(sub.Items.Data) > 0 {"),
		Linef("				user.%s.PriceId = sub.Items.Data[0].Price.ID", sf),
		Line("			}"),
		Line("			t := time.Unix(sub.CurrentPeriodEnd, 0)"),
		Linef("			user.%s.CurrentPeriodEnd = &t", sf),
		Linef("			user.%s.CancelAtPeriodEnd = sub.CancelAtPeriodEnd", sf),
		Line("			h.repo.Update(ctx, user)"),
		Line("			return"),
		Line("		}"),
		Line("	}"),
		Line("}"),
		Blank(),
		Line("func (h *StripeWebhookHandler) handleSubscriptionDeleted(ctx context.Context, sub *stripe.Subscription) {"),
		Line("	users, _ := h.repo.List(ctx)"),
		Line("	for _, user := range users {"),
		Linef("		if user.%s != nil && user.%s.SubscriptionId == sub.ID {", sf, sf),
		Linef("			user.%s.SubscriptionId = \"\"", sf),
		Linef("			user.%s.SubscriptionStatus = \"canceled\"", sf),
		Linef("			user.%s.PriceId = \"\"", sf),
		Line("			h.repo.Update(ctx, user)"),
		Line("			return"),
		Line("		}"),
		Line("	}"),
		Line("}"),
	})
}

func generateFrontend() string {
	return `// stripe.tsx
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';

interface StripeContextType {
  subscription: StripeSubscription | null;
  isLoading: boolean;
  createCheckout: (priceId: string, mode?: 'subscription' | 'payment') => Promise<void>;
  openPortal: () => Promise<void>;
  cancelSubscription: () => Promise<void>;
  reactivateSubscription: () => Promise<void>;
  refresh: () => Promise<void>;
}

interface StripeSubscription {
  subscriptionId: string;
  subscriptionStatus: string;
  priceId: string;
  currentPeriodEnd: string;
  cancelAtPeriodEnd: boolean;
}

const StripeContext = createContext<StripeContextType | null>(null);

export function StripeProvider({ children, client }: { children: React.ReactNode; client: any }) {
  const [subscription, setSubscription] = useState<StripeSubscription | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const refresh = useCallback(async () => {
    try {
      const { subscription: sub } = await client.getSubscriptionStatus({});
      setSubscription(sub);
    } catch { setSubscription(null); }
  }, [client]);

  useEffect(() => { refresh().finally(() => setIsLoading(false)); }, [refresh]);

  const createCheckout = useCallback(async (priceId: string, mode = 'subscription') => {
    const { url } = await client.createCheckoutSession({ priceId, mode });
    window.location.href = url;
  }, [client]);

  const openPortal = useCallback(async () => {
    const { url } = await client.createPortalSession({});
    window.location.href = url;
  }, [client]);

  const cancelSubscription = useCallback(async () => {
    await client.cancelSubscription({});
    refresh();
  }, [client, refresh]);

  const reactivateSubscription = useCallback(async () => {
    await client.reactivateSubscription({});
    refresh();
  }, [client, refresh]);

  return (
    <StripeContext.Provider value={{ subscription, isLoading, createCheckout, openPortal, cancelSubscription, reactivateSubscription, refresh }}>
      {children}
    </StripeContext.Provider>
  );
}

export function useStripe() {
  const ctx = useContext(StripeContext);
  if (!ctx) throw new Error('useStripe requires StripeProvider');
  return ctx;
}

interface Plan { id: string; priceId: string; name: string; price: number; interval: string; features: string[] }

export function PricingTable({ plans, highlight }: { plans: Plan[]; highlight?: string }) {
  const { subscription, createCheckout } = useStripe();

  const fmt = (n: number) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(n / 100);

  return (
    <div className="grid gap-6 md:grid-cols-3">
      {plans.map(plan => {
        const isCurrent = subscription?.priceId === plan.priceId;
        const isHighlight = plan.id === highlight;
        return (
          <div key={plan.id} className={"rounded-lg border p-6 " + (isHighlight ? "border-blue-500 ring-2 ring-blue-500" : "") + (isCurrent ? " bg-blue-50" : "")}>
            <h3 className="text-xl font-bold">{plan.name}</h3>
            <div className="mt-4"><span className="text-4xl font-bold">{fmt(plan.price)}</span><span className="text-gray-500">/{plan.interval}</span></div>
            <ul className="mt-6 space-y-2">{plan.features.map((f, i) => <li key={i} className="flex items-center gap-2">âœ“ {f}</li>)}</ul>
            <button onClick={() => createCheckout(plan.priceId)} disabled={isCurrent}
              className={"mt-6 w-full py-2 rounded " + (isCurrent ? "bg-gray-200 text-gray-500" : "bg-blue-600 text-white hover:bg-blue-700")}>
              {isCurrent ? 'Current Plan' : 'Select'}
            </button>
          </div>
        );
      })}
    </div>
  );
}

export function SubscriptionStatus() {
  const { subscription, isLoading, cancelSubscription, reactivateSubscription, openPortal } = useStripe();

  if (isLoading) return <div className="animate-pulse h-24 bg-gray-100 rounded" />;
  if (!subscription) return <div className="p-4 bg-gray-50 rounded">No active subscription</div>;

  const statusColors: Record<string, string> = {
    active: 'bg-green-100 text-green-800',
    trialing: 'bg-blue-100 text-blue-800',
    past_due: 'bg-yellow-100 text-yellow-800',
    canceled: 'bg-gray-100 text-gray-800',
  };

  return (
    <div className="p-6 border rounded-lg">
      <div className="flex justify-between items-start">
        <div>
          <span className={"px-2 py-1 text-xs rounded-full " + (statusColors[subscription.subscriptionStatus] || 'bg-gray-100')}>
            {subscription.subscriptionStatus}
          </span>
          {subscription.currentPeriodEnd && (
            <p className="mt-2 text-sm text-gray-600">
              Renews {new Date(subscription.currentPeriodEnd).toLocaleDateString()}
            </p>
          )}
          {subscription.cancelAtPeriodEnd && (
            <p className="text-sm text-yellow-600">Cancels at period end</p>
          )}
        </div>
      </div>
      <div className="mt-4 flex gap-2">
        {subscription.cancelAtPeriodEnd ? (
          <button onClick={reactivateSubscription} className="px-4 py-2 bg-blue-600 text-white rounded">Reactivate</button>
        ) : (
          <button onClick={cancelSubscription} className="px-4 py-2 border rounded">Cancel</button>
        )}
        <button onClick={openPortal} className="px-4 py-2 border rounded">Manage Billing</button>
      </div>
    </div>
  );
}
`
}

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			cfg := DetectStripeCustomer(f)
			if cfg == nil {
				continue
			}
			pkgName := string(f.GoPackageName)
			goFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_stripe.pb.go", f.GoImportPath)
			goFile.P(GenerateBackend(pkgName, cfg))
			basePath := strings.Replace(f.GeneratedFilenamePrefix, "/go/", "/ui/", 1)
			tsFile := gen.NewGeneratedFile(basePath+"_stripe.tsx", "")
			tsFile.P(generateFrontend())
		}
		return nil
	})
}
