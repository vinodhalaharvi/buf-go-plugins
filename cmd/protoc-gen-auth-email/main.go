// protoc-gen-auth-email generates email/password authentication
// Detects AuthEmail message embedded in a parent entity (User)
// Uses Category Theory: Monoid + Functor + Fold
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// =============================================================================
// CATEGORY THEORY FOUNDATIONS
// =============================================================================

type Monoid[A any] struct {
	Empty  func() A
	Append func(A, A) A
}

type Code struct{ Run func() string }

var CodeMonoid = Monoid[Code]{
	Empty:  func() Code { return Code{Run: func() string { return "" }} },
	Append: func(a, b Code) Code { return Code{Run: func() string { return a.Run() + b.Run() }} },
}

func FoldRight[A, B any](xs []A, z B, f func(A, B) B) B {
	if len(xs) == 0 {
		return z
	}
	return f(xs[0], FoldRight(xs[1:], z, f))
}

func Concat[A any](m Monoid[A], xs []A) A {
	return FoldRight(xs, m.Empty(), func(a A, acc A) A { return m.Append(a, acc) })
}

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }

// =============================================================================
// MESSAGE DETECTION
// =============================================================================

type AuthEmailConfig struct {
	AuthEmailMsg string

	// Fields in AuthEmail
	HasPasswordHash        bool
	HasEmailVerified       bool
	HasVerificationToken   bool
	HasVerificationExpiry  bool
	HasResetToken          bool
	HasResetExpiry         bool
	HasRefreshToken        bool
	HasRefreshExpiry       bool
	HasFailedLoginAttempts bool
	HasLockedUntil         bool

	// Parent message that embeds AuthEmail
	ParentMsg        string
	ParentField      string
	ParentGoField    string
	ParentEmailField string
}

func DetectAuthEmail(file *protogen.File) *AuthEmailConfig {
	var authEmailMsg *protogen.Message
	var config AuthEmailConfig

	// Find AuthEmail message
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == "AuthEmail" {
			authEmailMsg = msg
			config.AuthEmailMsg = msg.GoIdent.GoName
			break
		}
	}

	if authEmailMsg == nil {
		return nil
	}

	// Analyze AuthEmail fields
	for _, f := range authEmailMsg.Fields {
		switch string(f.Desc.Name()) {
		case "password_hash":
			config.HasPasswordHash = true
		case "email_verified":
			config.HasEmailVerified = true
		case "verification_token":
			config.HasVerificationToken = true
		case "verification_token_expires_at":
			config.HasVerificationExpiry = true
		case "reset_token":
			config.HasResetToken = true
		case "reset_token_expires_at":
			config.HasResetExpiry = true
		case "refresh_token":
			config.HasRefreshToken = true
		case "refresh_token_expires_at":
			config.HasRefreshExpiry = true
		case "failed_login_attempts":
			config.HasFailedLoginAttempts = true
		case "locked_until":
			config.HasLockedUntil = true
		}
	}

	if !config.HasPasswordHash {
		return nil
	}

	// Find parent that embeds AuthEmail
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == "AuthEmail" {
			continue
		}

		for _, f := range msg.Fields {
			if f.Message != nil && f.Message.GoIdent.GoName == "AuthEmail" {
				config.ParentMsg = msg.GoIdent.GoName
				config.ParentField = string(f.Desc.Name())
				config.ParentGoField = f.GoName

				for _, pf := range msg.Fields {
					if string(pf.Desc.Name()) == "email" {
						config.ParentEmailField = pf.GoName
						break
					}
				}

				if config.ParentEmailField != "" {
					return &config
				}
			}
		}
	}

	return nil
}

// =============================================================================
// GO BACKEND GENERATOR
// =============================================================================

func GenerateBackend(pkgName string, cfg *AuthEmailConfig) Code {
	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-auth-email. DO NOT EDIT."),
		Linef("// Email/password auth for %s.%s", cfg.ParentMsg, cfg.ParentGoField),
		Blank(),
		Linef("package %s", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"crypto/rand"`),
		Line(`	"encoding/base64"`),
		Line(`	"errors"`),
		Line(`	"fmt"`),
		Line(`	"regexp"`),
		Line(`	"strings"`),
		Line(`	"time"`),
		Blank(),
		Line(`	"golang.org/x/crypto/bcrypt"`),
		Line(")"),
		Blank(),
		generateErrors(),
		generateConfig(),
		generateHelpers(),
		generateEmailSender(),
		generateService(cfg),
	})
}

func generateErrors() Code {
	return Concat(CodeMonoid, []Code{
		Line("var ("),
		Line(`	ErrAuthInvalidEmail       = errors.New("invalid email")`),
		Line(`	ErrAuthInvalidPassword    = errors.New("password must be at least 8 characters")`),
		Line(`	ErrAuthEmailExists        = errors.New("email already registered")`),
		Line(`	ErrAuthInvalidCredentials = errors.New("invalid credentials")`),
		Line(`	ErrAuthEmailNotVerified   = errors.New("email not verified")`),
		Line(`	ErrAuthAccountLocked      = errors.New("account locked")`),
		Line(`	ErrAuthInvalidToken       = errors.New("invalid token")`),
		Line(`	ErrAuthTokenExpired       = errors.New("token expired")`),
		Line(")"),
		Blank(),
	})
}

func generateConfig() Code {
	return Concat(CodeMonoid, []Code{
		Line("type AuthEmailServiceConfig struct {"),
		Line("	JWTSecret              string"),
		Line("	JWTExpiry              time.Duration"),
		Line("	RefreshExpiry          time.Duration"),
		Line("	VerificationExpiry     time.Duration"),
		Line("	ResetExpiry            time.Duration"),
		Line("	MaxFailedAttempts      int"),
		Line("	LockoutDuration        time.Duration"),
		Line("	BcryptCost             int"),
		Line("}"),
		Blank(),
		Line("func DefaultAuthEmailServiceConfig() AuthEmailServiceConfig {"),
		Line("	return AuthEmailServiceConfig{"),
		Line("		JWTExpiry:          24 * time.Hour,"),
		Line("		RefreshExpiry:      7 * 24 * time.Hour,"),
		Line("		VerificationExpiry: 24 * time.Hour,"),
		Line("		ResetExpiry:        time.Hour,"),
		Line("		MaxFailedAttempts:  5,"),
		Line("		LockoutDuration:    15 * time.Minute,"),
		Line("		BcryptCost:         12,"),
		Line("	}"),
		Line("}"),
		Blank(),
	})
}

func generateHelpers() Code {
	return Concat(CodeMonoid, []Code{
		Line("var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)"),
		Blank(),
		Line("func authValidateEmail(email string) error {"),
		Line("	if !emailRegex.MatchString(email) { return ErrAuthInvalidEmail }"),
		Line("	return nil"),
		Line("}"),
		Blank(),
		Line("func authHashPassword(password string, cost int) (string, error) {"),
		Line("	if len(password) < 8 { return \"\", ErrAuthInvalidPassword }"),
		Line("	hash, err := bcrypt.GenerateFromPassword([]byte(password), cost)"),
		Line("	return string(hash), err"),
		Line("}"),
		Blank(),
		Line("func authVerifyPassword(hash, password string) bool {"),
		Line("	return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil"),
		Line("}"),
		Blank(),
		Line("func authGenerateToken(length int) string {"),
		Line("	b := make([]byte, length)"),
		Line("	rand.Read(b)"),
		Line("	return base64.URLEncoding.EncodeToString(b)"),
		Line("}"),
		Blank(),
	})
}

func generateEmailSender() Code {
	return Concat(CodeMonoid, []Code{
		Line("type AuthEmailSender interface {"),
		Line("	SendVerification(to, token string) error"),
		Line("	SendPasswordReset(to, token string) error"),
		Line("	SendWelcome(to string) error"),
		Line("}"),
		Blank(),
		Line("type ConsoleAuthEmailSender struct{}"),
		Line("func (s *ConsoleAuthEmailSender) SendVerification(to, token string) error { fmt.Printf(\"[VERIFY] %s: %s\\n\", to, token); return nil }"),
		Line("func (s *ConsoleAuthEmailSender) SendPasswordReset(to, token string) error { fmt.Printf(\"[RESET] %s: %s\\n\", to, token); return nil }"),
		Line("func (s *ConsoleAuthEmailSender) SendWelcome(to string) error { fmt.Printf(\"[WELCOME] %s\\n\", to); return nil }"),
		Blank(),
	})
}

func generateService(cfg *AuthEmailConfig) Code {
	p := cfg.ParentMsg
	af := cfg.ParentGoField
	ef := cfg.ParentEmailField

	return Concat(CodeMonoid, []Code{
		Linef("type AuthEmailService struct {"),
		Linef("	repo   %sRepository", p),
		Line("	email  AuthEmailSender"),
		Line("	config AuthEmailServiceConfig"),
		Line("}"),
		Blank(),
		Linef("func NewAuthEmailService(repo %sRepository, email AuthEmailSender, config AuthEmailServiceConfig) *AuthEmailService {", p),
		Line("	if config.BcryptCost == 0 { config = DefaultAuthEmailServiceConfig() }"),
		Line("	return &AuthEmailService{repo: repo, email: email, config: config}"),
		Line("}"),
		Blank(),
		generateSignUp(cfg, p, af, ef),
		generateVerifyEmail(cfg, p, af, ef),
		generateLogin(cfg, p, af, ef),
		generateForgotPassword(cfg, p, af, ef),
		generateResetPassword(cfg, p, af),
		generateRefreshToken(cfg, p, af),
	})
}

func generateSignUp(cfg *AuthEmailConfig, p, af, ef string) Code {
	parts := []Code{
		Linef("func (s *AuthEmailService) SignUp(ctx context.Context, email, password, name string) (*%s, error) {", p),
		Line("	email = strings.ToLower(strings.TrimSpace(email))"),
		Line("	if err := authValidateEmail(email); err != nil { return nil, err }"),
		Blank(),
		Linef("	if existing, _ := s.repo.GetBy%s(ctx, email); existing != nil {", ef),
		Line("		return nil, ErrAuthEmailExists"),
		Line("	}"),
		Blank(),
		Line("	hash, err := authHashPassword(password, s.config.BcryptCost)"),
		Line("	if err != nil { return nil, err }"),
		Blank(),
		Linef("	user := &%s{%s: email, Name: name}", p, ef),
		Linef("	user.%s = &AuthEmail{PasswordHash: hash", af),
	}

	if cfg.HasEmailVerified {
		parts = append(parts, Line(", EmailVerified: false"))
	}
	if cfg.HasVerificationToken {
		parts = append(parts, Line(", VerificationToken: authGenerateToken(32)"))
	}
	if cfg.HasVerificationExpiry {
		parts = append(parts, Line(", VerificationTokenExpiresAt: func() *time.Time { t := time.Now().Add(s.config.VerificationExpiry); return &t }()"))
	}

	parts = append(parts,
		Line("}"),
		Blank(),
		Line("	id, err := s.repo.Create(ctx, user)"),
		Line("	if err != nil { return nil, err }"),
		Line("	user.Id = id"),
		Blank(),
	)

	if cfg.HasVerificationToken {
		parts = append(parts,
			Linef("	if s.email != nil { s.email.SendVerification(user.%s, user.%s.VerificationToken) }", ef, af),
			Blank(),
		)
	}

	parts = append(parts,
		Line("	return user, nil"),
		Line("}"),
		Blank(),
	)

	return Concat(CodeMonoid, parts)
}

func generateVerifyEmail(cfg *AuthEmailConfig, p, af, ef string) Code {
	if !cfg.HasVerificationToken || !cfg.HasEmailVerified {
		return Blank()
	}

	parts := []Code{
		Line("func (s *AuthEmailService) VerifyEmail(ctx context.Context, token string) error {"),
		Line("	users, _ := s.repo.List(ctx)"),
		Linef("	var user *%s", p),
		Linef("	for _, u := range users { if u.%s != nil && u.%s.VerificationToken == token { user = u; break } }", af, af),
		Line("	if user == nil { return ErrAuthInvalidToken }"),
		Blank(),
	}

	if cfg.HasVerificationExpiry {
		parts = append(parts,
			Linef("	if user.%s.VerificationTokenExpiresAt != nil && user.%s.VerificationTokenExpiresAt.Before(time.Now()) { return ErrAuthTokenExpired }", af, af),
			Blank(),
		)
	}

	parts = append(parts,
		Linef("	user.%s.EmailVerified = true", af),
		Linef("	user.%s.VerificationToken = \"\"", af),
	)
	if cfg.HasVerificationExpiry {
		parts = append(parts, Linef("	user.%s.VerificationTokenExpiresAt = nil", af))
	}

	parts = append(parts,
		Line("	if err := s.repo.Update(ctx, user); err != nil { return err }"),
		Linef("	if s.email != nil { s.email.SendWelcome(user.%s) }", ef),
		Line("	return nil"),
		Line("}"),
		Blank(),
	)

	return Concat(CodeMonoid, parts)
}

func generateLogin(cfg *AuthEmailConfig, p, af, ef string) Code {
	parts := []Code{
		Line("type AuthLoginResult struct {"),
		Line("	AccessToken  string"),
		Line("	RefreshToken string"),
		Line("	ExpiresAt    time.Time"),
		Linef("	%s          *%s", p, p),
		Line("}"),
		Blank(),
		Line("func (s *AuthEmailService) Login(ctx context.Context, email, password string) (*AuthLoginResult, error) {"),
		Line("	email = strings.ToLower(strings.TrimSpace(email))"),
		Linef("	user, err := s.repo.GetBy%s(ctx, email)", ef),
		Line("	if err != nil { return nil, ErrAuthInvalidCredentials }"),
		Linef("	if user.%s == nil { return nil, ErrAuthInvalidCredentials }", af),
		Blank(),
	}

	if cfg.HasLockedUntil {
		parts = append(parts,
			Linef("	if user.%s.LockedUntil != nil && user.%s.LockedUntil.After(time.Now()) { return nil, ErrAuthAccountLocked }", af, af),
			Blank(),
		)
	}

	if cfg.HasEmailVerified {
		parts = append(parts,
			Linef("	if !user.%s.EmailVerified { return nil, ErrAuthEmailNotVerified }", af),
			Blank(),
		)
	}

	parts = append(parts, Linef("	if !authVerifyPassword(user.%s.PasswordHash, password) {", af))

	if cfg.HasFailedLoginAttempts {
		parts = append(parts, Linef("		user.%s.FailedLoginAttempts++", af))
		if cfg.HasLockedUntil {
			parts = append(parts,
				Linef("		if user.%s.FailedLoginAttempts >= int32(s.config.MaxFailedAttempts) {", af),
				Line("			t := time.Now().Add(s.config.LockoutDuration)"),
				Linef("			user.%s.LockedUntil = &t", af),
				Line("		}"),
			)
		}
		parts = append(parts, Line("		s.repo.Update(ctx, user)"))
	}

	parts = append(parts,
		Line("		return nil, ErrAuthInvalidCredentials"),
		Line("	}"),
		Blank(),
	)

	if cfg.HasFailedLoginAttempts {
		parts = append(parts, Linef("	user.%s.FailedLoginAttempts = 0", af))
		if cfg.HasLockedUntil {
			parts = append(parts, Linef("	user.%s.LockedUntil = nil", af))
		}
	}

	parts = append(parts,
		Line("	accessToken := authGenerateToken(32)"),
		Line("	refreshToken := authGenerateToken(64)"),
	)

	if cfg.HasRefreshToken {
		parts = append(parts, Linef("	user.%s.RefreshToken = refreshToken", af))
		if cfg.HasRefreshExpiry {
			parts = append(parts,
				Line("	refreshExp := time.Now().Add(s.config.RefreshExpiry)"),
				Linef("	user.%s.RefreshTokenExpiresAt = &refreshExp", af),
			)
		}
	}

	parts = append(parts,
		Line("	s.repo.Update(ctx, user)"),
		Linef("	return &AuthLoginResult{AccessToken: accessToken, RefreshToken: refreshToken, ExpiresAt: time.Now().Add(s.config.JWTExpiry), %s: user}, nil", p),
		Line("}"),
		Blank(),
	)

	return Concat(CodeMonoid, parts)
}

func generateForgotPassword(cfg *AuthEmailConfig, p, af, ef string) Code {
	if !cfg.HasResetToken {
		return Blank()
	}

	parts := []Code{
		Line("func (s *AuthEmailService) ForgotPassword(ctx context.Context, email string) error {"),
		Line("	email = strings.ToLower(strings.TrimSpace(email))"),
		Linef("	user, err := s.repo.GetBy%s(ctx, email)", ef),
		Line("	if err != nil { return nil }"),
		Linef("	if user.%s == nil { user.%s = &AuthEmail{} }", af, af),
		Blank(),
		Line("	token := authGenerateToken(32)"),
		Linef("	user.%s.ResetToken = token", af),
	}

	if cfg.HasResetExpiry {
		parts = append(parts,
			Line("	exp := time.Now().Add(s.config.ResetExpiry)"),
			Linef("	user.%s.ResetTokenExpiresAt = &exp", af),
		)
	}

	parts = append(parts,
		Line("	s.repo.Update(ctx, user)"),
		Linef("	if s.email != nil { s.email.SendPasswordReset(user.%s, token) }", ef),
		Line("	return nil"),
		Line("}"),
		Blank(),
	)

	return Concat(CodeMonoid, parts)
}

func generateResetPassword(cfg *AuthEmailConfig, p, af string) Code {
	if !cfg.HasResetToken {
		return Blank()
	}

	parts := []Code{
		Line("func (s *AuthEmailService) ResetPassword(ctx context.Context, token, newPassword string) error {"),
		Line("	users, _ := s.repo.List(ctx)"),
		Linef("	var user *%s", p),
		Linef("	for _, u := range users { if u.%s != nil && u.%s.ResetToken == token { user = u; break } }", af, af),
		Line("	if user == nil { return ErrAuthInvalidToken }"),
		Blank(),
	}

	if cfg.HasResetExpiry {
		parts = append(parts,
			Linef("	if user.%s.ResetTokenExpiresAt != nil && user.%s.ResetTokenExpiresAt.Before(time.Now()) { return ErrAuthTokenExpired }", af, af),
			Blank(),
		)
	}

	parts = append(parts,
		Line("	hash, err := authHashPassword(newPassword, s.config.BcryptCost)"),
		Line("	if err != nil { return err }"),
		Linef("	user.%s.PasswordHash = hash", af),
		Linef("	user.%s.ResetToken = \"\"", af),
	)

	if cfg.HasResetExpiry {
		parts = append(parts, Linef("	user.%s.ResetTokenExpiresAt = nil", af))
	}
	if cfg.HasFailedLoginAttempts {
		parts = append(parts, Linef("	user.%s.FailedLoginAttempts = 0", af))
	}
	if cfg.HasLockedUntil {
		parts = append(parts, Linef("	user.%s.LockedUntil = nil", af))
	}

	parts = append(parts,
		Line("	return s.repo.Update(ctx, user)"),
		Line("}"),
		Blank(),
	)

	return Concat(CodeMonoid, parts)
}

func generateRefreshToken(cfg *AuthEmailConfig, p, af string) Code {
	if !cfg.HasRefreshToken {
		return Blank()
	}

	parts := []Code{
		Line("func (s *AuthEmailService) RefreshAccessToken(ctx context.Context, refreshToken string) (*AuthLoginResult, error) {"),
		Line("	users, _ := s.repo.List(ctx)"),
		Linef("	var user *%s", p),
		Linef("	for _, u := range users { if u.%s != nil && u.%s.RefreshToken == refreshToken { user = u; break } }", af, af),
		Line("	if user == nil { return nil, ErrAuthInvalidToken }"),
		Blank(),
	}

	if cfg.HasRefreshExpiry {
		parts = append(parts,
			Linef("	if user.%s.RefreshTokenExpiresAt != nil && user.%s.RefreshTokenExpiresAt.Before(time.Now()) { return nil, ErrAuthTokenExpired }", af, af),
			Blank(),
		)
	}

	parts = append(parts,
		Line("	newAccess := authGenerateToken(32)"),
		Line("	newRefresh := authGenerateToken(64)"),
		Linef("	user.%s.RefreshToken = newRefresh", af),
	)

	if cfg.HasRefreshExpiry {
		parts = append(parts,
			Line("	exp := time.Now().Add(s.config.RefreshExpiry)"),
			Linef("	user.%s.RefreshTokenExpiresAt = &exp", af),
		)
	}

	parts = append(parts,
		Line("	s.repo.Update(ctx, user)"),
		Linef("	return &AuthLoginResult{AccessToken: newAccess, RefreshToken: newRefresh, ExpiresAt: time.Now().Add(s.config.JWTExpiry), %s: user}, nil", p),
		Line("}"),
		Blank(),
	)

	return Concat(CodeMonoid, parts)
}

// =============================================================================
// REACT FRONTEND
// =============================================================================

func generateFrontendTypes() string {
	return `// auth_email_types.ts
export interface SignUpRequest { email: string; password: string; name?: string; }
export interface LoginRequest { email: string; password: string; }
export interface LoginResult { accessToken: string; refreshToken: string; expiresAt: string; user: AuthUser; }
export interface AuthUser { id: string; email: string; name?: string; emailVerified?: boolean; }
`
}

func generateFrontendContext() string {
	return `// AuthEmailContext.tsx
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import type { AuthUser, SignUpRequest, LoginRequest, LoginResult } from './auth_email_types';

interface AuthState { user: AuthUser | null; accessToken: string | null; isAuthenticated: boolean; isLoading: boolean; }
interface AuthEmailContextType extends AuthState {
  signUp: (req: SignUpRequest) => Promise<void>;
  login: (req: LoginRequest) => Promise<void>;
  logout: () => Promise<void>;
  forgotPassword: (email: string) => Promise<void>;
  resetPassword: (token: string, password: string) => Promise<void>;
}

const AuthEmailContext = createContext<AuthEmailContextType | null>(null);

interface Props { children: React.ReactNode; client: any; }

export function AuthEmailProvider({ children, client }: Props) {
  const [state, setState] = useState<AuthState>({ user: null, accessToken: null, isAuthenticated: false, isLoading: true });

  useEffect(() => {
    const stored = localStorage.getItem('auth');
    if (stored) { const { user, accessToken } = JSON.parse(stored); setState({ user, accessToken, isAuthenticated: true, isLoading: false }); }
    else setState(s => ({ ...s, isLoading: false }));
  }, []);

  const signUp = useCallback(async (req: SignUpRequest) => { await client.signUp(req); }, [client]);
  const login = useCallback(async (req: LoginRequest) => {
    const result = await client.login(req);
    localStorage.setItem('auth', JSON.stringify({ user: result.user, accessToken: result.accessToken, refreshToken: result.refreshToken }));
    setState({ user: result.user, accessToken: result.accessToken, isAuthenticated: true, isLoading: false });
  }, [client]);
  const logout = useCallback(async () => { localStorage.removeItem('auth'); setState({ user: null, accessToken: null, isAuthenticated: false, isLoading: false }); }, []);
  const forgotPassword = useCallback(async (email: string) => { await client.forgotPassword({ email }); }, [client]);
  const resetPassword = useCallback(async (token: string, password: string) => { await client.resetPassword({ token, password }); }, [client]);

  return <AuthEmailContext.Provider value={{ ...state, signUp, login, logout, forgotPassword, resetPassword }}>{children}</AuthEmailContext.Provider>;
}

export function useAuthEmail() { const ctx = useContext(AuthEmailContext); if (!ctx) throw new Error('useAuthEmail requires AuthEmailProvider'); return ctx; }
`
}

func generateFrontendForms() string {
	return `// AuthEmailForms.tsx
import React, { useState } from 'react';
import { useAuthEmail } from './AuthEmailContext';

export function SignUpForm({ onSuccess }: { onSuccess?: () => void }) {
  const { signUp } = useAuthEmail();
  const [form, setForm] = useState({ name: '', email: '', password: '', confirm: '' });
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (form.password !== form.confirm) { setError('Passwords do not match'); return; }
    setLoading(true); setError('');
    try { await signUp({ email: form.email, password: form.password, name: form.name }); setSuccess(true); onSuccess?.(); }
    catch (err: any) { setError(err.message || 'Sign up failed'); }
    finally { setLoading(false); }
  };

  if (success) return <div className="p-4 bg-green-50 text-green-800 rounded">Check your email for verification link.</div>;
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && <div className="p-3 bg-red-50 text-red-700 rounded">{error}</div>}
      <input type="text" placeholder="Name" value={form.name} onChange={e => setForm(f => ({ ...f, name: e.target.value }))} className="w-full px-3 py-2 border rounded" />
      <input type="email" placeholder="Email" required value={form.email} onChange={e => setForm(f => ({ ...f, email: e.target.value }))} className="w-full px-3 py-2 border rounded" />
      <input type="password" placeholder="Password" required minLength={8} value={form.password} onChange={e => setForm(f => ({ ...f, password: e.target.value }))} className="w-full px-3 py-2 border rounded" />
      <input type="password" placeholder="Confirm" required value={form.confirm} onChange={e => setForm(f => ({ ...f, confirm: e.target.value }))} className="w-full px-3 py-2 border rounded" />
      <button type="submit" disabled={loading} className="w-full py-2 bg-blue-600 text-white rounded disabled:opacity-50">{loading ? 'Creating...' : 'Sign Up'}</button>
    </form>
  );
}

export function LoginForm({ onSuccess, onForgot }: { onSuccess?: () => void; onForgot?: () => void }) {
  const { login } = useAuthEmail();
  const [form, setForm] = useState({ email: '', password: '' });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault(); setLoading(true); setError('');
    try { await login(form); onSuccess?.(); }
    catch (err: any) { setError(err.message || 'Login failed'); }
    finally { setLoading(false); }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && <div className="p-3 bg-red-50 text-red-700 rounded">{error}</div>}
      <input type="email" placeholder="Email" required value={form.email} onChange={e => setForm(f => ({ ...f, email: e.target.value }))} className="w-full px-3 py-2 border rounded" />
      <input type="password" placeholder="Password" required value={form.password} onChange={e => setForm(f => ({ ...f, password: e.target.value }))} className="w-full px-3 py-2 border rounded" />
      {onForgot && <button type="button" onClick={onForgot} className="text-sm text-blue-600">Forgot password?</button>}
      <button type="submit" disabled={loading} className="w-full py-2 bg-blue-600 text-white rounded disabled:opacity-50">{loading ? 'Signing in...' : 'Sign In'}</button>
    </form>
  );
}

export function ForgotPasswordForm({ onBack }: { onBack?: () => void }) {
  const { forgotPassword } = useAuthEmail();
  const [email, setEmail] = useState('');
  const [sent, setSent] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => { e.preventDefault(); setLoading(true); await forgotPassword(email); setSent(true); setLoading(false); };
  if (sent) return <div className="text-center"><p className="text-green-700">Reset link sent</p>{onBack && <button onClick={onBack} className="mt-2 text-blue-600">Back</button>}</div>;
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <input type="email" placeholder="Email" required value={email} onChange={e => setEmail(e.target.value)} className="w-full px-3 py-2 border rounded" />
      <button type="submit" disabled={loading} className="w-full py-2 bg-blue-600 text-white rounded disabled:opacity-50">{loading ? 'Sending...' : 'Send Reset Link'}</button>
      {onBack && <button type="button" onClick={onBack} className="w-full text-sm text-gray-600">Back</button>}
    </form>
  );
}

export function ResetPasswordForm({ token, onSuccess }: { token: string; onSuccess?: () => void }) {
  const { resetPassword } = useAuthEmail();
  const [form, setForm] = useState({ password: '', confirm: '' });
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (form.password !== form.confirm) { setError('Passwords do not match'); return; }
    setLoading(true);
    try { await resetPassword(token, form.password); setSuccess(true); onSuccess?.(); }
    catch (err: any) { setError(err.message || 'Reset failed'); }
    finally { setLoading(false); }
  };

  if (success) return <div className="p-4 bg-green-50 text-green-800 rounded">Password reset successfully.</div>;
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && <div className="p-3 bg-red-50 text-red-700 rounded">{error}</div>}
      <input type="password" placeholder="New Password" required minLength={8} value={form.password} onChange={e => setForm(f => ({ ...f, password: e.target.value }))} className="w-full px-3 py-2 border rounded" />
      <input type="password" placeholder="Confirm" required value={form.confirm} onChange={e => setForm(f => ({ ...f, confirm: e.target.value }))} className="w-full px-3 py-2 border rounded" />
      <button type="submit" disabled={loading} className="w-full py-2 bg-blue-600 text-white rounded disabled:opacity-50">{loading ? 'Resetting...' : 'Reset Password'}</button>
    </form>
  );
}
`
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			cfg := DetectAuthEmail(f)
			if cfg == nil {
				continue
			}

			pkgName := string(f.GoPackageName)

			// Go backend
			goFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_auth_email.pb.go", f.GoImportPath)
			goFile.P(GenerateBackend(pkgName, cfg).Run())

			// React frontend
			basePath := strings.Replace(f.GeneratedFilenamePrefix, "/go/", "/ui/", 1)

			typesFile := gen.NewGeneratedFile(basePath+"_auth_email_types.ts", "")
			typesFile.P(generateFrontendTypes())

			contextFile := gen.NewGeneratedFile(basePath+"_auth_email_context.tsx", "")
			contextFile.P(generateFrontendContext())

			formsFile := gen.NewGeneratedFile(basePath+"_auth_email_forms.tsx", "")
			formsFile.P(generateFrontendForms())
		}
		return nil
	})
}
