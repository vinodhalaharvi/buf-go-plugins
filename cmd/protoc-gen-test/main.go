// protoc-gen-test generates Go integration tests
// Uses InMemory repo + Mock data + Connect server
// Uses Category Theory: Monoid + Functor + Fold
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	pluginpb "google.golang.org/protobuf/types/pluginpb"
)

// =============================================================================
// CATEGORY THEORY FOUNDATIONS
// =============================================================================

type Monoid[A any] struct {
	Empty  func() A
	Append func(A, A) A
}

type Code struct{ Run func() string }

var CodeMonoid = Monoid[Code]{
	Empty:  func() Code { return Code{Run: func() string { return "" }} },
	Append: func(a, b Code) Code { return Code{Run: func() string { return a.Run() + b.Run() }} },
}

func FoldRight[A, B any](xs []A, z B, f func(A, B) B) B {
	if len(xs) == 0 {
		return z
	}
	return f(xs[0], FoldRight(xs[1:], z, f))
}

func Concat[A any](m Monoid[A], xs []A) A {
	return FoldRight(xs, m.Empty(), func(a A, acc A) A { return m.Append(a, acc) })
}

func Map[A, B any](xs []A, f func(A) B) []B {
	return FoldRight(xs, []B{}, func(a A, acc []B) []B { return append([]B{f(a)}, acc...) })
}

func FoldMap[A, B any](xs []A, m Monoid[B], f func(A) B) B { return Concat(m, Map(xs, f)) }

func Filter[A any](xs []A, pred func(A) bool) []A {
	return FoldRight(xs, []A{}, func(a A, acc []A) []A {
		if pred(a) {
			return append([]A{a}, acc...)
		}
		return acc
	})
}

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }

// =============================================================================
// SERVICE & MESSAGE INFO
// =============================================================================

type ServiceInfo struct {
	Name    string
	Methods []MethodInfo
}

type MethodInfo struct {
	Name       string
	InputType  string
	OutputType string
	Entity     string // Inferred entity (CreateUser -> User)
	Operation  string // Inferred operation (Create, Get, List, Update, Delete)
}

type MessageInfo struct {
	Name   string
	Fields []FieldInfo
	HasID  bool
}

type FieldInfo struct {
	Name      string
	GoName    string
	ProtoKind protoreflect.Kind
	IsEnum    bool
}

func ExtractServiceInfo(svc *protogen.Service) ServiceInfo {
	return ServiceInfo{
		Name: svc.GoName,
		Methods: Map(svc.Methods, func(m *protogen.Method) MethodInfo {
			methodName := m.GoName
			entity, op := inferEntityAndOp(methodName)
			return MethodInfo{
				Name:       methodName,
				InputType:  m.Input.GoIdent.GoName,
				OutputType: m.Output.GoIdent.GoName,
				Entity:     entity,
				Operation:  op,
			}
		}),
	}
}

func inferEntityAndOp(methodName string) (entity, op string) {
	ops := []string{"Create", "Get", "List", "Update", "Delete", "Search", "Find"}
	for _, o := range ops {
		if strings.HasPrefix(methodName, o) {
			return strings.TrimPrefix(methodName, o), o
		}
	}
	return methodName, "Custom"
}

func ExtractMessageInfo(msg *protogen.Message) MessageInfo {
	hasID := false
	fields := Map(msg.Fields, func(f *protogen.Field) FieldInfo {
		name := string(f.Desc.Name())
		if strings.EqualFold(name, "id") {
			hasID = true
		}
		return FieldInfo{
			Name:      name,
			GoName:    f.GoName,
			ProtoKind: f.Desc.Kind(),
			IsEnum:    f.Desc.Kind() == protoreflect.EnumKind,
		}
	})
	return MessageInfo{
		Name:   msg.GoIdent.GoName,
		Fields: fields,
		HasID:  hasID,
	}
}

// =============================================================================
// TEST FILE GENERATOR
// =============================================================================

func GenerateTestFile(services []ServiceInfo, messages []MessageInfo, pkgName, pkgPath string) Code {
	// Find entities (messages with ID)
	entities := Filter(messages, func(m MessageInfo) bool { return m.HasID })

	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-test. DO NOT EDIT."),
		Line("// Integration tests using InMemory repository and Mock data"),
		Blank(),
		Linef("package %s_test", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"net/http"`),
		Line(`	"net/http/httptest"`),
		Line(`	"testing"`),
		Blank(),
		Line(`	"connectrpc.com/connect"`),
		Line(`	"github.com/stretchr/testify/assert"`),
		Line(`	"github.com/stretchr/testify/require"`),
		Linef(`	pb "%s"`, pkgPath),
		Line(")"),
		Blank(),
		GenerateTestHelper(services, entities),
		FoldMap(services, CodeMonoid, func(svc ServiceInfo) Code {
			return GenerateServiceTests(svc, entities)
		}),
	})
}

func GenerateTestHelper(services []ServiceInfo, entities []MessageInfo) Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Line("// TEST HELPERS"),
		Line("// ============================================================================="),
		Blank(),
		Line("type testEnv struct {"),
		Line("	ctx    context.Context"),
		Line("	server *httptest.Server"),
		FoldMap(entities, CodeMonoid, func(e MessageInfo) Code {
			return Linef("	%sRepo pb.%sRepository", lowerFirst(e.Name), e.Name)
		}),
		FoldMap(services, CodeMonoid, func(svc ServiceInfo) Code {
			entity := strings.TrimSuffix(svc.Name, "Service")
			return Linef("	%sClient pb.%sClient", lowerFirst(entity), svc.Name)
		}),
		Line("}"),
		Blank(),
		Line("func setupTest(t *testing.T) *testEnv {"),
		Line("	t.Helper()"),
		Blank(),
		Line("	ctx := context.Background()"),
		Line("	mux := http.NewServeMux()"),
		Blank(),
		Line("	// Create repositories"),
		FoldMap(entities, CodeMonoid, func(e MessageInfo) Code {
			return Linef("	%sRepo := pb.NewInMemory%sRepository()", lowerFirst(e.Name), e.Name)
		}),
		Blank(),
		Line("	// Register handlers"),
		FoldMap(services, CodeMonoid, func(svc ServiceInfo) Code {
			entity := strings.TrimSuffix(svc.Name, "Service")
			return Concat(CodeMonoid, []Code{
				Linef("	%sServer := pb.New%sServer(%sRepo)", lowerFirst(entity), svc.Name, lowerFirst(entity)),
				Linef("	path%s, handler%s := pb.New%sHandler(%sServer)", entity, entity, svc.Name, lowerFirst(entity)),
				Linef("	mux.Handle(path%s, handler%s)", entity, entity),
			})
		}),
		Blank(),
		Line("	// Create test server"),
		Line("	server := httptest.NewServer(mux)"),
		Line("	t.Cleanup(server.Close)"),
		Blank(),
		Line("	// Create clients"),
		FoldMap(services, CodeMonoid, func(svc ServiceInfo) Code {
			entity := strings.TrimSuffix(svc.Name, "Service")
			return Linef("	%sClient := pb.New%sClient(http.DefaultClient, server.URL)", lowerFirst(entity), svc.Name)
		}),
		Blank(),
		Line("	return &testEnv{"),
		Line("		ctx:    ctx,"),
		Line("		server: server,"),
		FoldMap(entities, CodeMonoid, func(e MessageInfo) Code {
			return Linef("		%sRepo: %sRepo,", lowerFirst(e.Name), lowerFirst(e.Name))
		}),
		FoldMap(services, CodeMonoid, func(svc ServiceInfo) Code {
			entity := strings.TrimSuffix(svc.Name, "Service")
			return Linef("		%sClient: %sClient,", lowerFirst(entity), lowerFirst(entity))
		}),
		Line("	}"),
		Line("}"),
		Blank(),
	})
}

func GenerateServiceTests(svc ServiceInfo, entities []MessageInfo) Code {
	return Concat(CodeMonoid, []Code{
		Line("// ============================================================================="),
		Linef("// %s TESTS", strings.ToUpper(svc.Name)),
		Line("// ============================================================================="),
		Blank(),
		FoldMap(svc.Methods, CodeMonoid, func(m MethodInfo) Code {
			return GenerateMethodTest(svc, m, entities)
		}),
	})
}

func GenerateMethodTest(svc ServiceInfo, m MethodInfo, entities []MessageInfo) Code {
	entity := m.Entity
	if entity == "" {
		entity = strings.TrimSuffix(svc.Name, "Service")
	}

	// Find entity message
	var entityMsg *MessageInfo
	for _, e := range entities {
		if e.Name == entity || e.Name == entity+"s" || strings.TrimSuffix(e.Name, "s") == entity {
			entityMsg = &e
			break
		}
	}

	switch m.Operation {
	case "Create":
		return GenerateCreateTest(svc, m, entity, entityMsg)
	case "Get":
		return GenerateGetTest(svc, m, entity, entityMsg)
	case "List":
		return GenerateListTest(svc, m, entity, entityMsg)
	case "Update":
		return GenerateUpdateTest(svc, m, entity, entityMsg)
	case "Delete":
		return GenerateDeleteTest(svc, m, entity, entityMsg)
	default:
		return GenerateGenericTest(svc, m, entity)
	}
}

func GenerateCreateTest(svc ServiceInfo, m MethodInfo, entity string, entityMsg *MessageInfo) Code {
	clientField := lowerFirst(entity) + "Client"

	return Concat(CodeMonoid, []Code{
		Linef("func Test%s_%s_Success(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Linef("	// Create fake %s", entity),
		Linef("	fake%s := pb.Fake%s()", entity, entity),
		Blank(),
		Line("	// Make request"),
		Linef("	req := connect.NewRequest(&pb.%s{", m.InputType),
		Linef("		%s: fake%s,", entity, entity),
		Line("	})"),
		Blank(),
		Linef("	resp, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	// Assert"),
		Line("	require.NoError(t, err)"),
		Line("	require.NotNil(t, resp)"),
		Linef("	assert.NotEmpty(t, resp.Msg.%s.Id)", entity),
		Line("}"),
		Blank(),
		Linef("func Test%s_%s_Validation(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Line("	// Empty request should fail validation"),
		Linef("	req := connect.NewRequest(&pb.%s{})", m.InputType),
		Blank(),
		Linef("	_, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	assert.Error(t, err)"),
		Line("}"),
		Blank(),
	})
}

func GenerateGetTest(svc ServiceInfo, m MethodInfo, entity string, entityMsg *MessageInfo) Code {
	clientField := lowerFirst(entity) + "Client"
	repoField := lowerFirst(entity) + "Repo"

	return Concat(CodeMonoid, []Code{
		Linef("func Test%s_%s_Success(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Line("	// Seed data"),
		Linef("	fake%s := pb.Fake%s()", entity, entity),
		Linef("	id, err := env.%s.Create(env.ctx, fake%s)", repoField, entity),
		Line("	require.NoError(t, err)"),
		Blank(),
		Line("	// Make request"),
		Linef("	req := connect.NewRequest(&pb.%s{", m.InputType),
		Line("		Id: id,"),
		Line("	})"),
		Blank(),
		Linef("	resp, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	// Assert"),
		Line("	require.NoError(t, err)"),
		Line("	require.NotNil(t, resp)"),
		Linef("	assert.Equal(t, id, resp.Msg.%s.Id)", entity),
		Line("}"),
		Blank(),
		Linef("func Test%s_%s_NotFound(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Line("	// Request non-existent ID"),
		Linef("	req := connect.NewRequest(&pb.%s{", m.InputType),
		Line(`		Id: "non-existent-id",`),
		Line("	})"),
		Blank(),
		Linef("	_, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	assert.Error(t, err)"),
		Line("}"),
		Blank(),
	})
}

func GenerateListTest(svc ServiceInfo, m MethodInfo, entity string, entityMsg *MessageInfo) Code {
	clientField := lowerFirst(entity) + "Client"
	repoField := lowerFirst(entity) + "Repo"

	return Concat(CodeMonoid, []Code{
		Linef("func Test%s_%s_Success(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Line("	// Seed data"),
		Linef("	_, err := pb.Seed%ss(env.ctx, env.%s, 5)", entity, repoField),
		Line("	require.NoError(t, err)"),
		Blank(),
		Line("	// Make request"),
		Linef("	req := connect.NewRequest(&pb.%s{})", m.InputType),
		Blank(),
		Linef("	resp, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	// Assert"),
		Line("	require.NoError(t, err)"),
		Line("	require.NotNil(t, resp)"),
		Linef("	assert.Len(t, resp.Msg.%ss, 5)", entity),
		Line("}"),
		Blank(),
		Linef("func Test%s_%s_Empty(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Line("	// No seeding - empty repo"),
		Linef("	req := connect.NewRequest(&pb.%s{})", m.InputType),
		Blank(),
		Linef("	resp, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	// Assert - should return empty list, not error"),
		Line("	require.NoError(t, err)"),
		Line("	require.NotNil(t, resp)"),
		Linef("	assert.Empty(t, resp.Msg.%ss)", entity),
		Line("}"),
		Blank(),
	})
}

func GenerateUpdateTest(svc ServiceInfo, m MethodInfo, entity string, entityMsg *MessageInfo) Code {
	clientField := lowerFirst(entity) + "Client"
	repoField := lowerFirst(entity) + "Repo"

	return Concat(CodeMonoid, []Code{
		Linef("func Test%s_%s_Success(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Line("	// Seed data"),
		Linef("	fake%s := pb.Fake%s()", entity, entity),
		Linef("	id, err := env.%s.Create(env.ctx, fake%s)", repoField, entity),
		Line("	require.NoError(t, err)"),
		Blank(),
		Line("	// Update"),
		Linef("	fake%s.Id = id", entity),
		Linef("	fake%s.Name = \"Updated Name\"", entity),
		Blank(),
		Linef("	req := connect.NewRequest(&pb.%s{", m.InputType),
		Linef("		%s: fake%s,", entity, entity),
		Line("	})"),
		Blank(),
		Linef("	resp, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	// Assert"),
		Line("	require.NoError(t, err)"),
		Line("	require.NotNil(t, resp)"),
		Linef("	assert.Equal(t, \"Updated Name\", resp.Msg.%s.Name)", entity),
		Line("}"),
		Blank(),
		Linef("func Test%s_%s_NotFound(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Linef("	fake%s := pb.Fake%s()", entity, entity),
		Linef("	fake%s.Id = \"non-existent-id\"", entity),
		Blank(),
		Linef("	req := connect.NewRequest(&pb.%s{", m.InputType),
		Linef("		%s: fake%s,", entity, entity),
		Line("	})"),
		Blank(),
		Linef("	_, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	assert.Error(t, err)"),
		Line("}"),
		Blank(),
	})
}

func GenerateDeleteTest(svc ServiceInfo, m MethodInfo, entity string, entityMsg *MessageInfo) Code {
	clientField := lowerFirst(entity) + "Client"
	repoField := lowerFirst(entity) + "Repo"

	return Concat(CodeMonoid, []Code{
		Linef("func Test%s_%s_Success(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Line("	// Seed data"),
		Linef("	fake%s := pb.Fake%s()", entity, entity),
		Linef("	id, err := env.%s.Create(env.ctx, fake%s)", repoField, entity),
		Line("	require.NoError(t, err)"),
		Blank(),
		Line("	// Delete"),
		Linef("	req := connect.NewRequest(&pb.%s{", m.InputType),
		Line("		Id: id,"),
		Line("	})"),
		Blank(),
		Linef("	_, err = env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	// Assert"),
		Line("	require.NoError(t, err)"),
		Blank(),
		Line("	// Verify deleted"),
		Linef("	_, err = env.%s.Get(env.ctx, id)", repoField),
		Line("	assert.Error(t, err)"),
		Line("}"),
		Blank(),
		Linef("func Test%s_%s_NotFound(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Linef("	req := connect.NewRequest(&pb.%s{", m.InputType),
		Line(`		Id: "non-existent-id",`),
		Line("	})"),
		Blank(),
		Linef("	_, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	// Delete of non-existent may or may not error depending on impl"),
		Line("	_ = err"),
		Line("}"),
		Blank(),
	})
}

func GenerateGenericTest(svc ServiceInfo, m MethodInfo, entity string) Code {
	clientField := lowerFirst(entity) + "Client"

	return Concat(CodeMonoid, []Code{
		Linef("func Test%s_%s(t *testing.T) {", svc.Name, m.Name),
		Line("	env := setupTest(t)"),
		Blank(),
		Line("	// TODO: Implement test for custom method"),
		Linef("	req := connect.NewRequest(&pb.%s{})", m.InputType),
		Blank(),
		Linef("	resp, err := env.%s.%s(env.ctx, req)", clientField, m.Name),
		Blank(),
		Line("	// Assert based on expected behavior"),
		Line("	_ = resp"),
		Line("	_ = err"),
		Line("}"),
		Blank(),
	})
}

// =============================================================================
// BENCHMARK GENERATOR
// =============================================================================

func GenerateBenchmarks(services []ServiceInfo, entities []MessageInfo, pkgName, pkgPath string) Code {
	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-test. DO NOT EDIT."),
		Line("// Benchmarks for service operations"),
		Blank(),
		Linef("package %s_test", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"net/http"`),
		Line(`	"net/http/httptest"`),
		Line(`	"testing"`),
		Blank(),
		Line(`	"connectrpc.com/connect"`),
		Linef(`	pb "%s"`, pkgPath),
		Line(")"),
		Blank(),
		FoldMap(services, CodeMonoid, func(svc ServiceInfo) Code {
			return GenerateServiceBenchmarks(svc, entities)
		}),
	})
}

func GenerateServiceBenchmarks(svc ServiceInfo, entities []MessageInfo) Code {
	entity := strings.TrimSuffix(svc.Name, "Service")

	return Concat(CodeMonoid, []Code{
		Linef("func Benchmark%s_Create(b *testing.B) {", svc.Name),
		Line("	ctx := context.Background()"),
		Line("	mux := http.NewServeMux()"),
		Blank(),
		Linef("	repo := pb.NewInMemory%sRepository()", entity),
		Linef("	server := pb.New%sServer(repo)", svc.Name),
		Linef("	path, handler := pb.New%sHandler(server)", svc.Name),
		Line("	mux.Handle(path, handler)"),
		Blank(),
		Line("	ts := httptest.NewServer(mux)"),
		Line("	defer ts.Close()"),
		Blank(),
		Linef("	client := pb.New%sClient(http.DefaultClient, ts.URL)", svc.Name),
		Blank(),
		Line("	b.ResetTimer()"),
		Line("	for i := 0; i < b.N; i++ {"),
		Linef("		fake := pb.Fake%s()", entity),
		Linef("		req := connect.NewRequest(&pb.Create%sRequest{%s: fake})", entity, entity),
		Linef("		_, _ = client.Create%s(ctx, req)", entity),
		Line("	}"),
		Line("}"),
		Blank(),
		Linef("func Benchmark%s_List(b *testing.B) {", svc.Name),
		Line("	ctx := context.Background()"),
		Line("	mux := http.NewServeMux()"),
		Blank(),
		Linef("	repo := pb.NewInMemory%sRepository()", entity),
		Linef("	pb.Seed%ss(ctx, repo, 100) // Pre-seed", entity),
		Blank(),
		Linef("	server := pb.New%sServer(repo)", svc.Name),
		Linef("	path, handler := pb.New%sHandler(server)", svc.Name),
		Line("	mux.Handle(path, handler)"),
		Blank(),
		Line("	ts := httptest.NewServer(mux)"),
		Line("	defer ts.Close()"),
		Blank(),
		Linef("	client := pb.New%sClient(http.DefaultClient, ts.URL)", svc.Name),
		Blank(),
		Line("	b.ResetTimer()"),
		Line("	for i := 0; i < b.N; i++ {"),
		Linef("		req := connect.NewRequest(&pb.List%ssRequest{})", entity),
		Linef("		_, _ = client.List%ss(ctx, req)", entity),
		Line("	}"),
		Line("}"),
		Blank(),
	})
}

// =============================================================================
// HELPERS
// =============================================================================

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			// Extract services
			services := Map(f.Services, ExtractServiceInfo)
			if len(services) == 0 {
				continue
			}

			// Extract messages
			messages := Map(f.Messages, ExtractMessageInfo)

			pkgName := string(f.GoPackageName)
			pkgPath := string(f.GoImportPath)

			// Generate test file
			testFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_test.go", f.GoImportPath)
			testFile.P(GenerateTestFile(services, messages, pkgName, pkgPath).Run())

			// Generate benchmark file
			benchFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_bench_test.go", f.GoImportPath)
			benchFile.P(GenerateBenchmarks(services, messages, pkgName, pkgPath).Run())
		}
		return nil
	})
}
