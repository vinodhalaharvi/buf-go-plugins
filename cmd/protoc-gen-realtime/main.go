// protoc-gen-realtime generates real-time subscription infrastructure
// - WebSocket server with pub/sub (Go)
// - Auto-reconnect hooks (React)
// - Optimistic updates
package main

import (
	"fmt"
	"strings"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
	pluginpb "google.golang.org/protobuf/types/pluginpb"
)

// =============================================================================
// CATEGORY THEORY FOUNDATIONS
// =============================================================================

type Monoid[A any] struct {
	Empty  func() A
	Append func(A, A) A
}

type Code struct{ Run func() string }

var CodeMonoid = Monoid[Code]{
	Empty:  func() Code { return Code{Run: func() string { return "" }} },
	Append: func(a, b Code) Code { return Code{Run: func() string { return a.Run() + b.Run() }} },
}

func Concat[A any](m Monoid[A], xs []A) A {
	if len(xs) == 0 {
		return m.Empty()
	}
	result := xs[0]
	for _, x := range xs[1:] {
		result = m.Append(result, x)
	}
	return result
}

func Map[A, B any](xs []A, f func(A) B) []B {
	result := make([]B, len(xs))
	for i, x := range xs {
		result[i] = f(x)
	}
	return result
}

func FoldMap[A, B any](xs []A, m Monoid[B], f func(A) B) B { return Concat(m, Map(xs, f)) }

func Line(s string) Code                            { return Code{Run: func() string { return s + "\n" }} }
func Linef(format string, args ...interface{}) Code { return Line(fmt.Sprintf(format, args...)) }
func Blank() Code                                   { return Line("") }

// =============================================================================
// MESSAGE INFO
// =============================================================================

type MessageInfo struct {
	Name, GoName string
}

func ExtractMessageInfo(msg *protogen.Message) MessageInfo {
	return MessageInfo{
		Name:   string(msg.Desc.Name()),
		GoName: msg.GoIdent.GoName,
	}
}

// =============================================================================
// GO REALTIME SERVER GENERATOR
// =============================================================================

func GenerateGoRealtime(messages []MessageInfo, pkgName string) Code {
	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-realtime. DO NOT EDIT."),
		Blank(),
		Linef("package %s", pkgName),
		Blank(),
		Line("import ("),
		Line(`	"context"`),
		Line(`	"encoding/json"`),
		Line(`	"log"`),
		Line(`	"net/http"`),
		Line(`	"sync"`),
		Line(`	"time"`),
		Line(""),
		Line(`	"github.com/gorilla/websocket"`),
		Line(")"),
		Blank(),
		generateWebSocketTypes(),
		generateHub(),
		generateClient(),
		generateEventTypes(messages),
		generatePublishMethods(messages),
		generateWebSocketHandler(),
	})
}

func generateWebSocketTypes() Code {
	return Concat(CodeMonoid, []Code{
		Line("// WebSocket configuration"),
		Line("var upgrader = websocket.Upgrader{"),
		Line("	ReadBufferSize:  1024,"),
		Line("	WriteBufferSize: 1024,"),
		Line("	CheckOrigin: func(r *http.Request) bool {"),
		Line("		return true // Configure for production"),
		Line("	},"),
		Line("}"),
		Blank(),
		Line("// Event types"),
		Line("type EventType string"),
		Blank(),
		Line("const ("),
		Line(`	EventTypeCreate EventType = "create"`),
		Line(`	EventTypeUpdate EventType = "update"`),
		Line(`	EventTypeDelete EventType = "delete"`),
		Line(")"),
		Blank(),
		Line("// Event represents a real-time event"),
		Line("type Event struct {"),
		Line("	Type      EventType   `json:\"type\"`"),
		Line("	Entity    string      `json:\"entity\"`"),
		Line("	ID        string      `json:\"id\"`"),
		Line("	Data      interface{} `json:\"data,omitempty\"`"),
		Line("	Timestamp time.Time   `json:\"timestamp\"`"),
		Line("}"),
		Blank(),
		Line("// Subscription represents a client subscription"),
		Line("type Subscription struct {"),
		Line("	Entity string `json:\"entity\"`"),
		Line("	ID     string `json:\"id,omitempty\"` // empty = all entities of type"),
		Line("}"),
		Blank(),
		Line("// ClientMessage from client to server"),
		Line("type ClientMessage struct {"),
		Line("	Action       string       `json:\"action\"` // subscribe, unsubscribe"),
		Line("	Subscription Subscription `json:\"subscription\"`"),
		Line("}"),
		Blank(),
	})
}

func generateHub() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Hub manages all WebSocket connections and subscriptions"),
		Line("type Hub struct {"),
		Line("	clients    map[*Client]bool"),
		Line("	broadcast  chan Event"),
		Line("	register   chan *Client"),
		Line("	unregister chan *Client"),
		Line("	mu         sync.RWMutex"),
		Line("}"),
		Blank(),
		Line("// Global hub instance"),
		Line("var hub *Hub"),
		Blank(),
		Line("// InitHub initializes the global hub"),
		Line("func InitHub() *Hub {"),
		Line("	hub = &Hub{"),
		Line("		clients:    make(map[*Client]bool),"),
		Line("		broadcast:  make(chan Event, 256),"),
		Line("		register:   make(chan *Client),"),
		Line("		unregister: make(chan *Client),"),
		Line("	}"),
		Line("	go hub.run()"),
		Line("	return hub"),
		Line("}"),
		Blank(),
		Line("// GetHub returns the global hub instance"),
		Line("func GetHub() *Hub {"),
		Line("	return hub"),
		Line("}"),
		Blank(),
		Line("func (h *Hub) run() {"),
		Line("	for {"),
		Line("		select {"),
		Line("		case client := <-h.register:"),
		Line("			h.mu.Lock()"),
		Line("			h.clients[client] = true"),
		Line("			h.mu.Unlock()"),
		Line(`			log.Printf("Client connected: %s", client.id)`),
		Blank(),
		Line("		case client := <-h.unregister:"),
		Line("			h.mu.Lock()"),
		Line("			if _, ok := h.clients[client]; ok {"),
		Line("				delete(h.clients, client)"),
		Line("				close(client.send)"),
		Line("			}"),
		Line("			h.mu.Unlock()"),
		Line(`			log.Printf("Client disconnected: %s", client.id)`),
		Blank(),
		Line("		case event := <-h.broadcast:"),
		Line("			h.mu.RLock()"),
		Line("			for client := range h.clients {"),
		Line("				if client.isSubscribed(event.Entity, event.ID) {"),
		Line("					select {"),
		Line("					case client.send <- event:"),
		Line("					default:"),
		Line("						// Client buffer full, skip"),
		Line("					}"),
		Line("				}"),
		Line("			}"),
		Line("			h.mu.RUnlock()"),
		Line("		}"),
		Line("	}"),
		Line("}"),
		Blank(),
		Line("// Publish sends an event to all subscribed clients"),
		Line("func (h *Hub) Publish(event Event) {"),
		Line("	event.Timestamp = time.Now()"),
		Line("	h.broadcast <- event"),
		Line("}"),
		Blank(),
	})
}

func generateClient() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Client represents a WebSocket client"),
		Line("type Client struct {"),
		Line("	id            string"),
		Line("	hub           *Hub"),
		Line("	conn          *websocket.Conn"),
		Line("	send          chan Event"),
		Line("	subscriptions map[string]bool // entity:id or entity:*"),
		Line("	mu            sync.RWMutex"),
		Line("}"),
		Blank(),
		Line("func (c *Client) isSubscribed(entity, id string) bool {"),
		Line("	c.mu.RLock()"),
		Line("	defer c.mu.RUnlock()"),
		Blank(),
		Line("	// Check specific subscription"),
		Line(`	if c.subscriptions[entity+":"+id] {`),
		Line("		return true"),
		Line("	}"),
		Line("	// Check wildcard subscription"),
		Line(`	if c.subscriptions[entity+":*"] {`),
		Line("		return true"),
		Line("	}"),
		Line("	return false"),
		Line("}"),
		Blank(),
		Line("func (c *Client) subscribe(sub Subscription) {"),
		Line("	c.mu.Lock()"),
		Line("	defer c.mu.Unlock()"),
		Blank(),
		Line("	key := sub.Entity"),
		Line(`	if sub.ID != "" {`),
		Line(`		key += ":" + sub.ID`),
		Line("	} else {"),
		Line(`		key += ":*"`),
		Line("	}"),
		Line("	c.subscriptions[key] = true"),
		Line(`	log.Printf("Client %s subscribed to %s", c.id, key)`),
		Line("}"),
		Blank(),
		Line("func (c *Client) unsubscribe(sub Subscription) {"),
		Line("	c.mu.Lock()"),
		Line("	defer c.mu.Unlock()"),
		Blank(),
		Line("	key := sub.Entity"),
		Line(`	if sub.ID != "" {`),
		Line(`		key += ":" + sub.ID`),
		Line("	} else {"),
		Line(`		key += ":*"`),
		Line("	}"),
		Line("	delete(c.subscriptions, key)"),
		Line(`	log.Printf("Client %s unsubscribed from %s", c.id, key)`),
		Line("}"),
		Blank(),
		Line("func (c *Client) readPump() {"),
		Line("	defer func() {"),
		Line("		c.hub.unregister <- c"),
		Line("		c.conn.Close()"),
		Line("	}()"),
		Blank(),
		Line("	c.conn.SetReadLimit(512)"),
		Line("	c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))"),
		Line("	c.conn.SetPongHandler(func(string) error {"),
		Line("		c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))"),
		Line("		return nil"),
		Line("	})"),
		Blank(),
		Line("	for {"),
		Line("		_, message, err := c.conn.ReadMessage()"),
		Line("		if err != nil {"),
		Line("			break"),
		Line("		}"),
		Blank(),
		Line("		var msg ClientMessage"),
		Line("		if err := json.Unmarshal(message, &msg); err != nil {"),
		Line("			continue"),
		Line("		}"),
		Blank(),
		Line("		switch msg.Action {"),
		Line(`		case "subscribe":`),
		Line("			c.subscribe(msg.Subscription)"),
		Line(`		case "unsubscribe":`),
		Line("			c.unsubscribe(msg.Subscription)"),
		Line("		}"),
		Line("	}"),
		Line("}"),
		Blank(),
		Line("func (c *Client) writePump() {"),
		Line("	ticker := time.NewTicker(30 * time.Second)"),
		Line("	defer func() {"),
		Line("		ticker.Stop()"),
		Line("		c.conn.Close()"),
		Line("	}()"),
		Blank(),
		Line("	for {"),
		Line("		select {"),
		Line("		case event, ok := <-c.send:"),
		Line("			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))"),
		Line("			if !ok {"),
		Line("				c.conn.WriteMessage(websocket.CloseMessage, []byte{})"),
		Line("				return"),
		Line("			}"),
		Blank(),
		Line("			data, _ := json.Marshal(event)"),
		Line("			if err := c.conn.WriteMessage(websocket.TextMessage, data); err != nil {"),
		Line("				return"),
		Line("			}"),
		Blank(),
		Line("		case <-ticker.C:"),
		Line("			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))"),
		Line("			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {"),
		Line("				return"),
		Line("			}"),
		Line("		}"),
		Line("	}"),
		Line("}"),
		Blank(),
	})
}

func generateEventTypes(messages []MessageInfo) Code {
	entityConsts := FoldMap(messages, CodeMonoid, func(m MessageInfo) Code {
		return Linef(`	Entity%s = "%s"`, m.GoName, lowerFirst(m.GoName))
	})

	return Concat(CodeMonoid, []Code{
		Line("// Entity types"),
		Line("const ("),
		entityConsts,
		Line(")"),
		Blank(),
	})
}

func generatePublishMethods(messages []MessageInfo) Code {
	return FoldMap(messages, CodeMonoid, func(m MessageInfo) Code {
		return Concat(CodeMonoid, []Code{
			Linef("// Publish%sCreate publishes a create event", m.GoName),
			Linef("func Publish%sCreate(entity *%s) {", m.GoName, m.GoName),
			Line("	if hub == nil { return }"),
			Line("	hub.Publish(Event{"),
			Line("		Type:   EventTypeCreate,"),
			Linef("		Entity: Entity%s,", m.GoName),
			Line("		ID:     entity.Id,"),
			Line("		Data:   entity,"),
			Line("	})"),
			Line("}"),
			Blank(),
			Linef("// Publish%sUpdate publishes an update event", m.GoName),
			Linef("func Publish%sUpdate(entity *%s) {", m.GoName, m.GoName),
			Line("	if hub == nil { return }"),
			Line("	hub.Publish(Event{"),
			Line("		Type:   EventTypeUpdate,"),
			Linef("		Entity: Entity%s,", m.GoName),
			Line("		ID:     entity.Id,"),
			Line("		Data:   entity,"),
			Line("	})"),
			Line("}"),
			Blank(),
			Linef("// Publish%sDelete publishes a delete event", m.GoName),
			Linef("func Publish%sDelete(id string) {", m.GoName),
			Line("	if hub == nil { return }"),
			Line("	hub.Publish(Event{"),
			Line("		Type:   EventTypeDelete,"),
			Linef("		Entity: Entity%s,", m.GoName),
			Line("		ID:     id,"),
			Line("	})"),
			Line("}"),
			Blank(),
			Linef("// %sRepositoryWithEvents wraps repository with event publishing", m.GoName),
			Linef("type %sRepositoryWithEvents struct {", m.GoName),
			Linef("	repo %sRepository", m.GoName),
			Line("}"),
			Blank(),
			Linef("func New%sRepositoryWithEvents(repo %sRepository) *%sRepositoryWithEvents {", m.GoName, m.GoName, m.GoName),
			Linef("	return &%sRepositoryWithEvents{repo: repo}", m.GoName),
			Line("}"),
			Blank(),
			Linef("func (r *%sRepositoryWithEvents) Create(ctx context.Context, entity *%s) (string, error) {", m.GoName, m.GoName),
			Line("	id, err := r.repo.Create(ctx, entity)"),
			Line("	if err == nil {"),
			Line("		entity.Id = id"),
			Linef("		Publish%sCreate(entity)", m.GoName),
			Line("	}"),
			Line("	return id, err"),
			Line("}"),
			Blank(),
			Linef("func (r *%sRepositoryWithEvents) Update(ctx context.Context, entity *%s) error {", m.GoName, m.GoName),
			Line("	err := r.repo.Update(ctx, entity)"),
			Line("	if err == nil {"),
			Linef("		Publish%sUpdate(entity)", m.GoName),
			Line("	}"),
			Line("	return err"),
			Line("}"),
			Blank(),
			Linef("func (r *%sRepositoryWithEvents) Delete(ctx context.Context, id string) error {", m.GoName),
			Line("	err := r.repo.Delete(ctx, id)"),
			Line("	if err == nil {"),
			Linef("		Publish%sDelete(id)", m.GoName),
			Line("	}"),
			Line("	return err"),
			Line("}"),
			Blank(),
			Linef("// Delegate other methods to underlying repo"),
			Linef("func (r *%sRepositoryWithEvents) Get(ctx context.Context, id string) (*%s, error) { return r.repo.Get(ctx, id) }", m.GoName, m.GoName),
			Linef("func (r *%sRepositoryWithEvents) List(ctx context.Context, limit int) ([]*%s, error) { return r.repo.List(ctx, limit) }", m.GoName, m.GoName),
			Linef("func (r *%sRepositoryWithEvents) Exists(ctx context.Context, id string) (bool, error) { return r.repo.Exists(ctx, id) }", m.GoName),
			Linef("func (r *%sRepositoryWithEvents) Count(ctx context.Context) (int64, error) { return r.repo.Count(ctx) }", m.GoName),
			Blank(),
			Line("// Ensure interface compliance"),
			Linef("var _ %sRepository = (*%sRepositoryWithEvents)(nil)", m.GoName, m.GoName),
			Blank(),
		})
	})
}

func generateWebSocketHandler() Code {
	return Concat(CodeMonoid, []Code{
		Line("// WebSocketHandler handles WebSocket connections"),
		Line("func WebSocketHandler(w http.ResponseWriter, r *http.Request) {"),
		Line("	conn, err := upgrader.Upgrade(w, r, nil)"),
		Line("	if err != nil {"),
		Line(`		log.Printf("WebSocket upgrade error: %v", err)`),
		Line("		return"),
		Line("	}"),
		Blank(),
		Line("	client := &Client{"),
		Line(`		id:            r.RemoteAddr,`),
		Line("		hub:           hub,"),
		Line("		conn:          conn,"),
		Line("		send:          make(chan Event, 64),"),
		Line("		subscriptions: make(map[string]bool),"),
		Line("	}"),
		Blank(),
		Line("	client.hub.register <- client"),
		Blank(),
		Line("	go client.writePump()"),
		Line("	go client.readPump()"),
		Line("}"),
		Blank(),
		Line("// RegisterWebSocket registers the WebSocket handler"),
		Line(`func RegisterWebSocket(mux *http.ServeMux) {`),
		Line(`	mux.HandleFunc("/ws", WebSocketHandler)`),
		Line("}"),
	})
}

// =============================================================================
// REACT REALTIME GENERATOR
// =============================================================================

func GenerateReactRealtime(messages []MessageInfo) Code {
	return Concat(CodeMonoid, []Code{
		Line("// Code generated by protoc-gen-realtime. DO NOT EDIT."),
		Blank(),
		Line(`import { useEffect, useRef, useState, useCallback } from "react";`),
		Line(`import { useQueryClient } from "@tanstack/react-query";`),
		Blank(),
		generateReactTypes(),
		generateWebSocketHook(),
		generateEntitySubscriptions(messages),
	})
}

func generateReactTypes() Code {
	return Concat(CodeMonoid, []Code{
		Line("// Types"),
		Line("type EventType = 'create' | 'update' | 'delete';"),
		Blank(),
		Line("interface RealtimeEvent<T = unknown> {"),
		Line("  type: EventType;"),
		Line("  entity: string;"),
		Line("  id: string;"),
		Line("  data?: T;"),
		Line("  timestamp: string;"),
		Line("}"),
		Blank(),
		Line("interface Subscription {"),
		Line("  entity: string;"),
		Line("  id?: string;"),
		Line("}"),
		Blank(),
		Line("type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';"),
		Blank(),
	})
}

func generateWebSocketHook() Code {
	return Concat(CodeMonoid, []Code{
		Line("// WebSocket URL"),
		Line("const WS_URL = (import.meta.env.VITE_WS_URL || 'ws://localhost:8080') + '/ws';"),
		Blank(),
		Line("// Global WebSocket instance"),
		Line("let ws: WebSocket | null = null;"),
		Line("let reconnectTimeout: ReturnType<typeof setTimeout> | null = null;"),
		Line("const listeners = new Map<string, Set<(event: RealtimeEvent) => void>>();"),
		Blank(),
		Line("function connect() {"),
		Line("  if (ws?.readyState === WebSocket.OPEN) return;"),
		Blank(),
		Line("  ws = new WebSocket(WS_URL);"),
		Blank(),
		Line("  ws.onopen = () => {"),
		Line("    console.log('WebSocket connected');"),
		Line("    // Resubscribe to all active subscriptions"),
		Line("    listeners.forEach((_, key) => {"),
		Line("      const [entity, id] = key.split(':');"),
		Line("      ws?.send(JSON.stringify({ action: 'subscribe', subscription: { entity, id: id === '*' ? undefined : id } }));"),
		Line("    });"),
		Line("  };"),
		Blank(),
		Line("  ws.onmessage = (msg) => {"),
		Line("    try {"),
		Line("      const event: RealtimeEvent = JSON.parse(msg.data);"),
		Line("      // Notify specific listeners"),
		Line("      const specificKey = `${event.entity}:${event.id}`;"),
		Line("      listeners.get(specificKey)?.forEach(cb => cb(event));"),
		Line("      // Notify wildcard listeners"),
		Line("      const wildcardKey = `${event.entity}:*`;"),
		Line("      listeners.get(wildcardKey)?.forEach(cb => cb(event));"),
		Line("    } catch (e) {"),
		Line("      console.error('Failed to parse WebSocket message:', e);"),
		Line("    }"),
		Line("  };"),
		Blank(),
		Line("  ws.onclose = () => {"),
		Line("    console.log('WebSocket disconnected, reconnecting...');"),
		Line("    reconnectTimeout = setTimeout(connect, 3000);"),
		Line("  };"),
		Blank(),
		Line("  ws.onerror = (err) => {"),
		Line("    console.error('WebSocket error:', err);"),
		Line("  };"),
		Line("}"),
		Blank(),
		Line("function subscribe(entity: string, id: string | undefined, callback: (event: RealtimeEvent) => void) {"),
		Line("  const key = `${entity}:${id || '*'}`;"),
		Blank(),
		Line("  if (!listeners.has(key)) {"),
		Line("    listeners.set(key, new Set());"),
		Line("    // Send subscribe message if connected"),
		Line("    if (ws?.readyState === WebSocket.OPEN) {"),
		Line("      ws.send(JSON.stringify({ action: 'subscribe', subscription: { entity, id } }));"),
		Line("    }"),
		Line("  }"),
		Blank(),
		Line("  listeners.get(key)!.add(callback);"),
		Blank(),
		Line("  // Ensure connection"),
		Line("  connect();"),
		Blank(),
		Line("  // Return unsubscribe function"),
		Line("  return () => {"),
		Line("    listeners.get(key)?.delete(callback);"),
		Line("    if (listeners.get(key)?.size === 0) {"),
		Line("      listeners.delete(key);"),
		Line("      if (ws?.readyState === WebSocket.OPEN) {"),
		Line("        ws.send(JSON.stringify({ action: 'unsubscribe', subscription: { entity, id } }));"),
		Line("      }"),
		Line("    }"),
		Line("  };"),
		Line("}"),
		Blank(),
		Line("// Base subscription hook"),
		Line("export function useSubscription<T>("),
		Line("  entity: string,"),
		Line("  id?: string,"),
		Line("  onEvent?: (event: RealtimeEvent<T>) => void"),
		Line(") {"),
		Line("  const queryClient = useQueryClient();"),
		Blank(),
		Line("  useEffect(() => {"),
		Line("    const handleEvent = (event: RealtimeEvent<T>) => {"),
		Line("      // Call custom handler"),
		Line("      onEvent?.(event);"),
		Blank(),
		Line("      // Auto-invalidate React Query cache"),
		Line("      if (event.type === 'create' || event.type === 'delete') {"),
		Line("        queryClient.invalidateQueries({ queryKey: [entity + 's'] });"),
		Line("      }"),
		Line("      if (event.type === 'update' || event.type === 'delete') {"),
		Line("        queryClient.invalidateQueries({ queryKey: [entity, event.id] });"),
		Line("      }"),
		Line("    };"),
		Blank(),
		Line("    const unsubscribe = subscribe(entity, id, handleEvent as (event: RealtimeEvent) => void);"),
		Line("    return unsubscribe;"),
		Line("  }, [entity, id, onEvent, queryClient]);"),
		Line("}"),
		Blank(),
		Line("// Connection status hook"),
		Line("export function useConnectionStatus(): ConnectionStatus {"),
		Line("  const [status, setStatus] = useState<ConnectionStatus>('disconnected');"),
		Blank(),
		Line("  useEffect(() => {"),
		Line("    const checkStatus = () => {"),
		Line("      if (!ws) setStatus('disconnected');"),
		Line("      else if (ws.readyState === WebSocket.CONNECTING) setStatus('connecting');"),
		Line("      else if (ws.readyState === WebSocket.OPEN) setStatus('connected');"),
		Line("      else setStatus('disconnected');"),
		Line("    };"),
		Blank(),
		Line("    checkStatus();"),
		Line("    const interval = setInterval(checkStatus, 1000);"),
		Line("    return () => clearInterval(interval);"),
		Line("  }, []);"),
		Blank(),
		Line("  return status;"),
		Line("}"),
		Blank(),
	})
}

func generateEntitySubscriptions(messages []MessageInfo) Code {
	return FoldMap(messages, CodeMonoid, func(m MessageInfo) Code {
		lower := lowerFirst(m.GoName)
		return Concat(CodeMonoid, []Code{
			Line("// ============================================================================="),
			Linef("// %s Subscriptions", m.GoName),
			Line("// ============================================================================="),
			Blank(),
			Linef("// Subscribe to all %s changes", m.GoName),
			Linef("export function use%sSubscription(onEvent?: (event: RealtimeEvent<%s>) => void) {", m.GoName, m.GoName),
			Linef(`  useSubscription<%s>("%s", undefined, onEvent);`, m.GoName, lower),
			Line("}"),
			Blank(),
			Linef("// Subscribe to a specific %s", m.GoName),
			Linef("export function use%sItemSubscription(id: string, onEvent?: (event: RealtimeEvent<%s>) => void) {", m.GoName, m.GoName),
			Linef(`  useSubscription<%s>("%s", id, onEvent);`, m.GoName, lower),
			Line("}"),
			Blank(),
			Linef("// %s list with real-time updates", m.GoName),
			Linef("export function use%ssRealtime() {", m.GoName),
			Linef("  use%sSubscription();", m.GoName),
			Linef("  // The useSubscription hook auto-invalidates the React Query cache"),
			Linef("  // so use%ss() will automatically refetch", m.GoName),
			Line("}"),
			Blank(),
			Linef("// Single %s with real-time updates", m.GoName),
			Linef("export function use%sRealtime(id: string) {", m.GoName),
			Linef("  use%sItemSubscription(id);", m.GoName),
			Linef("  // The useSubscription hook auto-invalidates the React Query cache"),
			Linef("  // so use%s(id) will automatically refetch", m.GoName),
			Line("}"),
			Blank(),
		})
	})
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate || len(f.Messages) == 0 {
				continue
			}

			messages := Map(f.Messages, ExtractMessageInfo)
			pkgName := string(f.GoPackageName)

			// Generate Go realtime server
			goFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_realtime.pb.go", f.GoImportPath)
			goFile.P(GenerateGoRealtime(messages, pkgName).Run())

			// Generate React realtime hooks
			tsFile := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_realtime.ts", f.GoImportPath)
			tsFile.P(GenerateReactRealtime(messages).Run())
		}
		return nil
	})
}

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			result = append(result, '_')
		}
		result = append(result, unicode.ToLower(r))
	}
	return string(result)
}
