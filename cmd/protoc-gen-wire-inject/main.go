// protoc-gen-wire-inject generates the wire.go injector file
// This is the final piece - generates InitializeServer and ProviderSet
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	pluginpb "google.golang.org/protobuf/types/pluginpb"
)

const entityExtensionNumber = 50000

// =============================================================================
// CODE HELPERS
// =============================================================================

type Code struct{ Run func() string }

var empty = Code{Run: func() string { return "" }}

func append2(a, b Code) Code { return Code{Run: func() string { return a.Run() + b.Run() }} }

func concat(codes ...Code) Code {
	result := empty
	for _, c := range codes {
		result = append2(result, c)
	}
	return result
}

func line(s string) Code                    { return Code{Run: func() string { return s + "\n" }} }
func linef(f string, a ...interface{}) Code { return line(fmt.Sprintf(f, a...)) }
func blank() Code                           { return line("") }

// =============================================================================
// ENTITY DETECTION
// =============================================================================

func hasEntityOption(msg *protogen.Message) bool {
	opts := msg.Desc.Options()
	if opts == nil {
		return false
	}
	optsProto, ok := opts.(*descriptorpb.MessageOptions)
	if !ok {
		return false
	}
	b, _ := proto.Marshal(optsProto)
	return containsTag(b, entityExtensionNumber)
}

func containsTag(b []byte, fieldNum int32) bool {
	tag := uint64(fieldNum<<3 | 2)
	i := 0
	for i < len(b) {
		v, n := varint(b[i:])
		if n == 0 {
			break
		}
		if v == tag {
			return true
		}
		i += n
		switch v & 0x7 {
		case 0:
			_, vn := varint(b[i:])
			i += vn
		case 1:
			i += 8
		case 2:
			length, ln := varint(b[i:])
			i += ln + int(length)
		case 5:
			i += 4
		default:
			return false
		}
	}
	return false
}

func varint(b []byte) (uint64, int) {
	var x uint64
	for n := 0; n < len(b) && n < 10; n++ {
		x |= uint64(b[n]&0x7f) << (7 * n)
		if b[n] < 0x80 {
			return x, n + 1
		}
	}
	return 0, 0
}

// =============================================================================
// CODE GENERATION
// =============================================================================

func generateWireInject(services []*protogen.Service, pkgName, pbImportPath, connectPkg string) Code {
	// Build handler registrations
	handlerParams := empty
	handlerCalls := empty
	for _, svc := range services {
		handlerParams = append2(handlerParams, linef("	%s *%s,", lowerFirst(svc.GoName), svc.GoName))
		handlerCalls = append2(handlerCalls, linef("	mux.Handle(%s.New%sHandler(%s))", extractPkgName(connectPkg), svc.GoName, lowerFirst(svc.GoName)))
	}

	return concat(
		line("// Code generated by protoc-gen-wire-inject. DO NOT EDIT."),
		line("// Wire dependency injection setup."),
		blank(),
		line("//go:build wireinject"),
		line("// +build wireinject"),
		blank(),
		linef("package %s", pkgName),
		blank(),
		line("import ("),
		line(`	"net/http"`),
		blank(),
		line(`	"cloud.google.com/go/firestore"`),
		line(`	"github.com/google/wire"`),
		linef(`	"%s"`, connectPkg),
		line(")"),
		blank(),
		line("// ============================================================================="),
		line("// SERVER"),
		line("// ============================================================================="),
		blank(),
		line("// Server holds the HTTP server and all services"),
		line("type Server struct {"),
		line("	HTTPServer *http.Server"),
		line("}"),
		blank(),
		line("// RegisterHandlers wires all service handlers to the mux"),
		line("func RegisterHandlers("),
		line("	mux *http.ServeMux,"),
		line("	httpServer *http.Server,"),
		handlerParams,
		line(") *Server {"),
		handlerCalls,
		line("	return &Server{HTTPServer: httpServer}"),
		line("}"),
		blank(),
		line("// ============================================================================="),
		line("// WIRE PROVIDERS"),
		line("// ============================================================================="),
		blank(),
		line("// ProviderSet combines all providers needed for the server"),
		line("var ProviderSet = wire.NewSet("),
		line("	RepositorySet,"),
		line("	ServiceSet,"),
		line("	NewServerMux,"),
		line("	NewHTTPServer,"),
		line("	RegisterHandlers,"),
		line(")"),
		blank(),
		line("// ============================================================================="),
		line("// WIRE INJECTOR"),
		line("// ============================================================================="),
		blank(),
		line("// InitializeServer creates a fully wired server"),
		line("func InitializeServer(client *firestore.Client, cfg *ServerConfig) (*Server, error) {"),
		line("	wire.Build(ProviderSet)"),
		line("	return nil, nil"),
		line("}"),
		blank(),
	)
}

// =============================================================================
// MAIN
// =============================================================================

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate || len(f.Services) == 0 {
				continue
			}

			// Check if there are any entities
			hasEntities := false
			for _, msg := range f.Messages {
				if hasEntityOption(msg) {
					hasEntities = true
					break
				}
			}
			if !hasEntities {
				continue
			}

			pkgName := string(f.GoPackageName)
			pbImportPath := string(f.GoImportPath)
			connectPkg := pbImportPath + "/" + strings.ToLower(pkgName) + "connect"

			g := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+"_wire_inject.pb.go", f.GoImportPath)
			g.P(generateWireInject(f.Services, pkgName, pbImportPath, connectPkg).Run())
		}
		return nil
	})
}

// =============================================================================
// HELPERS
// =============================================================================

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func extractPkgName(importPath string) string {
	parts := strings.Split(importPath, "/")
	return parts[len(parts)-1]
}
